<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法题易错点整理 | Journey</title><meta name="author" content="ldy"><meta name="copyright" content="ldy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这篇博客用于提醒自己在写算法题时，很容易忽视的易错点，有时明明是很小的问题，却花了好长时间才发现。 2024&#x2F;12&#x2F;10 要考试了，此博客除了易错点整理外，还整理了各种算法思想来应对考试！例题是选取pta上面我提交了好几次才ac的题目。┭┮﹏┭┮ 一、易错点1.qsort的cmp函数如下图代码，a.d 和b.d都是double类型,如果return语句是a.d-b.d，那么当a">
<meta property="og:type" content="article">
<meta property="og:title" content="算法题易错点整理">
<meta property="og:url" content="http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Journey">
<meta property="og:description" content="这篇博客用于提醒自己在写算法题时，很容易忽视的易错点，有时明明是很小的问题，却花了好长时间才发现。 2024&#x2F;12&#x2F;10 要考试了，此博客除了易错点整理外，还整理了各种算法思想来应对考试！例题是选取pta上面我提交了好几次才ac的题目。┭┮﹏┭┮ 一、易错点1.qsort的cmp函数如下图代码，a.d 和b.d都是double类型,如果return语句是a.d-b.d，那么当a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png">
<meta property="article:published_time" content="2024-11-09T04:35:56.000Z">
<meta property="article:modified_time" content="2024-12-24T13:52:25.354Z">
<meta property="article:author" content="ldy">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png"><link rel="shortcut icon" href="/img/logo2.jpeg"><link rel="canonical" href="http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法题易错点整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-24 21:52:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/fj/')"><nav id="nav"><span id="blog-info"><a href="/" title="Journey"><img class="site-icon" src="/img/logo.jpeg"/><span class="site-name">Journey</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法题易错点整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-09T04:35:56.000Z" title="发表于 2024-11-09 12:35:56">2024-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T13:52:25.354Z" title="更新于 2024-12-24 21:52:25">2024-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法题易错点整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这篇博客用于提醒自己在写算法题时，很容易忽视的易错点，有时明明是很小的问题，却花了好长时间才发现。</p>
<p>2024&#x2F;12&#x2F;10 要考试了，此博客除了易错点整理外，还整理了各种算法思想来应对考试！例题是选取pta上面我提交了好几次才ac的题目。┭┮﹏┭┮</p>
<h1 id="一、易错点"><a href="#一、易错点" class="headerlink" title="一、易错点"></a>一、易错点</h1><h2 id="1-qsort的cmp函数"><a href="#1-qsort的cmp函数" class="headerlink" title="1.qsort的cmp函数"></a>1.qsort的cmp函数</h2><p>如下图代码，a.d 和b.d都是double类型,如果return语句是a.d-b.d，那么当a.d和b.d的整数位的值相同时，它们并不会排序，导致排序有问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * x, <span class="type">const</span> <span class="type">void</span> * y)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">a</span> =</span> *(<span class="keyword">struct</span> <span class="built_in">map</span>*)x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">b</span> =</span> *(<span class="keyword">struct</span> <span class="built_in">map</span>*)y;</span><br><span class="line">    <span class="keyword">if</span>(a.d &gt; b.d)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-memset函数"><a href="#2-memset函数" class="headerlink" title="2.memset函数"></a>2.memset函数</h2><p>void *memset(void *str, int c, size_t n)</p>
<p>str是数组名，c是数值，n是sizeof(数组名)</p>
<p>例如：memset(arr, 0, sizeof(arr));</p>
<p>memset对于char数组，可以任意c赋值，而int数组只能用于赋值0。因为它是按字节赋值的。</p>
<p>参考链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/Supreme7/article/details/115431235">memset()函数的用法详解-CSDN博客</a></p>
<h2 id="3-strcmp函数"><a href="#3-strcmp函数" class="headerlink" title="3.strcmp函数"></a>3.strcmp函数</h2><h2 id="4-c-的队列对象"><a href="#4-c-的队列对象" class="headerlink" title="4.c++的队列对象"></a>4.c++的队列对象</h2><h2 id="5-qsort函数"><a href="#5-qsort函数" class="headerlink" title="5.qsort函数"></a>5.qsort函数</h2><p>qsort函数包含四个参数，分别是：</p>
<p>1.数组名</p>
<p>2.元素个数（从前往后计算）</p>
<p>3.数组元素所占字节（int，double，char等所占字节）</p>
<p>4.排序原则（递增，递减，奇偶交叉等）</p>
<p>使用例子：</p>
<p>int arr[100];</p>
<p>qsort(arr, n, sizeof(int), cmp);</p>
<p>参考链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/Cooler_z/article/details/122384559">C语言排序神器——qsort函数（看这一篇，足矣）-CSDN博客</a></p>
<h1 id="二、算法整理"><a href="#二、算法整理" class="headerlink" title="二、算法整理"></a>二、算法整理</h1><h2 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h2><h3 id="1）普通的0-1背包问题"><a href="#1）普通的0-1背包问题" class="headerlink" title="1）普通的0-1背包问题"></a>1）普通的0-1背包问题</h3><p>直接根据动态规划来做</p>
<p>但是，注意，有时会有坑，比如如下代码，问题出在第18行，j应该是&gt;&#x3D;0,而不是&gt;0,原因是vol[i]可能为0.</p>
<p>因为题目的输入要求为</p>
<p>第一行包含整数 T ，即个案数。后面是 T 个案例，每个案例有三行，第一行包含两个整数 N ， V ， （N &lt;&#x3D; 1000 ， V &lt;&#x3D; 1000 ） 代表骨头的数量和他的袋子的体积。第二行包含 N 个整数，表示每个骨骼的值。第三行包含 N 个整数，表示每个骨骼的体积。</p>
<p>这里V没有说大于0，所以0也是可能的。真的吐了，检查了半天，也太恶心了，正常来说肯定大于0啊。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int t, n, v;</span><br><span class="line">    int val[1111] = &#123;0&#125;, vol[1111] = &#123;0&#125;;</span><br><span class="line">    int dp[1111] = &#123;0&#125;;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t-- &gt; 0)&#123;</span><br><span class="line">        memset(val, 0, sizeof(val));</span><br><span class="line">        memset(vol, 0, sizeof(vol));</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;n, &amp;v);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;vol[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = v; j &gt; 0; j--)&#123;</span><br><span class="line">                if(j &gt;= vol[i])</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-vol[i]] + val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2）普通的完全背包问题"><a href="#2）普通的完全背包问题" class="headerlink" title="2）普通的完全背包问题"></a>2）普通的完全背包问题</h3><p>即可以取任意个相同的物品，应该对于每一个物品，都把它遍历至容量结束为止，可以参考如下代码。</p>
<p>题目链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45808737/article/details/115147213">湫湫系列故事——减肥记I(HDU-4808)-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">111</span>], b[<span class="number">111</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">111111</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = b[i]; j &lt;= m; j ++)&#123;</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-b[i]] + a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）对于判断是否装满背包的完全背包情况下"><a href="#3）对于判断是否装满背包的完全背包情况下" class="headerlink" title="3）对于判断是否装满背包的完全背包情况下"></a>3）对于判断是否装满背包的完全背包情况下</h3><p>得最大&#x2F;最小的价值情况，要额外进行判段，给每一个物品从头遍历至容量最大值时，先判断该容量是否可以装满，可以则进行赋值，不行则不管它。</p>
<p>题目链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/Alanrookie/article/details/107468511">Piggy-Bank HDU - 1114 （完全背包模板题）_在acm能够做任何事情之前,必须编制预算并获得必要的财政支持。这一行动的主要收入-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">600</span>], w[<span class="number">600</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">11000</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t -- &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;e, &amp;f);</span><br><span class="line">        f = f - e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= f; i++)&#123;</span><br><span class="line">            dp[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p[i], &amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = w[i]; j &lt;= f; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - w[i]] != INF)&#123;</span><br><span class="line">                    dp[j] = min(dp[j], dp[j-w[i]] + p[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[f] != INF)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;</span>, dp[f]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;This is impossible.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4）对于普通背包问题，不要进行额外判断了，会出错"><a href="#4）对于普通背包问题，不要进行额外判断了，会出错" class="headerlink" title="4）对于普通背包问题，不要进行额外判断了，会出错"></a>4）对于普通背包问题，不要进行额外判断了，会出错</h3><p>和第二点的题目一样，但使用了额外判断时不能通过。</p>
<p>未通过代码如下，原因是，从后找能完全符合容量的幸福度不一定是最大的，这是因为占满容量的限制。导致越大的容量价值不一定最高。</p>
<p>例如 价值    容量</p>
<p>​		 111      100</p>
<p>​		   1         123</p>
<p>这个情况下，123容量装满只有1元，而100容量装满有111元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int max(int x, int y)&#123;</span><br><span class="line">    if(x &gt; y)</span><br><span class="line">        return x;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    int a[111], b[111];</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) != EOF)&#123;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;a[i], &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int dp[111111];</span><br><span class="line">        for(int i = 0; i &lt; 111111; i++)&#123;</span><br><span class="line">            dp[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = b[i]; j &lt;= m; j ++)&#123;</span><br><span class="line">                if(dp[j - b[i]] != -1)</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-b[i]] + a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[m] != -1)</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[m]);</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int i = m - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">                if(dp[i] != -1)&#123;</span><br><span class="line">                    printf(&quot;%d&quot;, dp[i]);</span><br><span class="line">                    break;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-放挡板法"><a href="#2-放挡板法" class="headerlink" title="2.放挡板法"></a>2.放挡板法</h2><p>核心思想，<strong>数量最多的种类的数量值 - 1&lt;&#x3D;总数-数量最多的种类的数量值</strong>时，才可以将同种类的物品都隔开。</p>
<h3 id="例题，吃糖果"><a href="#例题，吃糖果" class="headerlink" title="例题，吃糖果"></a>例题，吃糖果</h3><p>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样； 可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？ 请你写个程序帮忙计算一下。</p>
<p>输入格式:</p>
<p>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;&#x3D;1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;&#x3D;1000000)。 </p>
<p>输出格式:</p>
<p>对于每组数据，输出一行，包含一个”Yes”或者”No”。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4 1 1</span><br><span class="line">5</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	while (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n, num;</span><br><span class="line">		//long long保险，毕竟有可能要加很多数，有很大几率超出int</span><br><span class="line">		long long sum = 0;</span><br><span class="line">		//最大值假定-1完美没问题，因为题目输入都是自然数</span><br><span class="line">		int max = -1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		while (n--)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">			if (max &lt; num)</span><br><span class="line">				max = num;</span><br><span class="line">			sum += num;</span><br><span class="line">		&#125;</span><br><span class="line">		//个人感觉这个写法容易理解</span><br><span class="line">		if (sum - max &lt;= max - 2)</span><br><span class="line">		//sum - max &lt; max - 1</span><br><span class="line">		//sum - max + 1 &lt; max</span><br><span class="line">		//都是等价的</span><br><span class="line">			printf(&quot;No\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;Yes\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-贪心"><a href="#3-贪心" class="headerlink" title="3.贪心"></a>3.贪心</h2><p><strong>核心思想：每次都先取最优解</strong></p>
<h3 id="例题，田忌赛马"><a href="#例题，田忌赛马" class="headerlink" title="例题，田忌赛马"></a>例题，田忌赛马</h3><p><strong>输入格式:</strong></p>
<p>输入最多包含 50 个测试用例。每个情况都以第一行的正整数 n （n &lt;&#x3D; 1000） 开始，这是每边的马匹数量。第二行接下来的 n 个整数是 Tian 的马的速度。然后第三行的下一个 n 个整数是国王的马的速度。input 以一行结尾，该行在最后一个测试用例后有一个 0。</p>
<p><strong>输出格式:</strong></p>
<p>对于每个 Importing case，输出一行包含单个数字的行，这是 Tian Ji 将获得的最大金额，以银元为单位。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">92 83 71</span><br><span class="line">95 87 74</span><br><span class="line">2</span><br><span class="line">20 20</span><br><span class="line">20 20</span><br><span class="line">2</span><br><span class="line">20 19</span><br><span class="line">22 18</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>用田忌最快的马与王最快的马相比较</p>
<p>如果田忌的快马比王的快马要快</p>
<p>果断把先用田忌的快马先赢一把(这样赢是代价最小的)</p>
<p>如果田忌的快马比王的快马要慢</p>
<p>果断把最慢的马与王最快的马比赛(因为反正都要输，这样我输的价值更大，因为我把最快的马比下去了，可以增加后面其他马赢的机会)</p>
<p>如果田忌的快马与王的快马<strong>速度一样</strong>——重点！！！</p>
<p>拿田忌最慢的马和王最慢的马比较</p>
<p>慢马能赢就让慢马赢，直到慢马比王的慢马速度一样或者更慢时，让慢马和王的快马比，</p>
<p>之所以慢马速度相同时依旧要让慢马输给快马的原因是如下情况</p>
<p>王     90 80 70</p>
<p>田忌 90 80 70</p>
<p>这时候，如果慢马比掉快马，田忌后面两只都能赢，最后得分200，但如果慢马依旧和慢马比，得分最后是0。</p>
<p>此外，还需要判断，是否慢吗和快马的速度一样，因为有可能是如下形式</p>
<p>王     90 90 90</p>
<p>田忌 90 90 90</p>
<p>这种情况，不需要减得分。</p>
<p>答案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = *(<span class="type">int</span>*)a;</span><br><span class="line">    <span class="type">int</span> n2 = *(<span class="type">int</span>*)b;</span><br><span class="line">    <span class="keyword">return</span> n2 - n1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> tianji[num];</span><br><span class="line">        <span class="type">int</span> king[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; num; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tianji[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;king[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        qsort(tianji, num, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">        qsort(king, num, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">        <span class="type">int</span> end = num - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(king[i] &gt; tianji[top])&#123;</span><br><span class="line">                score -= <span class="number">200</span>;</span><br><span class="line">                end -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(king[i] &lt; tianji[top])&#123;</span><br><span class="line">                score += <span class="number">200</span>;</span><br><span class="line">                top += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//慢马能赢就让它赢</span></span><br><span class="line">                <span class="keyword">if</span>(tianji[end] &gt; king[num<span class="number">-1</span>])&#123;</span><br><span class="line">                    score+= <span class="number">200</span>;</span><br><span class="line">                    end -= <span class="number">1</span>;</span><br><span class="line">                    num-= <span class="number">1</span>;</span><br><span class="line">                    i -= <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tianji[end] == king[i])&#123;</span><br><span class="line">                    end -= <span class="number">1</span>; <span class="comment">//慢吗和王的快马的速度一样时不需要减得分</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    score -= <span class="number">200</span>; <span class="comment">//慢马和王的慢马速度一样或者更慢，且慢马比对面快马慢时，需要减得分</span></span><br><span class="line">                    end -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h2><p><strong>核心思想：确立后续</strong></p>
<h3 id="例题一、母牛的故事"><a href="#例题一、母牛的故事" class="headerlink" title="例题一、母牛的故事"></a>例题一、母牛的故事</h3><p>有一头母牛，它每年年初生一头小母牛。 每头小母牛从第四个年头开始，每年年初也生一头小母牛。 请编程实现在第n年的时候，共有多少头母牛？</p>
<p>输入格式:</p>
<p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n&#x3D;0表示输入数据的结束，不做处理。</p>
<p>输出格式:</p>
<p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>解法：n年母牛的数量等于n-1年母牛的数量加上n-3年母牛的数量，因为n-3年的所有母牛到n年都已经成年了，所以第n年出生的母牛等于n-3年的母牛数量。而第n年的母牛数量等于去年母牛数量加新生母牛数量。故可得递推式m[n] &#x3D; m[n-1] + m[n-3]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long m[55];</span><br><span class="line">    m[1] = 1;</span><br><span class="line">    m[2] = 2;</span><br><span class="line">    m[3] = 3;</span><br><span class="line">    m[4] = 4;</span><br><span class="line">    for(int i = 5; i &lt; 55; i++)&#123;</span><br><span class="line">        m[i] = m[i - 1] + m[i - 3];</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, m[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="例题二、儿童队列"><a href="#例题二、儿童队列" class="headerlink" title="例题二、儿童队列"></a>例题二、儿童队列</h3><p>PHT School 有很多学生。有一天，名叫 PigHeader 的校长希望所有学生站成一排。他规定女孩不能单身。换句话说，要么队列中没有女孩，要么不止一个女孩并排站着。情况 n&#x3D;4（n 是孩子的数量）类似于<br>FFFF、FFFM、MFFF、FFMM、MFFM、MMFF、MMMM<br>这里 F 代表女孩，M 代表男孩。满足校长需求的队列总数为 7。你能做一个程序来找到有 n 个孩子的队列总数吗？</p>
<p>输入格式:</p>
<p>此问题有多种情况，并由 EOF 结束。在每种情况下，只有一个整数 n 表示子项的数量 （1&lt;&#x3D;n&lt;&#x3D;1000）</p>
<p>输出格式:</p>
<p>对于每个测试用例，只有一个整数表示满足 Headmaster 需求的队列数量。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>解法：</p>
<p>设f[n]合法</p>
<p>前提，队尾是M,那么前面一定要合法，因为非法无法变成合法。若队伍最后两位是MF,那么只有去掉最后两位后是合法，且该队伍继续进入的下一位是F的情况非法才能变为合法。</p>
<p>当f[n]的队尾是M时，前n-1个数肯定合法，所以f[n] 的数量等于 f[n-1] 的数量</p>
<p>当f[n]的队尾是F时，要求f[n]合法，所以f[n-1]的队尾是F.</p>
<p>此时，f[n-2]既可以合法又可以非法</p>
<p>f[n-2]合法时，f[n]的数量等于f[n-2].</p>
<p>而f[n-2]非法时，f[n-2]的队尾两个元素为MF。所以f[n-4]是合法的，f[n]数量等于f[n-4]</p>
<p>综上三种情况整合起来，得递推式f[n] &#x3D; f[n-1] + f[n-2] + f[n-4]。</p>
<p>此外，本题还要求高精度，超过了long long，所以用了二维数组来存值每个十进制位的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long f[1001][101] =&#123;0&#125;;</span><br><span class="line">    f[0][1] = 1;</span><br><span class="line">    f[1][1] = 1;</span><br><span class="line">    f[2][1] = 2;</span><br><span class="line">    f[3][1] = 4;</span><br><span class="line">    f[4][1] = 7;</span><br><span class="line">    for(int i = 5; i &lt; 1001; i++)&#123;</span><br><span class="line">        int add =0;</span><br><span class="line">        for(int j = 1; j &lt;= 100; j++)&#123;</span><br><span class="line">            f[i][j] = add + f[i - 1][j] + f[i - 2][j] + f[i - 4][j];</span><br><span class="line">            add = f[i][j] / 10000;</span><br><span class="line">            f[i][j] = f[i][j] % 10000;</span><br><span class="line">            if(add == 0 &amp;&amp; f[i][j] == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;k) != EOF)&#123;</span><br><span class="line">        int end = 0;</span><br><span class="line">        for(int i = 100; i  &gt; 0; i--)&#123;</span><br><span class="line">            if(f[k][i] != 0)&#123;</span><br><span class="line">                end = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d&quot;, f[k][end--]);</span><br><span class="line">        for(int j = end; j &gt; 0; j--)&#123;</span><br><span class="line">            printf(&quot;%04d&quot;, f[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h2><h3 id="例题一、免费馅饼"><a href="#例题一、免费馅饼" class="headerlink" title="例题一、免费馅饼"></a>例题一、免费馅饼</h3><p>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：<br><img src="http://acm.hdu.edu.cn/data/images/1176_1.jpg" alt="img"><br>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</p>
<p>输入格式:</p>
<p>输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n&#x3D;0时输入结束。</p>
<p>输出格式:</p>
<p>每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。<br>提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5 1</span><br><span class="line">4 1</span><br><span class="line">6 1</span><br><span class="line">7 2</span><br><span class="line">7 2</span><br><span class="line">8 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="例题二、搬寝室"><a href="#例题二、搬寝室" class="headerlink" title="例题二、搬寝室"></a>例题二、搬寝室</h3><p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 &#x3D; 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</p>
<p>输入格式:</p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;&#x3D;2*k&lt;&#x3D;n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>输出格式:</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="例题三、最大总和"><a href="#例题三、最大总和" class="headerlink" title="例题三、最大总和"></a>例题三、最大总和</h3><p>给定序列 a[1]，a[2]，a[3]……a[n]，你的工作是计算子序列的最大和。例如，给定 （6，-1,5,4，-7），此序列中的最大总和为 6 + （-1） + 5 + 4 &#x3D; 14。</p>
<p>输入格式:</p>
<p>输入的第一行包含一个整数 T（1&lt;&#x3D;T&lt;&#x3D;20），表示测试用例的数量。然后是 T 行，每行以一个数字 N（1&lt;&#x3D;N&lt;&#x3D;100000） 开头，然后是 N 个整数（所有整数都在 -1000 到 1000 之间）。</p>
<p>输出格式:</p>
<p>对于每个测试用例，您应该输出两行。第一行是 “Case #：”，# 表示测试用例的编号。第二行包含三个整数，序列中的 Max Sum、子序列的开始位置、子序列的结束位置。如果有多个结果，则输出第一个结果。在两个 case 之间输出一个空行。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 6 -1 5 4 -7</span><br><span class="line">7 0 6 -1 1 -6 7 -5</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">14 1 4</span><br><span class="line"></span><br><span class="line">Case 2:</span><br><span class="line">7 1 6</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>解法: </p>
<p>前提，若第n个元素前面的最大序列值小于0，果断舍弃前面的值，单独列出做为起始值。</p>
<p>从头开始，用temp不断累加遍历到的元素，不断与max进行比较。若temp&lt;0,则说明后面的值没必要留着前面累赘了，放弃前面，temp&#x3D;0重新开始记录。</p>
<p>设dp[n]是当前最大序列值数组</p>
<p>则可得动态规划式：dp[n] &#x3D; dp[n-1] &gt; 0 ? m[n] + dp[n-1] : m[n]。</p>
<p>下面没有用这个式子，但实际想法差不多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">        int len;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;len);</span><br><span class="line">        int m[100001] = &#123;0&#125;;</span><br><span class="line">        for(int i = 1; i &lt;= len; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        int start = 1; </span><br><span class="line">        int up = 1;</span><br><span class="line">        int end = 1;</span><br><span class="line">        int max = -10000;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">​    for(int i = 1; i &lt;= len; i++)&#123;</span><br><span class="line">​        temp += m[i];</span><br><span class="line">​        if(temp &gt; max)&#123;</span><br><span class="line">​            up = start;</span><br><span class="line">​            max = temp;</span><br><span class="line">​            end = i;</span><br><span class="line">​        &#125;if(temp &lt; 0)&#123;</span><br><span class="line">​            start = i + 1;</span><br><span class="line">​            temp = 0;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    printf(&quot;Case %d:\n%d %d %d\n&quot;, j, max, up, end);</span><br><span class="line">​    if(j!=n)&#123;</span><br><span class="line">​        printf(&quot;\n&quot;);</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-宽度优先搜索BFS"><a href="#6-宽度优先搜索BFS" class="headerlink" title="6.宽度优先搜索BFS"></a>6.宽度优先搜索BFS</h2><p><strong>核心思想：队列</strong></p>
<p>参考链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/aliyonghang/article/details/128724989">宽度优先搜索算法（BFS）详解（超级详细讲解，附有大图）-CSDN博客</a></p>
<p>bfs函数设计</p>
<p>可以参考下面两个例题的bfs函数，函数可以不需要参数值，因为不需要递归，在函数里面主要就是在while循环进行入队出队操作，直至遍历到满足的元素后输出结果+return结束，或者队列为空后再输出结果。</p>
<p>模板一：使用c++的queue对象</p>
<p>queue&lt;结构体对象名&gt; q</p>
<p>q.push(元素对象) 放入对象</p>
<p>q.empty()检测队列是否为空</p>
<p>q.front() 获取队首元素</p>
<p>q.pop() 队首元素出队</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//以下两个是必要的头文件！！！！</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct qu&#123;</span><br><span class="line">    int item;</span><br><span class="line">    int step;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">        qu cur = &#123;0, 0&#125;;</span><br><span class="line">        queue&lt;qu&gt; q;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        qu nex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板二、使用c++的priority_queue对象</p>
<p>priority_queue对象会自动排序，但要求我们自定义的结构体里面有声明相应的排序规则</p>
<p>注意，priority_queue获取队首用的是top(),不是front()</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	bool operator &lt; (const node &amp; a) const</span><br><span class="line">	&#123;</span><br><span class="line">		return x&lt;a.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个node结构体有两个成员，x和y，它的小于规则是x小者小。</p>
<p>就是说若当前x比新来的x要小的话，就return true，进行交换，把大的放在靠近队首的地方。</p>
<p>所以把元素(10,100),(12,60),(14,40),(6,20),(8,20)这五个node加入到队列后，一个个pop()的输出结果是(14,40) (12,60) (10,100) (8,20) (6,80)</p>
<p>参考链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/c20182030/article/details/70757660">【原创】优先队列 priority_queue 详解-CSDN博客</a></p>
<h3 id="例题一、胜利大逃亡"><a href="#例题一、胜利大逃亡" class="headerlink" title="例题一、胜利大逃亡"></a>例题一、胜利大逃亡</h3><p><strong>7-5 胜利大逃亡</strong></p>
<p>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会. </p>
<p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个. 现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.</p>
<p><img src="https://images.ptausercontent.com/d20c18e1-1c3c-4097-8056-7bb2ad155250.png" alt="image.png"></p>
<p>输入格式:</p>
<p>输入数据的第一行是一个正整数K,表明测试数据的数量. 每组测试数据的第一行是四个正整数A,B,C和T(1&lt;&#x3D;A,B,C&lt;&#x3D;50,1&lt;&#x3D;T&lt;&#x3D;1000),它们分别代表城堡的大小和魔王回来的时间. 然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙. (如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)</p>
<p>输出格式:</p>
<p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 3 4 20</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 0 0 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 1 1 0</span><br><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>注意点：该题是一个三维数组，需要建立三维坐标，以及六个方向数组。</p>
<p>2.bfs函数里，该函数没有传入值，在函数开头需要先把队列里元素全都pop掉，再把初始的node cur &#x3D; {0, 0, 0, 0}传入到queue&lt;node&gt; q中。</p>
<p>3.函数的结束判定。因为只要能遍历到终点或者当前时间已经超时了，那么一定有输出，所以再输出完之后直接return掉结束函数就可以了。</p>
<p>4.若函数的while循环里，没有最终遍历到终点，那么要记得在while循环外面放一个printf(“-1\n”)语句。</p>
<p>或者在while循环里最后放上这么一段</p>
<pre><code>if(q.empty())&#123;
    printf(&quot;-1\n&quot;);
    return;
&#125;
</code></pre>
<p>总之，核心关键点就是记得拿到结果时，<strong>使用return直接结束函数</strong>。因为这个老是会忘记┭┮﹏┭┮。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map[51][51][51];</span><br><span class="line">int vis[51][51][51];</span><br><span class="line">int k, a, b, c, t;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x, y, z;</span><br><span class="line">    int time;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">int dir[6][3] = &#123;&#123;-1, 0, 0&#125;, &#123;1, 0, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, 0, -1&#125;, &#123;0, 0, 1&#125;&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    node n = &#123;0, 0, 0, 0&#125;;</span><br><span class="line">    q.push(n);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        node cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(cur.time &gt; t)&#123;</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur.x == a - 1 &amp;&amp; cur.y == b - 1 &amp;&amp; cur.z == c -1)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, cur.time);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        node nex;</span><br><span class="line">        for(int i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">            int x = cur.x + dir[i][0];</span><br><span class="line">            int y = cur.y + dir[i][1];</span><br><span class="line">            int z = cur.z + dir[i][2];</span><br><span class="line">            if(!vis[x][y][z] &amp;&amp; !map[x][y][z] &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; a &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; b &amp;&amp; z &gt;= 0 &amp;&amp; z &lt; c)&#123;</span><br><span class="line">                nex = &#123;x, y, z, cur.time+1&#125;;</span><br><span class="line">                q.push(nex);</span><br><span class="line">                vis[x][y][z] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">    while(k -- &gt;0)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;t);</span><br><span class="line">        for(int i = 0; i &lt; a; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; b; j++)&#123;</span><br><span class="line">                for(int p = 0; p &lt; c; p++)&#123;</span><br><span class="line">                    scanf(&quot;%d&quot;, &amp;map[i][j][p]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(vis, 0, sizeof(vis));</span><br><span class="line">        vis[0][0][0] = 1;</span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="例题二、营救"><a href="#例题二、营救" class="headerlink" title="例题二、营救"></a>例题二、营救</h3><p><strong>7-4 营救</strong></p>
<p>Angel 被 MOLIGPY 抓住了！他被 Moligpy 关进了监狱。监狱被描述为 N * M （N， M &lt;&#x3D; 200） 矩阵。监狱里有 WALLs、ROAD 和 GUARDs。Angel 的朋友想救 Angel。他们的任务是：接近 Angel。我们假设 “接近 Angel” 是为了到达 Angel 停留的位置。当网格中有守卫时，我们必须杀死他（或她）才能进入网格。我们假设我们向上、向下、向右、向左移动需要 1 个单位的时间，杀死一个守卫也需要 1 个单位的时间。而且我们足够强大，可以杀死所有的守卫。您必须计算接近 Angel 的最短时间。（当然，我们只能将 UP、DOWN、LEFT 和 RIGHT 移动到边界内的相邻网格。</p>
<p>输入格式:</p>
<p>第一行包含两个整数，分别代表 N 和 M。然后是 N 行，每行有 M 个字符。“.” 代表道路，“a” 代表 Angel，“r” 代表 Angel 的每个朋友。进程到文件末尾。</p>
<p>输出格式:</p>
<p>对于每个测试用例，您的程序应输出一个整数，代表所需的最短时间。如果不存在这样的数字，您应该输出一行，其中包含“可怜的天使必须终生留在监狱中”。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">#.#####.</span><br><span class="line">#.a#..r.</span><br><span class="line">#..#x...</span><br><span class="line">..#..#.#</span><br><span class="line">#...##..</span><br><span class="line">.#......</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>解法：</p>
<p>因为这道题里，time的值不是一直+1，还有可能+2,所以，所以用普通的队列不能ac，因为我们要保证队列前面的元素一定要是time最小的，从前到后遍历时，元素的time是非递减的，这样子才能保证遍历到结束点的时候用时最短。故需要在原普通队列的基础上做一点改动就能够ac了。</p>
<p>1.queue&lt;node&gt; q 改为 priority_queue&lt;node&gt; q</p>
<p>2.取队首元素从q.front()改为q.top()。 </p>
<p>3.结构体里要内嵌比较函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x, y, time;</span><br><span class="line">    <span class="comment">//固定写法，试过了，不能不写const</span></span><br><span class="line">    <span class="type">bool</span> operator &lt;(<span class="type">const</span> node&amp;other)<span class="type">const</span>&#123;</span><br><span class="line">    	<span class="comment">//当前元素的值和其他元素的time比较，若返回true,则交换，即当前元素放到后面，所以就是从小到大排</span></span><br><span class="line">        <span class="keyword">return</span> time &gt; other.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>易错点：这道题重新写，让我崩溃的是我x和y的范围没有写全，漏了x &gt;&#x3D; 0 和 y &gt;&#x3D; 0，导致一直报段错误，害我找半天错误。</p>
<p>队列会写的话，优先队列只需要改动一点就行了O(∩_∩)O。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, sx, sy;</span><br><span class="line">char map[201][201];</span><br><span class="line">int vis[201][201];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x, y, time;</span><br><span class="line">    </span><br><span class="line">    bool operator&lt;(const node&amp; other) const &#123;</span><br><span class="line">        return time &gt; other.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">    node st = &#123;sx, sy, 0&#125;;</span><br><span class="line">    q.push(st);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node cur = q.top();</span><br><span class="line">        if(map[cur.x][cur.y] == &#x27;r&#x27;)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, cur.time);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        node nex;</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int x = cur.x + dir[i][0];</span><br><span class="line">            int y = cur.y + dir[i][1];</span><br><span class="line">            if(vis[x][y] == 0 &amp;&amp; map[x][y] != &#x27;#&#x27; &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)&#123;</span><br><span class="line">                if(map[x][y] == &#x27;x&#x27;)&#123;</span><br><span class="line">                    nex = &#123;x, y, cur.time + 2&#125;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    nex = &#123;x, y, cur.time+1&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[x][y] = 1;</span><br><span class="line">                q.push(nex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Poor ANGEL has to stay in the prison all his life.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        q = &#123;&#125;;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            // getchar();</span><br><span class="line">            scanf(&quot;%s&quot;, &amp;map[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                if(map[i][j] == &#x27;a&#x27;)&#123;</span><br><span class="line">                    sx = i; </span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(vis, 0, sizeof(vis));</span><br><span class="line">        vis[sx][sy] = 1;</span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-深度优先搜索DFS"><a href="#7-深度优先搜索DFS" class="headerlink" title="7.深度优先搜索DFS"></a>7.深度优先搜索DFS</h2><p><strong>核心思想：回溯、递归</strong></p>
<ol>
<li>为了求得问题的解，先选择某一种可能情况向前探索；</li>
<li>在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索；</li>
<li>如此反复进行，直至得到解或证明无解。</li>
</ol>
<p>模板</p>
<p>主要就是设置一个vis数组标记是否访问过。</p>
<p>难点在如何剪枝</p>
<p>参考链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47733361/article/details/123858318">DFS (深度优先搜索) 算法详解 + 模板 + 例题，这一篇就够了_dfs算法-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int a[510];   //存储每次选出来的数据</span><br><span class="line">int book[510];   //标记是否被访问</span><br><span class="line">int ans = 0; //记录符合条件的次数</span><br><span class="line"></span><br><span class="line">void DFS(int cur)&#123;</span><br><span class="line">	if(cur == k)&#123; //k个数已经选完，可以进行输出等相关操作 </span><br><span class="line">		for(int i = 0; i &lt; cur; i++)&#123;</span><br><span class="line">			printf(&quot;%d &quot;, a[i]);</span><br><span class="line">		&#125; </span><br><span class="line">		ans++;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123; //遍历 n个数，并从中选择k个数 </span><br><span class="line">	if(!book[i])&#123; //若没有被访问 </span><br><span class="line">		book[i] = 1; //标记已被访问 </span><br><span class="line">		a[cur] = i;  //选定本数，并加入数组 </span><br><span class="line">		DFS(cur + 1);  //递归，cur+1 </span><br><span class="line">		book[i] = 0;  //释放，标记为没被访问，方便下次引用 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="例题一、骨头者的诱惑"><a href="#例题一、骨头者的诱惑" class="headerlink" title="例题一、骨头者的诱惑"></a>例题一、骨头者的诱惑</h3><p><strong>7-1 骨头的诱惑者</strong></p>
<p>这只小狗在一个古老的迷宫里发现了一根骨头，这让他非常着迷。然而，当他捡起它时，迷宫开始晃动，小狗能感觉到地面在下沉。他意识到那块骨头是一个陷阱，他拼命想走出这个迷宫。迷宫是一个尺寸为 N x M 的矩形。迷宫里有一扇门。一开始，门是关着的，它会在第 T 秒打开一小段时间（不到 1 秒）。因此，这只小狗必须在第 T 秒到达门口。在每一秒内，他可以将一个块移动到上、下、左、右相邻块中的一个。一旦他进入一个方块，这个方块的地面就会开始下沉，并在下一秒消失。他不能在一个区块上停留超过一秒钟，也不能进入一个被访问过的区块。可怜的小狗能活下来吗？请帮助他。</p>
<p>输入格式:</p>
<p>输入由多个测试用例组成。每个测试用例的第一行包含三个整数 N、M 和 T （1 &lt; N， M &lt; 7;0 &lt; T &lt; 50），分别表示迷宫的大小和门打开的时间。接下来的 N 行给出了迷宫布局，每行包含 M 个字符。字符是以下之一： ‘X’：一块墙，小狗不能进入;’S’：小狗的起点;’D’：门;或 ‘.’：一个空块。input 以三个 0 终止。此测试用例不予处理。</p>
<p>输出格式:</p>
<p>对于每个测试用例，如果 doggie 可以存活，则在一行中打印 “YES”，否则打印 “NO”。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">..XD</span><br><span class="line">....</span><br><span class="line">3 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">...D</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>解法：</p>
<p>dfs和剪枝</p>
<p>1.dfs()，以当前元素的位置和时间作为参数</p>
<p>2.剪枝。当目前时间减去最短距离所需时间时的剩余时间小于0，或者等于奇数时，那么该点一定走不到终点，直接return。</p>
<p>问题：该代码读取map各个位置的元素时不能使用getchar()加scanf(),cin或者直接scanf(“%s”)就可以，也不知道为什么。我自己重新写时出一堆问题，明明和原代码差不多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, t, nt;</span><br><span class="line">int ex, ey;</span><br><span class="line">char map[10][10];</span><br><span class="line">int flag = 0;</span><br><span class="line">int dir[4][2] = &#123;&#123;0,1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">void dfs(int x, int y, int cnt)&#123;</span><br><span class="line">    if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x == ex &amp;&amp; y == ey &amp;&amp; cnt == t)&#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = t - cnt - fabs(x - ex) - fabs(y - ey);</span><br><span class="line">    if(temp &lt; 0 || temp % 2 == 1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        if(map[x + dir[i][0]][y + dir[i][1]] != &#x27;X&#x27;)&#123;</span><br><span class="line">            map[x + dir[i][0]][y + dir[i][1]] = &#x27;X&#x27;;</span><br><span class="line">            dfs(x + dir[i][0], y + dir[i][1], cnt+1);</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            map[x + dir[i][0]][y + dir[i][1]] = &#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int sx, sy;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t)&amp;&amp;(m+n+t))&#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        //scanf(&quot;%s&quot;, &amp;map[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                cin&gt;&gt;map[i][j];</span><br><span class="line">                if(map[i][j] == &#x27;S&#x27;)&#123;</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(map[i][j] == &#x27;D&#x27;)&#123;</span><br><span class="line">                    ex = i; </span><br><span class="line">                    ey = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map[sx][sy] = &#x27;X&#x27;;</span><br><span class="line">        dfs(sx, sy, 0);</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="例题二、FatMouse-和奶酪"><a href="#例题二、FatMouse-和奶酪" class="headerlink" title="例题二、FatMouse 和奶酪"></a>例题二、FatMouse 和奶酪</h3><p><strong>7-7 FatMouse 和奶酪</strong></p>
<p>FatMouse 在一个城市储存了一些奶酪。城市可以看作是维度 n 的方形网格：每个网格位置都标记为 （p，q），其中 0 &lt;&#x3D; p &lt; n 和 0 &lt;&#x3D; q &lt; n。在每个网格位置，Fatmouse 都在一个洞中隐藏了 0 到 100 块奶酪。现在他要享受他最喜欢的食物了。FatMouse 首先站在位置 （0,0）。他吃掉了自己站着的奶酪，然后水平或垂直地跑到另一个地方。问题是有一只名叫 Top Killer 的超级猫坐在他的洞附近，所以每次他最多可以跑 k 个位置进入洞中，然后被 Top Killer 抓住。更糟糕的是 – 在一个地方吃完奶酪后，FatMouse 变得更胖了。因此，为了获得足够的能量进行下一次跑步，他必须跑到一个比当前洞的奶酪块更多的地方。给定 n、k 和每个网格位置的奶酪块数，计算 FatMouse 在无法移动之前可以吃的最大奶酪量。</p>
<p>输入格式:</p>
<p>有几个测试用例。每个测试用例由一行组成，其中包含两个介于 1 和 100 之间的整数：n 行和 k n 行，每行有 n 个数字：第一行包含位置 （0,0） （0,1） 的奶酪块数……（0，n-1）;下一行包含位置 （1,0）、（1,1）、…（1，n-1） 等。input 以一对 -1 结尾。</p>
<p>输出格式:</p>
<p>对于每个测试用例，在一行中输出单个整数，给出收集的奶酪块数。</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 2 5</span><br><span class="line">10 11 6</span><br><span class="line">12 12 7</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure>

<p>答案:</p>
<p>解法：dfs+dp</p>
<p>这道题需要注意的是，由于要计算收集的奶酪的最大值，所以我们不能只单纯进行dfs，而应该在dfs过程中运用dp思想，把当前位置可以拿到的最大奶酪数记录到dp数组里。而且由于只能走比自己当前位置大的数的方向，所以没有必要再用vis数组记录当前位置是否被遍历过。</p>
<p>剪枝:</p>
<p>若dp数组一开始就赋予了和map数组一样的值，那么进行dfs时，遍历到的位置最大值可能要求好多次。</p>
<p>从结果推到起点来看，如果我们在dfs中开始先判断dp是否有值，若有，若没有，那么再把同样位置的map值赋给dp当初始值进行最大值搜索，因为这样做，如果从别的位置又遍历到当前位置时，不需要再进行dfs下去，直接return该值即可，因为之前已经dfs过，把当前位置的最大值给记录到了。总之就是当前dp进行dfs后就已经获取最大值了，只是借用dp不为0来进行直接返回。换用其他标记数组也可以达到同样效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[x][y] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x][y] = <span class="built_in">map</span>[x][y];</span><br><span class="line">    <span class="type">int</span> tx, ty, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            tx = dir[i][<span class="number">0</span>] * j + x;</span><br><span class="line">            ty = dir[i][<span class="number">1</span>] * j + y;</span><br><span class="line">            <span class="keyword">if</span>(tx &gt;= <span class="number">0</span> &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; tx &lt; n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[tx][ty] &gt; <span class="built_in">map</span>[x][y])&#123;</span><br><span class="line">                    dp[x][y] = max(<span class="built_in">map</span>[x][y] + dfs(tx, ty), dp[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memset(map, 0, sizeof(map));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;  n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        res = dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="8-并查集"><a href="#8-并查集" class="headerlink" title="8.并查集"></a>8.并查集</h2><p><strong>核心思想：找父亲findp(), 合并merge()</strong></p>
<p>1.给每个元素都先把它们自己定义为父亲。</p>
<p>2.查找目标元素父亲时，使用while循环，直至遍历的当前元素的父亲等于当前元素，此时当前元素即为目标元素的父类。</p>
<p>3.合并时要注意，合并的是<strong>当前两个元素的父亲</strong>，即先findp(x)和findp(y)，把x和y的父亲先找到，再给y的父亲的父亲设置为x的父亲。而不是直接f[x] &#x3D; y!!!!。</p>
<p>优化：</p>
<p>查找目标元素父亲时，顺便把找父亲时遍历的其他元素的f[n]也都直接设置为父亲，这样子可以有效减少之后找父亲的循环次数。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int findp(int x)&#123;</span><br><span class="line">    int r = x;</span><br><span class="line">    //找到最终的父亲</span><br><span class="line">    while(f[r] != r)&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    //给当前元素的f直接设置为父亲的值</span><br><span class="line">    //i存储当前元素，j存储当前元素的f</span><br><span class="line">    int i=x,j;</span><br><span class="line">    while(f[i]!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        j=f[i];</span><br><span class="line">        f[i]=r;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板</p>
<p>1.findp函数如上面的优化写即可</p>
<p>2.merge函数</p>
<p>注意：merge函数有两种写法，一个是在merge里找父亲元素，一个是在调用merge函数之前把父亲找好了再传值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> xp = findp(x);</span><br><span class="line">    <span class="type">int</span> yp = findp(y);</span><br><span class="line">    f[yp] = xp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">	f[y] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题一、畅通工程再续"><a href="#例题一、畅通工程再续" class="headerlink" title="例题一、畅通工程再续"></a>例题一、畅通工程再续</h3><p><strong>7-3 畅通工程再续</strong></p>
<p>全屏浏览切换布局</p>
<p>作者 刘春英</p>
<p>单位 杭州电子科技大学</p>
<p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元&#x2F;米。</p>
<p>输入格式:</p>
<p>输入包括多组数据。输入首先包括一个整数T(T &lt;&#x3D; 200)，代表有T组数据。<br>每组数据首先是一个整数C(C &lt;&#x3D; 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;&#x3D; x, y &lt;&#x3D; 1000的整数。</p>
<p>输出格式:</p>
<p>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">20 20</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1000 1000</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1414.2</span><br><span class="line">oh!</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>解法</p>
<p>贪心+并查集</p>
<p>1.该题使用并查集之前，需要自己在读完所有岛屿信息后，根据条件筛选出两两对应的不同岛屿，把他们的编号和距离存放到结构体数组node中。由于两个for循环遍历完，所以结构体node数组开辟的大小应该是c*(c-1)&#x2F;2。之后使用qsort函数排序后进行并查集操作。</p>
<p>易错点</p>
<p>node数组的大小不等于岛的个数c，而是等于<em><em>c</em>(c-1)&#x2F;2</em>*，这点很重要，否则一直报段错误。还有，qsort函数里面排序数量也是c*(c-1),这些都是极易忽视的易错点啊(╯°□°）╯︵ ┻━┻。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int t, c;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    double dis;</span><br><span class="line">&#125;node[10000];</span><br><span class="line">int land[111][2], f[111], vis[101];</span><br><span class="line">int cmp(const void * a, const void * b)&#123;</span><br><span class="line">    struct node x = *(struct node*)a;</span><br><span class="line">    struct node y = *(struct node*)b;</span><br><span class="line">    if(x.dis - y.dis &gt; 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int findp(int x)&#123;</span><br><span class="line">    int r = x;</span><br><span class="line">    while(f[r] != r)&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    int a = x, b;</span><br><span class="line">    while(f[a] != r)&#123;</span><br><span class="line">        b = f[a];</span><br><span class="line">        f[a] = r;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">void merge(int a, int b)&#123;</span><br><span class="line">    f[b] = a;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;c);</span><br><span class="line">        for(int i = 0; i &lt; c; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;land[i][0], &amp;land[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        double dis = 0;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for(int i = 0; i &lt; c-1; i ++)&#123;</span><br><span class="line">            for(int j = i + 1; j &lt; c; j++)&#123;</span><br><span class="line">                dis = sqrt(pow(land[j][0] - land[i][0], 2)+pow(land[j][1]-land[i][1], 2));</span><br><span class="line">                if(dis &gt;= 10 &amp;&amp; dis &lt;= 1000)&#123;</span><br><span class="line">                    node[index].a = i;</span><br><span class="line">                    node[index].b = j;</span><br><span class="line">                    node[index].dis = dis;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; c; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        double sum = 0;</span><br><span class="line">        int num = 0;</span><br><span class="line">        qsort(node, c*(c-1)/2, sizeof(struct node), cmp);</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;</span><br><span class="line">            int fx = findp(node[i].a);</span><br><span class="line">            int fy = findp(node[i].b);</span><br><span class="line">            if(fx != fy)&#123;</span><br><span class="line">                merge(fx, fy);</span><br><span class="line">                sum += node[i].dis;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num == c - 1)</span><br><span class="line">            printf(&quot;%.1lf\n&quot;, sum*100);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;oh!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题二、Is-It-A-Tree"><a href="#例题二、Is-It-A-Tree" class="headerlink" title="例题二、Is It A Tree"></a>例题二、Is It A Tree</h3><p><strong>7-6 Is It A Tree?</strong></p>
<p>全屏浏览切换布局</p>
<p>作者 刘春英</p>
<p>单位 杭州电子科技大学</p>
<p>A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties.<br>There is exactly one node, called the root, to which no directed edges point.</p>
<p>Every node except the root has exactly one edge pointing to it.</p>
<p>There is a unique sequence of directed edges from the root to each node.</p>
<p>For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not.<br><img src="https://images.ptausercontent.com/68a90dcf-b7f1-47ae-b69f-e27d254896b6.png" alt="image.png"><img src="https://images.ptausercontent.com/3a21ddd6-66ae-4c58-a4d8-68df04c524bb.png" alt="image.png"><img src="https://images.ptausercontent.com/b85985db-76f8-4b76-9f1a-3fe18f5d5faa.png" alt="image.png"></p>
<p>In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not.</p>
<p>输入格式:</p>
<p>The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero.</p>
<p>输出格式:</p>
<p>For each test case display the line <code>Case k is a tree.&quot; or the line </code>Case k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1).</p>
<p>输入样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8 5 3 5 2 6 4</span><br><span class="line">5 6 0 0</span><br><span class="line">8 1 7 3 6 2 8 9 7 5</span><br><span class="line">7 4 7 8 7 6 0 0</span><br><span class="line">3 8 6 8 6 4</span><br><span class="line">5 3 5 6 5 2 0 0</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<p>输出样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1 is a tree.</span><br><span class="line">Case 2 is a tree.</span><br><span class="line">Case 3 is not a tree.</span><br></pre></td></tr></table></figure>

<p>答案</p>
<p>解法</p>
<p>1.一个节点有两个父节点时，这就不是一个树了。所以在合并前，应先判断b是否已经有父节点了。</p>
<p>2.用一个vis数组来记录节点是否存在，若存在，再根据其是否等于父节点（即该节点是否是根），给sum+1, 若最后sum&#x3D;&#x3D;1,则是树，否则不是树。</p>
<p>3.空集合是树，即输入为 0 0 的情况。因此需要额外判断。</p>
<p>易错点</p>
<p>气死我了，输出样例最后句子有个小数点，但我没注意，结果一直反复查看代码哪里出错了，(╯▔皿▔)╯。另外，该题<strong>不能用两个while循环来读取数据，会一直超时</strong>。也不知道啥原因。所以只能用一个while循环来写，若遍历到了0 0，则调用isAtree()函数判断是否是树，再用initial()函数重置数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10005</span>], vis[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>,index = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findp</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> r = a;</span><br><span class="line">    <span class="keyword">while</span>(r != f[r])&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x =a, y;</span><br><span class="line">    <span class="keyword">while</span>(f[x] != r)&#123;</span><br><span class="line">        y = f[x];</span><br><span class="line">        f[x] = r;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    f[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initial</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10005</span>; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isAtree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>, index++);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10005</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[i] == i)&#123;</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">1</span> || !ok)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is a tree.\n&quot;</span>, index++);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>, index++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    initial();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">-1</span> &amp;&amp; b == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)&#123;</span><br><span class="line">            isAtree();</span><br><span class="line">            initial();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vis[a] = <span class="number">1</span>;</span><br><span class="line">            vis[b] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[b] != b || a == b)&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> fa = findp(a);</span><br><span class="line">            <span class="type">int</span> fb = findp(b);</span><br><span class="line">            <span class="keyword">if</span>(fa != fb)&#123;</span><br><span class="line">                merge(fa, fb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ldy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/">http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/22/Springmvc%E6%80%BB%E7%BB%93/" title="Springmvc总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Springmvc总结</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/08/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9303-Aop/" title="Spring技术总结03-Aop"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring技术总结03-Aop</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ldy</div><div class="author-info__description">I am a slow walker,but I never walk backwards.我走得很慢，但是我从来不会后退</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qcqwy"><i class="fab fa-github"></i><span>别点这里</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-text">一、易错点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-qsort%E7%9A%84cmp%E5%87%BD%E6%95%B0"><span class="toc-text">1.qsort的cmp函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-memset%E5%87%BD%E6%95%B0"><span class="toc-text">2.memset函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-strcmp%E5%87%BD%E6%95%B0"><span class="toc-text">3.strcmp函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-c-%E7%9A%84%E9%98%9F%E5%88%97%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.c++的队列对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-qsort%E5%87%BD%E6%95%B0"><span class="toc-text">5.qsort函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86"><span class="toc-text">二、算法整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%99%AE%E9%80%9A%E7%9A%840-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1）普通的0-1背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E6%99%AE%E9%80%9A%E7%9A%84%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">2）普通的完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%AF%B9%E4%BA%8E%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A3%85%E6%BB%A1%E8%83%8C%E5%8C%85%E7%9A%84%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%83%85%E5%86%B5%E4%B8%8B"><span class="toc-text">3）对于判断是否装满背包的完全背包情况下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%A2%9D%E5%A4%96%E5%88%A4%E6%96%AD%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%87%BA%E9%94%99"><span class="toc-text">4）对于普通背包问题，不要进行额外判断了，会出错</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%94%BE%E6%8C%A1%E6%9D%BF%E6%B3%95"><span class="toc-text">2.放挡板法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%8C%E5%90%83%E7%B3%96%E6%9E%9C"><span class="toc-text">例题，吃糖果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B4%AA%E5%BF%83"><span class="toc-text">3.贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC"><span class="toc-text">例题，田忌赛马</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%92%E5%BD%92"><span class="toc-text">4.递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%80%E3%80%81%E6%AF%8D%E7%89%9B%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-text">例题一、母牛的故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%BA%8C%E3%80%81%E5%84%BF%E7%AB%A5%E9%98%9F%E5%88%97"><span class="toc-text">例题二、儿童队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">5.动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%80%E3%80%81%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC"><span class="toc-text">例题一、免费馅饼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%BA%8C%E3%80%81%E6%90%AC%E5%AF%9D%E5%AE%A4"><span class="toc-text">例题二、搬寝室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%89%E3%80%81%E6%9C%80%E5%A4%A7%E6%80%BB%E5%92%8C"><span class="toc-text">例题三、最大总和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2BFS"><span class="toc-text">6.宽度优先搜索BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%80%E3%80%81%E8%83%9C%E5%88%A9%E5%A4%A7%E9%80%83%E4%BA%A1"><span class="toc-text">例题一、胜利大逃亡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%BA%8C%E3%80%81%E8%90%A5%E6%95%91"><span class="toc-text">例题二、营救</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2DFS"><span class="toc-text">7.深度优先搜索DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%80%E3%80%81%E9%AA%A8%E5%A4%B4%E8%80%85%E7%9A%84%E8%AF%B1%E6%83%91"><span class="toc-text">例题一、骨头者的诱惑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%BA%8C%E3%80%81FatMouse-%E5%92%8C%E5%A5%B6%E9%85%AA"><span class="toc-text">例题二、FatMouse 和奶酪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">8.并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%80%E3%80%81%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD"><span class="toc-text">例题一、畅通工程再续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%BA%8C%E3%80%81Is-It-A-Tree"><span class="toc-text">例题二、Is It A Tree</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/15/%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6/" title="手写RPC框架">手写RPC框架</a><time datetime="2025-12-15T15:12:20.000Z" title="发表于 2025-12-15 23:12:20">2025-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/10/%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASpring%E7%9A%84starter%E4%BE%9D%E8%B5%96/" title="如何自己实现一个Spring的starter依赖">如何自己实现一个Spring的starter依赖</a><time datetime="2025-12-10T02:23:27.000Z" title="发表于 2025-12-10 10:23:27">2025-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/24/Langchain4j%E5%AD%A6%E4%B9%A0/" title="轻松掌握Langchain4j">轻松掌握Langchain4j</a><time datetime="2025-08-24T11:47:55.000Z" title="发表于 2025-08-24 19:47:55">2025-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/15/%E6%B7%B1%E5%85%A5java%E9%9B%86%E5%90%88/" title="深入java集合">深入java集合</a><time datetime="2025-08-15T09:57:34.000Z" title="发表于 2025-08-15 17:57:34">2025-08-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/11/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%B4%E5%90%88/" title="开发常见问题汇总">开发常见问题汇总</a><time datetime="2025-07-11T15:59:20.000Z" title="发表于 2025-07-11 23:59:20">2025-07-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://t.alcy.cc/fj/')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By ldy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>