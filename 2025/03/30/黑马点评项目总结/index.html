<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>黑马点评项目总结 | Journey</title><meta name="author" content="ldy"><meta name="copyright" content="ldy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、项目介绍八股介绍：之后再补吧。。。。。词穷了 这个项目主要是基于redis相关内容进行展开的，主要实现了用户登录、抢票、点赞、评论、关注等类似社交软件的功能。 二、短信登录1.简介短信登录逻辑是用户填入手机号和短信验证码来校验用户信息。此外，该登录功能还包含了注册，即未注册过的手机号进行登录时，将会默认注册为一个新用户。 2.验证码的获取验证码缓存用户发起获取短信验证码请求时，后端会先随机生成">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马点评项目总结">
<meta property="og:url" content="http://example.com/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Journey">
<meta property="og:description" content="一、项目介绍八股介绍：之后再补吧。。。。。词穷了 这个项目主要是基于redis相关内容进行展开的，主要实现了用户登录、抢票、点赞、评论、关注等类似社交软件的功能。 二、短信登录1.简介短信登录逻辑是用户填入手机号和短信验证码来校验用户信息。此外，该登录功能还包含了注册，即未注册过的手机号进行登录时，将会默认注册为一个新用户。 2.验证码的获取验证码缓存用户发起获取短信验证码请求时，后端会先随机生成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png">
<meta property="article:published_time" content="2025-03-30T10:59:42.000Z">
<meta property="article:modified_time" content="2025-08-18T09:57:29.183Z">
<meta property="article:author" content="ldy">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png"><link rel="shortcut icon" href="/img/logo2.jpeg"><link rel="canonical" href="http://example.com/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '黑马点评项目总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-18 17:57:29'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/fj/')"><nav id="nav"><span id="blog-info"><a href="/" title="Journey"><img class="site-icon" src="/img/logo.jpeg"/><span class="site-name">Journey</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">黑马点评项目总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-30T10:59:42.000Z" title="发表于 2025-03-30 18:59:42">2025-03-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-18T09:57:29.183Z" title="更新于 2025-08-18 17:57:29">2025-08-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/redis/">redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="黑马点评项目总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h1><p>八股介绍：之后再补吧。。。。。词穷了</p>
<p>这个项目主要是基于redis相关内容进行展开的，主要实现了用户登录、抢票、点赞、评论、关注等类似社交软件的功能。</p>
<h1 id="二、短信登录"><a href="#二、短信登录" class="headerlink" title="二、短信登录"></a>二、短信登录</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>短信登录逻辑是用户填入手机号和短信验证码来校验用户信息。此外，该登录功能还包含了注册，即未注册过的手机号进行登录时，将会默认注册为一个新用户。</p>
<h2 id="2-验证码的获取"><a href="#2-验证码的获取" class="headerlink" title="2.验证码的获取"></a>2.验证码的获取</h2><h3 id="验证码缓存"><a href="#验证码缓存" class="headerlink" title="验证码缓存"></a>验证码缓存</h3><p>用户发起获取短信验证码请求时，后端会先随机生成一个6位数验证码，以<code>login:phone:填入的手机号</code>为key，将验证码存入redis中。随后调用短信相关的api，给对应的手机号发送验证码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;非法手机号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将验证码存入redis，以手机号码为key, 过期时间600秒</span></span><br><span class="line">    redisTemplate.opsForValue().set(RedisConstant.LOGIN_PHONE_KEY + phone, code, <span class="number">600</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送验证码成功&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-登录校验"><a href="#3-登录校验" class="headerlink" title="3.登录校验"></a>3.登录校验</h2><h3 id="用户信息缓存"><a href="#用户信息缓存" class="headerlink" title="用户信息缓存"></a>用户信息缓存</h3><p>用户校验成功后，后端会利用UUID随机生成一个token值，并以<code>login:user:token值</code>为key，保存用户的相关消息到redis中。前端接收返回的token值并带入请求头中，以便访问其他页面时校验用户身份。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.根据手机号查询redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> redisTemplate.opsForValue().get(RedisConstant.LOGIN_PHONE_KEY + phone);</span><br><span class="line">    <span class="comment">//2.校验验证码</span></span><br><span class="line">    <span class="keyword">if</span>(code == <span class="literal">null</span> || !code.equals(loginForm.getCode()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span>  <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.保存信息到redis</span></span><br><span class="line">    <span class="comment">//4.1随机生成token,做为访问redis的key，同时返回前端存储该token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstant.LOGIN_USER_KEY + token;</span><br><span class="line">    <span class="comment">//4.2将UserDTO对象转换为Map存储</span></span><br><span class="line"></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">    BeanUtils.copyProperties(user, userDTO);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">//设置过期时间</span></span><br><span class="line">    redisTemplate.expire(tokenKey, RedisConstant.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-登录拦截"><a href="#4-登录拦截" class="headerlink" title="4.登录拦截"></a>4.登录拦截</h2><p>拦截器配置类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//token刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(</span><br><span class="line">                <span class="string">&quot;/**&quot;</span></span><br><span class="line">        ).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（1）token刷新拦截器"><a href="#（1）token刷新拦截器" class="headerlink" title="（1）token刷新拦截器"></a>（1）token刷新拦截器</h3><p>该拦截器目的是刷新用户token的有效期，并不具有拦截功能，真正实现拦截功能的是登录拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.从请求头的authorization中获取token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="comment">//2.根据key 获取用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">    <span class="keyword">if</span>(entries.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若用户信息存在，则添加到threadlocal</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(entries, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">    UserHolder.saveUser(userDTO);</span><br><span class="line">    <span class="comment">//4.刷新用户token</span></span><br><span class="line">    stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）登录拦截器"><a href="#（2）登录拦截器" class="headerlink" title="（2）登录拦截器"></a>（2）登录拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h3><h4 id="为什么需要有两个拦截器"><a href="#为什么需要有两个拦截器" class="headerlink" title="为什么需要有两个拦截器"></a>为什么需要有两个拦截器</h4><p>**答:**因为不是每个页面都会拦截，例如首页，非登录用户也可以进行访问。若token刷新功能设置在登录拦截器中，那么用户访问非登录拦截页面时，token也就无法刷新，所以只有一个拦截器的话，token刷新是存在问题的。</p>
<p><strong>解决方法：</strong>设置一个全放行的全局拦截器，并把登录拦截器的功能移植到这个全局拦截器中，若存在token，则会刷新token,并将用户信息存入<strong>ThreadLocal</strong>中。在访问登录拦截器所拦截的页面时，登录拦截器只需要判断<strong>ThreadLocal</strong>中是否存在用户信息即可。这种情况下，token刷新拦截器的优先级高于登录拦截器。</p>
<h1 id="三、商户查询缓存"><a href="#三、商户查询缓存" class="headerlink" title="三、商户查询缓存"></a>三、商户查询缓存</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><p>缓存穿透指的是客户端请求在缓存和数据库中都不存在的数据，导致请求直接打到数据库。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="（1）缓存空对象"><a href="#（1）缓存空对象" class="headerlink" title="（1）缓存空对象"></a>（1）缓存空对象</h4><ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致（空对象存在时间内，新增了该id对应的商户信息）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用读缓存方法 -- 解决缓存穿透</span></span><br><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若redis中存在则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(str, type);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.若redis中没有，则访问数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3.1数据库中不存在，空值写入redis，防止缓存穿透</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, expireTime, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2.若数据库中存在，则存入redis中, 缓存时间为30分钟</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), expireTime, unit);</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知识点详解</p>
<p><strong>1.方法泛型</strong></p>
<p>方法泛型的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ReturnType <span class="title function_">methodName</span><span class="params">(T param1, T param2, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，泛型T类型根据方法参数而定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">((String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">	<span class="comment">//方法体  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>ID</code>类型</strong>：在调用<code>queryPassThrough</code>方法时，第二个参数的类型决定了<code>ID</code>的具体类型。</li>
<li><strong><code>R</code>类型</strong>：在调用<code>queryPassThrough</code>方法时，第三个参数<code>Class&lt;R&gt;</code>的类型决定了<code>R</code>的具体类型。</li>
</ul>
<p>上述方法中使用了泛型<code>&lt;ID, R&gt;</code>，其中<code>ID</code>表示传入的ID类型，<code>R</code>表示返回结果的类型。这使得方法可以处理不同类型的ID和返回值，增强了代码的通用性。</p>
<p>简单示例:将从Redis获取对象并进行类型转换的代码进行了封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; R <span class="title function_">getBean</span><span class="params">(String key, Class&lt;R&gt; type)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JSONUtil.toBean(s, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用封装方法</span></span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> Cache.getBean(key, Shop.class);</span><br><span class="line"><span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用封装方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="keyword">if</span>(StrUtil.isEmpty(s))&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(s, Shop.class);</span><br></pre></td></tr></table></figure>

<p><strong>2.函数式接口</strong></p>
<p><code>Function&lt;ID, R&gt;</code> 是一个函数式接口，定义了一个方法 <code>apply</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(ID id)</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法接收一个类型为 <code>ID</code> 的参数，并返回一个类型为 <code>R</code> 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, <span class="number">1200L</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>上述代码的this::getById是一个方法引用，用作apply方法的实现。</p>
<p><strong>3.方法引用</strong></p>
<p>方法引用是 Java 8 引入的一种特性，它允许你直接引用已有的方法或构造函数，而无需显式地定义一个 Lambda 表达式。方法引用可以看作是 Lambda 表达式的语法糖，它使得代码更加简洁、易读，并且能够直接利用已有的方法逻辑。</p>
<p><strong>方法引用与 Lambda 表达式的区别</strong></p>
<ul>
<li><p><strong>Lambda 表达式</strong>：是一种匿名函数，可以定义新的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; absFunction = x -&gt; Math.abs(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用</strong>：直接引用已有的方法，避免重复定义逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; absFunction = Math::abs;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong></p>
<p><code>Function&lt;S, T&gt;</code> 这种函数式接口可以使用方法引用，但方法引用必须满足以下条件：</p>
<ul>
<li>方法的参数类型必须与 <code>S</code> 匹配。</li>
<li>方法的返回类型必须与 <code>T</code> 匹配。</li>
</ul>
<p>只有当方法的签名的参数与 <code>Function&lt;S, T&gt;</code> 的 <code>apply</code> 方法的签名参数一致时，才能使用方法引用。</p>
<p>方法的签名（Method Signature）指的是方法的名称和参数列表。</p>
<h4 id="（2）布隆过滤器"><a href="#（2）布隆过滤器" class="headerlink" title="（2）布隆过滤器"></a>（2）布隆过滤器</h4><p><strong>介绍：</strong>详解见<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41125219/article/details/119982158">布隆(Bloom Filter)过滤器——全面讲解，建议收藏-CSDN博客</a></p>
<p>布隆过滤器它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是<strong>一个大型位数组（二进制数组）+多个无偏hash函数。</strong></p>
<p>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</p>
<p>如下就是一个简单的布隆过滤器示意图，其中k1、k2代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。其实就是看当前元素的经多个hash函数计算的不同索引在二进制数组当中是否都为1，都是1就通过。</p>
<p><img src="/../images/image-20250424151328839.png" alt="image-20250424151328839"></p>
<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能（若存在则肯定存在，若不存在有可能认为存在）</li>
</ul>
</li>
</ul>
<p>实现代码如下</p>
<p>1.引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--布隆过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在ShopServiceImpl中添加如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布隆过滤器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Long&gt; bloomFilter;</span><br><span class="line"><span class="comment">//布隆过滤器初始化方法</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBlooFilter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.从数据库中加载所有的店铺</span></span><br><span class="line">    List&lt;Long&gt; shopIds = shopMapper.getAllShopIds();</span><br><span class="line">    <span class="comment">//2.创建布隆过滤器</span></span><br><span class="line">    bloomFilter = BloomFilter.create(</span><br><span class="line">            Funnels.longFunnel(),  <span class="comment">//使用Long类型</span></span><br><span class="line">            shopIds.size() * <span class="number">2</span>,  <span class="comment">//期望插入的元素数量，这里乘以2是为了给新增店铺id留空</span></span><br><span class="line">            <span class="number">0.01</span> <span class="comment">//误判率</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//3.将店铺的id添加到布隆过滤器</span></span><br><span class="line">    <span class="keyword">for</span> (Long shopId : shopIds) &#123;</span><br><span class="line">        bloomFilter.put(shopId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.修改查询店铺代码</p>
<p>注意：因为布隆过滤器不能百分百阻拦不存在的数据，所以cacheClient的queryPassThrough方法没动。若侥幸通过布隆过滤器检测，会使用缓存空值的办法来解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//使用布隆过滤器先判断店铺是否存在</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(bloomFilter.mightContain(id))&#123;</span><br><span class="line">        <span class="comment">//存在则先查缓存再查数据库</span></span><br><span class="line">        shop = cacheClient.queryPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, <span class="number">1200L</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;布隆过滤器检测到店铺id不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺id真不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.修改新增店铺代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveShop</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.save(shop);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">shopId</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="comment">//添加新店铺id到布隆过滤器中</span></span><br><span class="line">    bloomFilter.put(shopId);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shopId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><p>缓存雪崩指的是在同一时间段内大量的缓存key同时失效或者redis服务突然宕机，导致大量请求直接打到数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的key添加随机的TTL</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加<strong>降级限流</strong>策略（<strong>限流</strong>：缓存未命中时，数据库的访问量也不会超过<strong>业务</strong>限流量，<strong>降级</strong>：缓存未命中时，返回默认值）</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="解决方案实现待补充"><a href="#解决方案实现待补充" class="headerlink" title="解决方案实现待补充"></a>解决方案实现待补充</h3><h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><p>缓存击穿指的是一个被高并发访问并且缓存重建业务较耗时的key突然失效了，导致大量请求直接打到数据库上。</p>
<p><img src="/../images/1653328022622-17433473940211.png" alt="1653328022622"></p>
<p>逻辑描述：假设线程1查询缓存未命中的情况下，本该是查询数据库并重建缓存数据就好了，之后的线程就都可以命中缓存了。但在高并发情况下，可能会有多个线程2、3、4，虽然在线程1之后查询缓存，但他们在线程1重建缓存之前就已经查询完缓存了，此时缓存是未命中的，导致这些线程都会执行和线程1一样的逻辑，去查询数据库，导致数据库访问压力过大。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li><strong>互斥锁</strong></li>
<li><strong>逻辑过期</strong></li>
</ul>
<h3 id="（1）互斥锁"><a href="#（1）互斥锁" class="headerlink" title="（1）互斥锁"></a>（1）互斥锁</h3><p>因为锁具有互斥性，所以我们可以设置一个互斥锁用于访问相应的数据库资源，只有拿到了锁的线程可以对数据库进行访问。这样可以使对同一资源的访问从并行变成了串行，从而减轻数据库压力。但这种方式的问题就是，其他没拿到锁的线程如何处理，是继续等待呢，还是直接返回呢？</p>
<p>继续等待的情况下，其他线程会等待锁的释放，当拿到了锁后，需要先访问缓存，判断拿到该锁之前，是否已经有线程访问过数据库并重建了缓存。如果有，则不需要再次访问数据库了，直接从缓存中拿即可。</p>
<p><img src="/../images/1653328288627.png" alt="1653328288627"></p>
<h4 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h4><p>那么问题来了，既然选择了互斥锁方案，那么这个互斥锁是谁提供的呢？</p>
<p>那当然是<strong>redis</strong>来提供了！！！</p>
<p>因为redis是单线程的，所以不必担心锁的获取会有线程安全问题。给每个商户信息设置一个对应的互斥锁key即可。只有成功设置key-value的线程才算拿到了互斥锁。</p>
<p>获取互斥锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取互斥锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="comment">//尝试设置redis内容,若设置成功则表明获取到了锁，若失败，则说明已经有人拿到了这个锁</span></span><br><span class="line">    <span class="comment">//设置过期时间是怕获取到锁的线程发生问题时独占锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放互斥锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，互斥锁也应当设置过期时间，以防某线程拿到锁却挂了，导致锁没释放成功的情况。当然了，不能排除这个线程后面又复活的情况，所以又引申出一个新的问题，原线程继续执行下去，但此时锁已经到期释放且被另一个线程获取了。原线程就有可能会把另一个线程获取到的锁给提前释放！！！这个问题到后面会解决，这里先埋个关子，我也是才意识到原来这里就已经出现这个问题了。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>商户信息访问的互斥锁解决方案如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存击穿--互斥锁方法</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.1先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//1.2判断是否str非空（非null和非空字符串）</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">        shop = JSONUtil.toBean(str, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.3若str是空字符串，则说明这个缓存是用于缓存穿透的，直接返回null即可</span></span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//2.若redis中没有，则访问数据库</span></span><br><span class="line">        <span class="comment">//3.获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">            <span class="comment">//休眠50ms,递归获取数据，直至命中缓存或者得到锁</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4拿到互斥锁时需要二次判断缓存中是否已经添加</span></span><br><span class="line">        <span class="comment">// 因为可能在拿到锁时，上一个拿到锁的已经将数据存到redis中了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">            <span class="comment">//4.1若此时缓存中已经存在了，则直接返回，不需要再查数据库了</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2 若缓存中仍然不存在，则查询数据库</span></span><br><span class="line">        shop = <span class="built_in">this</span>.getById(id);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//空值写入redis，防止缓存穿透,注意要设置过期时间</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//5.释放互斥锁</span></span><br><span class="line">        releaseLock(LOCK_SHOP_KEY + id);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：获取锁之后的<strong>缓存二次判断</strong>。</p>
<h3 id="（2）逻辑过期"><a href="#（2）逻辑过期" class="headerlink" title="（2）逻辑过期"></a>（2）逻辑过期</h3><p>我们之所以会出现缓存击穿这个问题的是因为缓存中的key过期失效了，才会导致请求打到数据库上。那么如果我们给缓存设置一个逻辑过期时间在缓存的数据中，缓存本身并不设置过期时间，那么当其他线程访问该数据时就一定会命中缓存。</p>
<p>我们所需要做的，就是在线程获取到缓存时加上个逻辑过期的判断语句即可。若过期了，就<strong>试着获取互斥锁</strong>，若获取互斥锁成功，则<strong>开启一个独立线程去重建缓存</strong>。但是，无论是否获取到互斥锁，当前线程都则<strong>无需等待</strong>，直接<strong>返回旧数据</strong>。</p>
<p>这个方案优点是异步构建缓存，响应速度快。缺点就是会造成<strong>脏读</strong>。</p>
<p>此外，对于逻辑过期也要获取互斥锁这个现象，让我感觉逻辑过期本质上就是对互斥锁方案本身的改进吧。</p>
<p><img src="/../images/1653328663897.png" alt="1653328663897"></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>逻辑过期通用类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 逻辑过期策略的通用类 -- 解决缓存击穿</span></span><br><span class="line"><span class="comment">* 对象存入data,逻辑过期时间存入expireTime</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑过期主方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*缓存击穿--逻辑过期主方法*/</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若未命中，则直接返回null, 因为逻辑过期场景下，redis中的数据是提前写好的，没有就不需要查数据库了</span></span><br><span class="line">    <span class="keyword">if</span>(!StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若redis命中，则判断是否逻辑过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//因为redisObject是一个通用类，所以data类型是Object,这种情况下需要先强转为JSONObject,再使用JSONUtil.toBean()</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="comment">//4.1未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.2已过期，需缓存重建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.1获取互斥锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY+id);</span><br><span class="line">    <span class="comment">//5.2判断是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//5.3成功</span></span><br><span class="line">        <span class="comment">//5.4二次判断redis当中此时是否已经更新过过期时间了</span></span><br><span class="line">        shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        redisData = JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        expireTime = JSONUtil.toBean(shopJson, RedisData.class).getExpireTime();</span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            data = (JSONObject)redisData.getData();</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.5开启独立线程，实现缓存重建</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5.6若未更新，则重建缓存</span></span><br><span class="line">            saveShop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">            <span class="comment">//5.7释放锁</span></span><br><span class="line">            releaseLock(LOCK_SHOP_KEY+id);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.7返回过期的店铺信息</span></span><br><span class="line">    <span class="keyword">return</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：释放锁需要交给异步线程来释放。</p>
<p>异步重建缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池，供逻辑过期方法使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">/*逻辑过期信息存入redis方法*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, <span class="type">long</span> expireseconds)</span>&#123;</span><br><span class="line">    <span class="comment">//1.查询商品数据</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//2.存入redisData</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireseconds));</span><br><span class="line">    <span class="comment">//3.写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提问-1"><a href="#提问-1" class="headerlink" title="提问"></a>提问</h4><p>1.为什么这里会把redisData.getData()强制类型转换为JSONObject,再利用JSONUtil把类型转化为Shop，而不是直接强制类型转换为Shop?</p>
<p>答：因为JSONObject可扩展性更强，功能强大，虽然代码中并未体现，但它可以使用get方法获取属性中的值，也可以使用getString判断是否存在某属性，这对类型不确定的情况下还是很有帮助的。具体参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/NiNg_1_234/article/details/144069674">Java中的JSONObject详解_java jsonobject-CSDN博客</a></p>
<p>2.开启独立线程是怎么实现的？</p>
<p>答：利用的是Executors获取线程池的方式开启独立线程。目前这个线程池是静态变量，在整个应用生命周期内保持存在（注意：静态变量的生命周期与类的加载和卸载相关，而不是由 Spring 容器管理），避免了在任务执行过程中动态创建线程。但由于这个线程池并非spring容器管理，所以无法动态调整线程池大小。改进方法就是可以设置一个线程池Bean交给Spring容器管理，可以在配置文件中设置线程的最大线程数量等参数配置。</p>
<h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><p><strong>互斥锁方案</strong>：由于互斥性，所以数据一致性可以保证，且只需要在原代码上加把锁，没有复杂的逻辑，实现简单。问题就是可能会陷入死锁（当前代码只有一把锁，所以没有体现），而且数据访问是串行执行的，线程需要等待，性能肯定有影响。</p>
<p><strong>逻辑过期方案</strong>：有一个额外线程去重建缓存，线程不需要等待，性能好。但在重构缓存之前，其他线程都只能返回旧数据。此外，实现较为复杂、且需要占用额外的内存来存放逻辑过期时间。</p>
<p><img src="/../images/1653357522914.png" alt="1653357522914"></p>
<h2 id="RedisTemplate工具类"><a href="#RedisTemplate工具类" class="headerlink" title="RedisTemplate工具类"></a>RedisTemplate工具类</h2><p>基于上面的缓存穿透和缓存击穿实现方法，我们可以封装成一个通用的工具类。</p>
<p>这里我们把RedisTemplate工具类的相关方法写入CacheClient类中。</p>
<h3 id="1-通用写缓存方法"><a href="#1-通用写缓存方法" class="headerlink" title="1.通用写缓存方法"></a>1.通用写缓存方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, value, expireTime, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-通用读缓存方法–解决缓存穿透"><a href="#2-通用读缓存方法–解决缓存穿透" class="headerlink" title="2.通用读缓存方法–解决缓存穿透"></a>2.通用读缓存方法–解决缓存穿透</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用读缓存方法 -- 解决缓存穿透</span></span><br><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若redis中存在则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(str, type);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.若redis中没有，则访问数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3.1数据库中不存在，空值写入redis，防止缓存穿透</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, expireTime, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2.若数据库中存在，则存入redis中, 缓存时间为30分钟</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), expireTime, unit);</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-通用获取对象–解决缓存击穿–基于逻辑过期"><a href="#3-通用获取对象–解决缓存击穿–基于逻辑过期" class="headerlink" title="3.通用获取对象–解决缓存击穿–基于逻辑过期"></a>3.通用获取对象–解决缓存击穿–基于逻辑过期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用获取对象 -- 解决缓存击穿 -- 逻辑过期</span></span><br><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryWithLogicExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, String lockPrefix, Long prolongTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">strJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若未命中，则直接返回null, 因为逻辑过期场景下，redis中的数据是提前写好的，没有就不需要查数据库了</span></span><br><span class="line">    <span class="keyword">if</span>(!StrUtil.isNotBlank(strJson))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若redis命中，则判断是否逻辑过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//因为redisObject是一个通用类，所以data类型是Object,这种情况下需要先强转为JSONObject,再使用JSONUtil.toBean()</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="comment">//4.1未过期，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.2已过期，需缓存重建</span></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.1获取互斥锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> tryLock(lockPrefix+id);</span><br><span class="line">    <span class="comment">//5.2判断是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//5.3成功</span></span><br><span class="line">        <span class="comment">//5.4二次判断redis当中此时是否已经更新过过期时间了</span></span><br><span class="line">        strJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        redisData = JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">        expireTime = redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            data = (JSONObject)redisData.getData();</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.5开启独立线程，实现缓存重建</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5.6查询数据库</span></span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">            setWithExpire(key, r, prolongTime, unit);</span><br><span class="line">            <span class="comment">//5.7释放锁</span></span><br><span class="line">            releaseLock(lockPrefix+id);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.7返回过期的店铺信息</span></span><br><span class="line">    <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用写入缓存方法 – 逻辑过期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用写入缓存方法 -- 逻辑过期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithExpire</span><span class="params">(String key, Object value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个逻辑过期对象通用类</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(expireTime)));</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、优惠券秒杀"><a href="#四、优惠券秒杀" class="headerlink" title="四、优惠券秒杀"></a>四、优惠券秒杀</h1><p>这个优惠券秒杀功能主要核心点:</p>
<p>1.全局唯一id的生成</p>
<p>2.乐观锁 – 一人一单</p>
<p>3.悲观锁 – </p>
<p>4.分布式锁</p>
<p>5.lua脚本</p>
<p>6.Redission</p>
<p>7.异步秒杀优化</p>
<p>8.基于redis实现的消息队列</p>
<p>8.Rabbitmq实现的消息队列</p>
<h2 id="1-全局唯一id"><a href="#1-全局唯一id" class="headerlink" title="1.全局唯一id"></a>1.全局唯一id</h2><p>当用户抢购时，就会生成订单并保存到订单表中，如果我们使用数据库自增id的话，就会存在id的规律性太明显的问题。</p>
<p>场景1：如果我们的id具有太明显的规则，那么用户或者说商业竞争者就很容易猜测出我们的一些敏感信息，比如一天总共卖出了多少单，这很明显不合适。</p>
<p>场景2：mysql的单表容量不宜超过500w,当我们数据量过大时，我们需要进行拆库拆表，但拆库拆表后，我们就需要保证id的唯一性。</p>
<p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<p><img src="/../images/1653363100502.png" alt="1653363100502"></p>
<p>同时，为了保证id的安全性，所以我们不能全靠redis的id自增来生成ID,可以用拼接其他信息。例如时间戳。</p>
<p><img src="/../images/1653363172079.png" alt="1653363172079"></p>
<p>ID的组成部分</p>
<p>Long类型：占用8个字节，是64位的整数类型。</p>
<p>id组成：</p>
<ul>
<li>符号位：1位，永远为0</li>
<li>时间戳：31位，以秒为单位，从起始点算起可以用69年</li>
<li>序列号：32位，秒内计数器，支持每秒最多2^32个id</li>
</ul>
<p>时间戳占用Long类型的第2为到第32位：先设置一个起始时间戳，代表起始点，然后我们可以用当前的时间戳-起始时间戳得到的数来填充Long类型的32位。经计算，2^32可以供我们用69年。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//开始时间戳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//2025年3月8号做为起始时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1741464196</span>;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">dateSeconds</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> dateSeconds - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2.生成序列号</span></span><br><span class="line">        <span class="comment">//2.1获取当前时间，精确到天，做为当天自增长key的一部分</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2自增长</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;incr:&quot;</span> + keyPrefix + date);</span><br><span class="line">        <span class="comment">//3.拼接并返回， 时间戳（每秒都不一样）在前32位，自增长id在后32位，这样子可以支持每秒产生最多2^32次个不同的id</span></span><br><span class="line">        <span class="comment">//当然，因为没有做redis的id超限判断，所以这一天最多只能产生2^32次个id，我们也可以自己加上超额判断</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(id.equals(4294967295L))&#123;</span></span><br><span class="line"><span class="comment">            stringRedisTemplate.opsForValue().set(&quot;incr:&quot;+keyPrefix+date, &quot;0&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:这里的 <code>timestamp &lt;&lt; COUNT_BIT | id</code>，这里代表的是将时间戳左移32位并低32位由id填充，因为<code>|</code>运算符用来或运算，即有1填1，全0则0。当id &lt; 2^32时，id只会在低32位存在1，不影响时间戳的加入。</p>
<h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法其实和自定义的全局唯一id类似！！！</p>
<p>雪花算法也是占用64位（1位符号位、41位时间戳，以毫秒为单位、10位机器id和12位序列号）。这相当于每台机器每毫秒可以产生4096个id。</p>
<p>至于机器id分配，则可以通过服务配置来实现，让程序在整个运行期间保持不变。</p>
<p>由于时钟误差或网络延迟等原因，可能会出现时钟回拨的情况。为了处理这种情况，雪花算法通常使用一个缓存机制来存储最近生成的时间戳。如果当前时间戳小于缓存中的时间戳，则拒绝生成ID并等待一段时间再试。这样可以避免由于时钟回拨导致的ID冲突问题。</p>
<h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2.乐观锁"></a>2.乐观锁</h2><p>乐观锁和悲观锁是用于解决<strong>超卖</strong>问题的</p>
<p><img src="/../images/1653368562591.png" alt="1653368562591"></p>
<p>先讲乐观锁：</p>
<p>乐观锁的基本思路就是给数据增加一个版本号字段，每次对数据进行修改时，会先获取原数据的版本号，然后在修改时，带上这个版本号<strong>判断当前版本号是否和之前获取的版本号一致</strong>，若一致的话，则对数据进行修改，并对版本号加1。若不一致，则说明在对数据修改之前，已经被其他线程改动过了，则放弃修改。</p>
<p>乐观锁的核心代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.试着获取秒杀券</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line"><span class="comment">//7.若true,则表示扣减库存成功</span></span><br><span class="line"><span class="keyword">if</span>(b)&#123;</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="string">&quot;抢票成功，订单号:&quot;</span>+voucherOrder.getId());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;抱歉，优惠券已抢光&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们并没有设置版本号来对数据一致性进行判断，而是用更简单的方式（<strong>判断库存是否大于0</strong>），因为我们是秒杀抢票功能，如果我们设置版本号或者直接库存来保证数据的一致性，那么会导致在有充足票的情况下，要是多个人同时抢票得到的初始版本号或者库存相同，那么肯定只有一个人能抢票成功。这是不允许的。</p>
<h2 id="3-悲观锁"><a href="#3-悲观锁" class="headerlink" title="3.悲观锁"></a>3.悲观锁</h2><p><strong>问题引入：</strong></p>
<p>假设一个场景，未抢票的用户几乎同时发起了2次抢票请求，在乐观锁的代码为准，这可能会导致，一个用户同时抢到2张票的情况。为什么呢？因为，即使原代码有判断一人一单的操作，但没有确保判断一人一单操作和扣减库存操作之间的原子性，这就会导致，多个线程都执行完判断一人一单的操作后第一个线程才开始扣减库存，导致一个人可能抢到多张票。究其原因，还是锁的粒度太小导致的。乐观锁只在最后修改数据时起判断作用。</p>
<p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等。</p>
<p>尽管对于多个不同用户发起抢票的情况下，悲观锁不如乐观锁，试想下，如果给操作数据加个锁，那么即便在库存充足的情况下，多个用户发起的抢票也只能串行执行，严重影响效率。</p>
<p>但悲观锁可以解决乐观锁无法解决的<strong>同一个用户的多次频繁请求,即一人一单问题</strong>。因为悲观锁是对同一个用户的多次请求加锁。所以，这个业务中，悲观锁的实现是在乐观锁的基础上进行的！！！两者没有优劣之分，都很重要。</p>
<p>核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给用户id加锁，intern是指锁的对象是常量池中的字符串</span></span><br><span class="line"><span class="comment">//因为每次toString创建的都是新对象，加锁没有用，所以需要intern()方法</span></span><br><span class="line"><span class="comment">//同时，锁需要在事务提交之后才能释放，保证线程安全</span></span><br><span class="line"><span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了锁的正常释放和保证事务可以回滚，需要单独提取个方法，并给方法加上<code>@Transactional</code>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId, Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1获取订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order:&quot;</span>);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    <span class="comment">//6.2用户id</span></span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    <span class="comment">//6.3代金券id</span></span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h3><p>1.<strong>synchronized</strong></p>
<p>synchronized 块是 阻塞获取锁 的。当一个线程尝试进入一个 synchronized 块时，如果锁已经被其他线程持有，该线程会被阻塞（即进入等待状态），直到锁被释放。一旦锁被释放，等待的线程会竞争锁，获得锁的线程可以继续执行同步块中的代码。</p>
<p>2.<strong>intern</strong>()方法</p>
<p>intern() 方法是 Java 中 String 类的一个方法，用于将字符串对象放入字符串常量池中，并返回该字符串的引用。如果常量池中已经存在相同内容的字符串，则直接返回该字符串的引用；否则，将该字符串添加到常量池中，并返回其引用。</p>
<h3 id="提问-2"><a href="#提问-2" class="headerlink" title="提问"></a>提问</h3><p>1.为什么要在锁中使用代理对象执行创建订单的逻辑？</p>
<p>答：<code>@Transactional</code> 注解需要通过<strong>代理对象</strong>来生效。直接调用 this.createVoucherOrder(voucherId, userId) 不会触发 Spring 的事务管理，因为 this 指向的是当前对象实例，而不是代理对象。</p>
<p>2.为什么要创建订单逻辑代码提取出来改成一个方法呢?</p>
<p>答：防止锁提前释放</p>
<p>首先我们看看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//校验操作省略</span></span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你发现了什么？@Transaction这个注解是加在整个方法上面的对吧。但问题是，并不是说事务提交了锁才会释放!!!锁可能会在事务提交前提前释放，这是完全可能的，毕竟锁并不知道事务是否成功提交了。所以，我们才会选择在锁块中调用有@Transaction的方法来解决锁提前释放的问题。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>目前这个悲观锁只能使用于单个服务，如果部署了多个服务（tomcat），即集群的话，每个tomcat都有一个属于自己的jvm,所以多个tomcat之间无法共用同一把锁。</p>
<p><img src="/../images/1653374044740.png" alt="1653374044740"></p>
<h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4.分布式锁"></a>4.分布式锁</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<p>那么分布式锁他应该满足一些什么样的条件呢？</p>
<p><strong>可见性</strong>：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<p><strong>互斥</strong>：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
<p><strong>高可用</strong>：程序不易崩溃，时时刻刻都保证较高的可用性</p>
<p><strong>高性能</strong>：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
<p><strong>安全性</strong>：安全也是程序中必不可少的一环</p>
<p>常见的分布式锁有三种</p>
<ol>
<li>mysql</li>
<li>redis</li>
<li>zookeeper</li>
</ol>
<p>这里先使用redis来实现。至于mysql，基本不会考虑，zookeeper等学了之后再用</p>
<h3 id="Redis分布式锁的核心思路"><a href="#Redis分布式锁的核心思路" class="headerlink" title="Redis分布式锁的核心思路"></a>Redis分布式锁的核心思路</h3><p>实现分布式锁需要满足以下两个条件</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
<p>利用redis的setNx方法，实现思路如下。</p>
<p><img src="/../images/1653382830810.png" alt="1653382830810"></p>
</li>
</ul>
<p>首先，为了方便，我们可以创建一个锁的通用类<strong>SimpleRedisLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> &#123;</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//uuid用于区分进程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">keyPrefix</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="comment">//这里把脚本当作定值预先加载了，避免每次获取锁都要重新读取脚本内容而浪费时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long expireSecond)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线程id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(keyPrefix + name, uuid+id, expireSecond, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//防止b是null时拆箱出错</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(keyPrefix);</span><br><span class="line">        <span class="keyword">if</span>(val.equals(uuid + Thread.currentThread().toString()))&#123;</span><br><span class="line">            stringRedisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在抢票中使用自定义分布式锁的代码部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悲观锁解决方案</span></span><br><span class="line"><span class="comment">//给用户id加锁</span></span><br><span class="line"><span class="comment">//分布式锁解决悲观锁的分布式问题</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span>+voucherId+<span class="string">&quot;:&quot;</span>+userId;</span><br><span class="line"><span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(stringRedisTemplate, lockKey);</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">1000L</span>))&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//乐观锁解决方案</span></span><br><span class="line">        <span class="comment">//6.试着获取秒杀券</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="comment">//7.若true,则表示扣减库存成功</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            voucherOrder.setUserId(userId);</span><br><span class="line">            voucherOrder.setVoucherId(voucherId);</span><br><span class="line">            <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(<span class="string">&quot;抢票成功，订单号:&quot;</span>+voucherOrder.getId());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;抱歉，优惠券已抢光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(e.toString());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;请勿频繁点击抢票&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，现在我们知道了抢票过程中锁的流程创建是一步步递进的，乐观锁–&gt;悲观锁–&gt;分布式锁。思路也是循序渐进的。</p>
<h3 id="提问-3"><a href="#提问-3" class="headerlink" title="提问"></a>提问</h3><p><strong>1.uuid的作用是什么</strong></p>
<p>答：uuid是为了区分不同服务之间的标识。从代码中，我们可以看到，uuid是一个静态变量，也就是服务在初始化时就已经定下了，而uuid可以保证每次生成的内容不一致，所以，每个服务启动时都会有一个不同uuid值。这样可以方便区分锁究竟是哪个服务拿到的。</p>
<p><strong>2.获取当前线程的threadId有什么用</strong></p>
<p>答：用于区分同一个服务下，究竟是哪个线程拿到了锁。</p>
<p><strong>3.uuid和threadId存入redis中有什么用</strong></p>
<p>答：为了保证锁的安全释放。假设一个场景，锁被1号服务的1号线程获取到了，但在执行业务过程中发生了阻塞，导致长时间未完成，此时锁的过期时间又到了，导致锁被提前释放。这时，2号服务的1号线程过来拿到了锁，执行业务流程。但执行过程中，1号服务的1号线程业务执行完毕，准备执行释放锁的操作。这会导致2号服务的1号线程的锁被提前释放。为了避免这种问题的发生，我们需要区分不同进程和不同线程，在释放锁的时候先判断目前锁究竟是不是自己的，是则释放锁，不是则不进行释放。所以，我们需要引入uuid+线程id来保证锁的安全释放。</p>
<p>图片详解</p>
<p><img src="/../images/1653385920025.png" alt="1653385920025"></p>
<h2 id="5-Lua脚本"><a href="#5-Lua脚本" class="headerlink" title="5.Lua脚本"></a>5.Lua脚本</h2><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%E3%80%82%E6%B3%A8%E6%84%8F%EF%BC%9Alua%E8%84%9A%E6%9C%AC%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%85%B7%E6%9C%89%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E5%8F%AA%E6%98%AF%E7%94%A8%E5%9C%A8redis%E6%97%B6%EF%BC%8Credis%E8%B5%8B%E4%BA%88%E5%AE%83%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。注意：lua脚本本身不具有原子性，只是用在redis时，redis赋予它实现原子性。</a></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>redis提供的调用函数基本语法如下</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其他参数&#x27;</span>, ....)</span><br></pre></td></tr></table></figure>

<p>例如，我们要执行set name ldy,则脚本这么写</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;ldy&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如我们要先执行完set name ldh,再执行get name,则脚本如下</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行set name ldh</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;ldh&#x27;</span>)</span><br><span class="line"># 再执行get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>其中<code>local</code>用于声明变量值。</p>
<p>写好脚本后，需要使用redis命令来调用脚本，调用脚本的常见命令如下:</p>
<p><img src="/../images/image-20250404184421196.png" alt="image-20250404184421196"></p>
<p>在redis中也可以直接写lua脚本语句进行执行</p>
<p><img src="/../images/image-20250404184518534.png" alt="image-20250404184518534"></p>
<p>上述语句没有需要从外部获取的key值，所以脚本内容后面跟个0。</p>
<p>其中的语法规则是 <code>Eval &quot;脚本内容&quot; 脚本需要的key类型的参数个数 参数值</code>，其中参数值的规则是这样子的，首先参数个数为n, 则后面跟的n个参数都是KEYS数组的参数值，从第n+1个参数起则是ARGV数组的参数值。</p>
<p><img src="/../images/image-20250404185803664.png" alt="image-20250404185803664"></p>
<p>要是脚本中的key和value不想写死，可以做为参数传递。key类型的参数需要放入KEYS数组，其他参数则需要放入ARGV数组中，在脚本中可以从KEYS和ARGV数组中获取这些参数。</p>
<p>注意：数组的索引是从1开始的</p>
<p>例如下图所示</p>
<p><img src="/../images/image-20250404190732159.png" alt="image-20250404190732159"></p>
<p>我们再来看看，在lua脚本中怎么写语句合适。如下所示，我们用自定义变量名来接收数组中的值，然后用自定义的变量名来做为参数。方便我们更好的理解代码。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> val1 = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val2 = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> val3 = ARGV[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> res redis.call(<span class="string">&#x27;LPUSH&#x27;</span>, key, val1, val2, val3)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>把上述语句写在一行里，然后执行也是可以成功的。注意：lpush命令返回列表中的元素个数。</p>
<p><img src="/../images/image-20250404191438460.png" alt="image-20250404191438460"></p>
<p>ok,lua脚本的基本使用就这些了。可以开始优化分布式锁了。</p>
<h3 id="分布式锁的优化"><a href="#分布式锁的优化" class="headerlink" title="分布式锁的优化"></a>分布式锁的优化</h3><p>首先回顾下释放锁的业务逻辑</p>
<p>1.获取线程标识（uuid+线程id）</p>
<p>2.判断锁中存放的线程标识是否和当前的一致</p>
<p>3.如果一致，则释放锁（删除）</p>
<p>4.如果不一致，则什么都不做</p>
<p>用lua脚本实现</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val1 = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val2 = redis.call(<span class="string">&#x27;get&#x27;</span>, key) <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(val1 == val2) <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"># 简化后是这样子的</span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>使用java代码调用lua脚本来改造分布式锁</strong></p>
<p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图所示</p>
<p><img src="/../images/image-20250404200842686.png" alt="image-20250404200842686"></p>
<p>使用lua脚本释放锁代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态脚本常量，提前加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT; </span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//设置脚本路径</span></span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    <span class="comment">//设置返回值类型</span></span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                                Collections.singletonList(keyPrefix + name),</span><br><span class="line">                                uuid + Thread.currentThread().getId()</span><br><span class="line">                               );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码详解</strong></p>
<ul>
<li>**<code>DefaultRedisScript&lt;Long&gt;</code>**：这是变量的类型，表示这是一个<code>DefaultRedisScript</code>对象，泛型<code>&lt;Long&gt;</code>表示该脚本的执行结果类型为<code>Long</code>。</li>
<li><strong>static静态代码块</strong>用于用于初始化类的静态变量。</li>
<li><strong>ClassPathResource</strong>是Spring框架提供的一个类，用于表示类路径下的资源文件。</li>
<li><strong>Collections.singletonList</strong>用于设置单值的列表</li>
</ul>
<h2 id="6-Redisson"><a href="#6-Redisson" class="headerlink" title="6.Redisson"></a>6.Redisson</h2><p>首先，我们基于setnx实现的自定义分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p>什么是Redisson</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<h3 id="分布式锁-Redisson快速入门"><a href="#分布式锁-Redisson快速入门" class="headerlink" title="分布式锁-Redisson快速入门"></a>分布式锁-Redisson快速入门</h3><p>引入依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置Redisson客户端，其中RedissonClien就是我们实现分布式锁的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用Redisson自带的分布式锁实现抢票逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悲观锁解决方案</span></span><br><span class="line"><span class="comment">//给用户id加锁</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span>+voucherId+<span class="string">&quot;:&quot;</span>+userId;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//乐观锁解决方案</span></span><br><span class="line">        <span class="comment">//6.试着获取秒杀券</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="comment">//7.若true,则表示扣减库存成功</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            voucherOrder.setUserId(userId);</span><br><span class="line">            voucherOrder.setVoucherId(voucherId);</span><br><span class="line">            <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(<span class="string">&quot;抢票成功，订单号:&quot;</span>+voucherOrder.getId());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;抱歉，优惠券已抢光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(e.toString());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;请勿频繁点击抢票&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，和我们之前自定义分布式锁SimpleRedisLock的逻辑完全一致，我们自定义的分布式锁就相当于一个低配版的Redisson。</p>
<h3 id="重入问题"><a href="#重入问题" class="headerlink" title="重入问题"></a>重入问题</h3><p>首先，我们执行如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;mylock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拿到锁了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有拿到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去查redis，可以看见，创建的锁是Hash类型。其中value是当前锁的重入次数，第1次是00110001，第2次是00110010，至于为什么0011开头，我也不清楚哈哈。field应该是线程标识符</p>
<p><img src="/../images/image-20250404202916900.png" alt="image-20250404202916900"></p>
<p>重入机制测试代码，如下,可以自己打断点调试下，查看value的变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:1&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;方法1获取锁成功&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.info(<span class="string">&quot;方法1释放锁成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:1&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;方法2获取锁成功&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.info(<span class="string">&quot;方法2释放锁成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>tryLock中有重载方法可以传入重试时间</p>
<p><img src="/../images/image-20250404210813586.png" alt="image-20250404210813586"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span>+voucherId+<span class="string">&quot;:&quot;</span>+userId;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"></span><br><span class="line">lock.tryLock(<span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>晚点再解读</p>
<h3 id="锁重试和看门狗机制"><a href="#锁重试和看门狗机制" class="headerlink" title="锁重试和看门狗机制"></a>锁重试和看门狗机制</h3><p>锁重试机制顾名思义就是可以对锁的获取进行不断的重试，这里暂不赘述。重要的是看门狗机制。</p>
<p>先回顾下，我们之前自定义的锁的释放是怎么样的，就分两种情况，1是过期自动释放，2是业务完成，手动释放。显然过期自动释放是有问题的，因为很可能过期自动释放后，原线程其实并未挂掉，只是因为某些原因执行时间较长，我们不能让没有挂掉的线程的锁提前给释放，所以需要不断的给过期时间进行延长。这就是看门狗机制。</p>
<p>那你可能会问了，那过期时间有什么用啊，既然都不断延长了？</p>
<p>答：就是为了让线程挂掉时可以释放掉锁，因为线程挂掉了，那么肯定不可能继续执行下去了，这个时候也就不会进行自动延迟过期时间了。</p>
<p>总之，看门狗机制就是为了确保线程在存活期间不会因锁的过期而失去锁的持有权，同时在线程挂掉时能够及时释放锁，避免死锁或资源泄露。</p>
<p>源码部分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>

<h3 id="MutiLock原理"><a href="#MutiLock原理" class="headerlink" title="MutiLock原理"></a>MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。这就导致一种情况，明明获取到了锁，结果这突然锁没了，其他线程还能获取这把锁。</p>
<p>为了解决这个问题，我们获取这把锁时就不用主从关系获取锁了，而是把加锁逻辑写入到每个节点中，只有所有节点都加锁成功时，才算成功加锁。只要有一个节点拿不到锁，就不算加锁成功。保证了加锁的可靠性。</p>
<p>Redisson这块实在不好总结，毕竟源码也是一知半解，后面有时间再补吧。</p>
<h2 id="7、异步优化"><a href="#7、异步优化" class="headerlink" title="7、异步优化"></a>7、异步优化</h2><p>先回顾下我们之前抢秒杀券的流程</p>
<p>1、查询优惠卷</p>
<p>2、判断秒杀库存是否足够</p>
<p>3、校验是否是一人一单</p>
<p>4、扣减库存</p>
<p>5、创建订单</p>
<p>以上5步，都是直操作数据库，还是串行执行，执行速度有待提升。</p>
<p>执行速度提升有2种方法</p>
<p>1.利用redis进行数据校验</p>
<p>2.开启异步线程执行创建订单的操作</p>
<p>以上2种方法相结合可以有效提升运行速度，对于异步线程，我们可以使用阻塞队列来实现，让一个线程专门去对数据库执行扣减库存和创建订单的操作，不必担心线程池消耗殆尽的问题。</p>
<p><img src="/../images/1653561657295.png" alt="1653561657295"></p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要到redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p>
<h3 id="1-Redis完成秒杀资格判断"><a href="#1-Redis完成秒杀资格判断" class="headerlink" title="1.Redis完成秒杀资格判断"></a>1.Redis完成秒杀资格判断</h3><p>需求：</p>
<ul>
<li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li>
<li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li>
<li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li>
<li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li>
</ul>
<p>VoucherServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-基于阻塞队列实现秒杀优化"><a href="#2-基于阻塞队列实现秒杀优化" class="headerlink" title="2.基于阻塞队列实现秒杀优化"></a>2.基于阻塞队列实现秒杀优化</h3><p>实现代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">EXECUTOR_SERVICE</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; script;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;();</span><br><span class="line">    script.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lus&quot;</span>));</span><br><span class="line">    script.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">SeckillVoucherHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SeckillVoucherHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不断循环去查看阻塞队列中是否存在订单信息</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//1.从阻塞队列获取订单信息</span></span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                <span class="comment">//2.创建订单</span></span><br><span class="line">                createVoucherOrder(order);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                log.error(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">        <span class="comment">//2.获取优惠券id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">        <span class="comment">//3.获取锁</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:seckill:&quot;</span> + voucherId + <span class="string">&quot;:&quot;</span> + userId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">//4.拿到锁</span></span><br><span class="line">            <span class="keyword">if</span>(b)&#123;</span><br><span class="line">                <span class="comment">//获取代理对象</span></span><br><span class="line">                proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">                <span class="comment">//创建订单</span></span><br><span class="line">                proxy.createVoucherOrder(order);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.没拿到锁</span></span><br><span class="line">            log.error(<span class="string">&quot;限一人一单&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="comment">// 5.1.查询订单</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, order.getVoucherId()).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, order.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">// 扣减失败</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    save(order);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//1.查询秒杀券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="keyword">if</span>(seckillVoucher == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀券不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断秒杀活动是否开始</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="keyword">if</span>(beginTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动暂未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="keyword">if</span>(endTime.isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(script, Collections.emptyList(), voucherId, userId);</span><br><span class="line">    <span class="keyword">if</span>(execute == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;lua脚本执行异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!execute.equals(<span class="number">0L</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足&quot;</span>) : Result.fail(<span class="string">&quot;限一人一单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成订单号</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order:&quot;</span>);</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    <span class="comment">//将订单信息存入到阻塞队列中</span></span><br><span class="line">    orderTasks.add(order);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h4><p>1.如下代码作用是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">SeckillVoucherHandler</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：因为类初始化之后，随时都可能要处理阻塞队列，所以在类实例初始化完成时，就开始执行<code>new SeckillVoucherHandler()</code>的run方法，处理阻塞队列。</p>
<h2 id="8-基于redis的消息队列"><a href="#8-基于redis的消息队列" class="headerlink" title="8.基于redis的消息队列"></a>8.基于redis的消息队列</h2><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p>在redis中，一共有三种数据类型可以实现消息队列。</p>
<p><img src="/../images/image-20250314175932374.png" alt="image-20250314175932374"></p>
<h3 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a><strong>基于List结构模拟消息队列</strong></h3><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src="/../images/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>无法避免消息丢失</strong></li>
<li><strong>只支持单消费者</strong></li>
</ul>
<h3 id="基于PubSub结构模拟消息队列"><a href="#基于PubSub结构模拟消息队列" class="headerlink" title="基于PubSub结构模拟消息队列"></a><strong>基于PubSub结构模拟消息队列</strong></h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p>
<p><img src="/../images/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="基于Stream实现消息队列"><a href="#基于Stream实现消息队列" class="headerlink" title="基于Stream实现消息队列"></a>基于Stream实现消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img src="/../images/1653577301737.png" alt="1653577301737"></p>
<p>例如：</p>
<p><img src="/../images/1653577349691.png" alt="1653577349691"></p>
<p>读取消息的方式之一：XREAD</p>
<p><img src="/../images/1653577445413.png" alt="1653577445413"></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img src="/../images/1653577643629.png" alt="1653577643629"></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img src="/../images/1653577659166.png" alt="1653577659166"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img src="/../images/1653577689129.png" alt="1653577689129"></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src="/../images/1653577801668.png" alt="1653577801668"></p>
<p>创建消费者组：<br><img src="/../images/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p>
<p> <strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>

<p> <strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p> <strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p><strong>从消费者组读取消息：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：</li>
</ul>
<p>对于起始消息ID,分两类情况，1.未消费 2.已消费未确认</p>
<p><strong>“&gt;”：从下一个未消费的消息开始</strong></p>
<p><strong>“0”：从第一个已消费未确认开始</strong></p>
<p><strong>“其他id”：从该id的后面开始获取已消费未确认的消息</strong><img src="/../images/image-20250406143645095.png" alt="image-20250406143645095"></p>
<p><strong>确认消息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XACK key group id [id ...]</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20250406142947663.png" alt="image-20250406142947663"></p>
<h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p>
<ul>
<li><p>创建一个Stream类型的消息队列，名为stream.orders</p>
</li>
<li><p>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</p>
<p>或者</p>
<p>修改seckillVoucher，在执行完lua脚本，认定有抢购资格后，向stream.orders中添加消息，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line"><span class="comment">//3.3 发送消息到stream.order队列中</span></span><br><span class="line">stringRedisTemplate.opsForStream().add(MapRecord.create(<span class="string">&quot;stream.order&quot;</span>, map));</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</p>
</li>
</ul>
<p>实现整体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHanler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHanler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//循环获取消息队列中的信息</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.获取消息队列中的订单信息  XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.order &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                        StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">//2.判断消息是否获取成功</span></span><br><span class="line">                <span class="keyword">if</span>(list == <span class="literal">null</span> || list.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//3.没有消息，进入下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.解析订单消息</span></span><br><span class="line">                <span class="comment">//这里的MapRecord中的第一个String是消息id,后面的Object和Object组合起来是一个map,存放键值对</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; entries =</span><br><span class="line">                        list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; map = entries.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//4.获取成功，则下单</span></span><br><span class="line">                handleVoucherOrder(order);</span><br><span class="line">                <span class="comment">//5.ACK确认消息</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>, <span class="string">&quot;g1&quot;</span>,  entries.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//若消息处理发生异常，则需要处理PendingList中的消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取PendingList中的消息</span></span><br><span class="line">            List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//2.判断消息是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span>(list == <span class="literal">null</span> || list.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//3.没有消息，说明消息已经全部确认完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.解析订单消息</span></span><br><span class="line">            <span class="comment">//这里的MapRecord中的第一个String是消息id,后面的Object和Object组合起来是一个map,存放键值对</span></span><br><span class="line">            MapRecord&lt;String, Object, Object&gt; entries =</span><br><span class="line">                    list.get(<span class="number">0</span>);</span><br><span class="line">            Map&lt;Object, Object&gt; map = entries.getValue();</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4.获取成功，则下单</span></span><br><span class="line">            handleVoucherOrder(order);</span><br><span class="line">            <span class="comment">//5.ACK确认消息</span></span><br><span class="line">            stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>, <span class="string">&quot;g1&quot;</span>,  entries.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;处理PendingList中发生异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户、优惠券id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//2.获取锁对象</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//3.获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="comment">//4.判断锁是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        <span class="comment">//获取锁失败，输出日志</span></span><br><span class="line">        log.error(<span class="string">&quot;发送异常，没获取到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        proxy.createVoucherOrder(order);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户已经下过单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">         .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">         .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">     <span class="comment">//库存不足</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            userId.toString(),</span><br><span class="line">            voucherId.toString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(execute != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1不为0返回异常信息</span></span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足!&quot;</span>) : Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.创建订单,异步下单</span></span><br><span class="line">    <span class="comment">//3.1 获取订单id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(SECKILL_ORDER_KEY);</span><br><span class="line">    <span class="comment">//3.2将用户id, 优惠券id和 订单id存入stream中</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line">    <span class="comment">//3.3 发送消息到stream.order队列中</span></span><br><span class="line">    stringRedisTemplate.opsForStream().add(MapRecord.create(<span class="string">&quot;stream.order&quot;</span>, map));</span><br><span class="line">    <span class="comment">//3.4返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码详解-1"><a href="#代码详解-1" class="headerlink" title="代码详解"></a>代码详解</h4><p>因为是基于redis的Stream实现消息队列，所以涉及到的api比较多，下面简单解释下api.</p>
<p><strong>1.消费组消息获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                       Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                       StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                       StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">               );</span><br></pre></td></tr></table></figure>

<p>上述代码翻译成redis语句是</p>
<p><code>XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.order &gt;</code></p>
<p>意思是从g1消费者组中获取一条未读取到的消息给消费者c1，若stream中有未读取的消息，则获取最早未读取的消息，若stream中没有消息，则阻塞2s。若2s内还未获取到新消息则结束。语句执行完的结果是读取到的消息。这里测试了下，如果有2个消费者c1和c2，c1读取到消息后，c2无法读取c1读取过的消息，即一条消息只能被一个消费者读取，这里就是单纯为了加快消费速度，将<strong>一个消费组交由多个消费者共同处理</strong>。不能把之前学习过的rabbitmq的广播机制代入到这里。</p>
<p>注意：代码中没有创建消费组这一代码的实现，因为这个消费组我们已经在redis中提前创建好了。</p>
<p><img src="/../images/image-20250406140243528.png" alt="image-20250406140243528"></p>
<p><strong>2.自动类型转换</strong></p>
<p>订单数据存入到消息队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line"><span class="comment">//3.3 发送消息到stream.order队列中</span></span><br><span class="line">stringRedisTemplate.opsForStream().add(MapRecord.create(<span class="string">&quot;stream.order&quot;</span>, map));</span><br></pre></td></tr></table></figure>

<p>从消息队列获取订单数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MapRecord&lt;String, Object, Object&gt; entries = list.get(<span class="number">0</span>);</span><br><span class="line">Map&lt;Object, Object&gt; map = entries.getValue();</span><br><span class="line"><span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，我们存入消息队列中的数据是Map&lt;String, String&gt;,最后从消息队列中读取出来的map类型是Map&lt;Object,Object&gt;，最后经由<strong>BeanUtil.fillBeanWithMap()</strong>,根据字段名称自动赋值和类型转换。</p>
<p>拿userId举例，实现了Long –&gt; String –&gt; Obejct –&gt; Long的类型转换，很厉害吧。</p>
<p>至于<code>BeanUtil.fillBeanWithMap(map, new VoucherOrder(), true)</code>这句代码中的true，则是为了忽略错误。</p>
<p>即当从 map 填充数据到目标对象（这里是 VoucherOrder）时，如果遇到某些字段无法匹配或转换失败的情况，ignoreError() 会告诉工具类忽略这些错误，继续完成其他字段的填充，而不是抛出异常中断整个过程。</p>
<p><strong>3.handlePendingList方法的作用</strong></p>
<p>pending-list中存的是获取已消费但未确认的消息。当我们从消息队列中获取到消息，并消费完消息时，需要根据消息id及时确认该消息已经被处理完成，否则改消息依然会存在于pending-list中等待确认。这种情况是为了防止获取到消息后，在消息处理时发生意外而导致的消息丢失问题。至于消息可能被重复消费（指的是消息处理完，但是在确认消息时发生意外）问题，那就看最终的消息处理有没有校验机制了，在这里，订单在创建时依然会进行一人一单和库存校验，所以不用担心消息被重复消费的问题。</p>
<p>因为redis的消息队列实用性不如专门的消息队列，所以点到为止。</p>
<h2 id="9-基于RabbitMq的消息队列"><a href="#9-基于RabbitMq的消息队列" class="headerlink" title="9.基于RabbitMq的消息队列"></a>9.基于RabbitMq的消息队列</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h3><p>添加内容如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">  host: 192.168.10.129 # 你的虚拟机IP</span><br><span class="line">  port: 5672 # 端口</span><br><span class="line">  virtual-host: ldy-mq # 虚拟主机</span><br><span class="line">  username: ldy # 用户名</span><br><span class="line">  password: 20050718 # 密码</span><br><span class="line">  listener:</span><br><span class="line">    simple:</span><br><span class="line">      prefetch: 1 #每个消费者每次只能获取一个消息，处理完才能获取下一条消息</span><br></pre></td></tr></table></figure>

<h3 id="3-新增消息监听类"><a href="#3-新增消息监听类" class="headerlink" title="3.新增消息监听类"></a>3.新增消息监听类</h3><p><img src="/../images/image-20250424152238039.png" alt="image-20250424152238039"></p>
<p>代码如下，其中第二个消息监听器是跟订单超时相关的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IVoucherOrderService voucherOrderService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; CANCEL_ORDER_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        CANCEL_ORDER_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        CANCEL_ORDER_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;cancelOrder.lua&quot;</span>));</span><br><span class="line">        CANCEL_ORDER_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;seckill.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;voucher.seckill.exchange&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;seckill&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerSeckillVoucherOrder</span><span class="params">(Map&lt;String, String&gt; map)</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取消息&quot;</span>+map);</span><br><span class="line">        <span class="comment">//map对象转换为order对象</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//4.获取成功，则下单</span></span><br><span class="line">        voucherOrderService.handleVoucherOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;voucher.order.overtime.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;voucher.order.dead.exchange&quot;, type = &quot;direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;overTime&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerOverTimeOrder</span><span class="params">(VoucherOrder order)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//如果订单未支付，则删除订单并删除相关库存和购票记录</span></span><br><span class="line">        <span class="keyword">if</span>(order.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> order.getId();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">            LambdaUpdateWrapper&lt;VoucherOrder&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>();</span><br><span class="line">            wrapper.eq(VoucherOrder::getId, orderId).set(VoucherOrder::getStatus, <span class="number">4</span>);</span><br><span class="line">            voucherOrderService.update(wrapper);</span><br><span class="line">            log.info(<span class="string">&quot;订单超时，已取消，订单id:&quot;</span>+orderId);</span><br><span class="line">            <span class="comment">//1.先恢复数据库库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                    .setSql(<span class="string">&quot;stock = stock + 1&quot;</span>)</span><br><span class="line">                    .update();</span><br><span class="line">            <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;数据库库存恢复异常，订单id:&quot;</span>+orderId);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;数据库库存恢复异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.恢复redis中的库存和购票记录，使用lua脚本保证原子性</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                        CANCEL_ORDER_SCRIPT,</span><br><span class="line">                        Collections.emptyList(),</span><br><span class="line">                        userId.toString(),</span><br><span class="line">                        voucherId.toString()</span><br><span class="line">                );</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;redis库存恢复异常，订单id:&quot;</span>+orderId);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;redis恢复库存异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-修改VoucherOrderServiceImpl"><a href="#4-修改VoucherOrderServiceImpl" class="headerlink" title="4.修改VoucherOrderServiceImpl"></a>4.修改VoucherOrderServiceImpl</h3><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line">    <span class="comment">//        //3.3 发送消息到stream.order队列中</span></span><br><span class="line">    <span class="comment">//        stringRedisTemplate.opsForStream().add(MapRecord.create(&quot;stream.order&quot;, map));</span></span><br><span class="line">    <span class="comment">//利用rabbitmq发送消息队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;voucher.seckill.exchange&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;seckill&quot;</span>, map);</span><br><span class="line">    <span class="comment">//3.4返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-新增订单超时自动删除功能"><a href="#5-新增订单超时自动删除功能" class="headerlink" title="5.新增订单超时自动删除功能"></a>5.新增订单超时自动删除功能</h3><p><strong>注意：</strong>因为黑马点评项目没有做支付功能模块的内容，所以有些业务点我们要考虑。</p>
<p>1.用户<strong>订单取消</strong>后<strong>还可以下单、库存要增加</strong>。</p>
<p>2.一人一单的查询逻辑要外加<strong>订单的状态判断</strong>。订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款</p>
<p>利用rabbitMq的延迟消息功能实现订单超时自动删除</p>
<p>（1）先安装DelayExchange插件</p>
<p>我是docker部署的rabbitmq，所以docker安装插件方法如下</p>
<p>插件下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p>
<p>查看rabbitmq插件目录对应的数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20250424153144268.png" alt="image-20250424153144268"></p>
<p>把插件安装到Mountpoint属性指向的目录里</p>
<p>然后执行以下命令启用插件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

<p>（2）修改createVoucherOrder创建订单的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).notIn(<span class="string">&quot;status&quot;</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户已经下过单&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    order.setStatus(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">    <span class="comment">//发送超时消息至死信交换机</span></span><br><span class="line">    System.out.println(<span class="string">&quot;准备发送超时消息&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(</span><br><span class="line">        RabbitMqConstant.VOUCHER_ORDER_DEAD_EXCHANGE,</span><br><span class="line">        RabbitMqConstant.DEAD_VOUCHER_ORDER_KEY,</span><br><span class="line">        order,</span><br><span class="line">        message -&gt; &#123;</span><br><span class="line">            <span class="comment">//为方便测试10秒即超时</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20250424153500512.png" alt="image-20250424153500512"></p>
<p>监听器的代码看第3点。</p>
<h1 id="五、达人探店"><a href="#五、达人探店" class="headerlink" title="五、达人探店"></a>五、达人探店</h1><h2 id="1-发布探店笔记"><a href="#1-发布探店笔记" class="headerlink" title="1.发布探店笔记"></a>1.发布探店笔记</h2><p>关于发布探店笔记，这里主要是存储相应的探店图片。</p>
<p>图片上传接口如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原始文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 生成新文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">createNewFileName</span><span class="params">(String originalFilename)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取后缀</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> StrUtil.subAfter(originalFilename, <span class="string">&quot;.&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 生成目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> name.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> hash &amp; <span class="number">0xF</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> (hash &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">    <span class="comment">// 判断目录是否存在</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;&quot;</span>, d1, d2));</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">        dir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成文件名</span></span><br><span class="line">    <span class="keyword">return</span> StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;/&#123;&#125;.&#123;&#125;&quot;</span>, d1, d2, name, suffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码详解-2"><a href="#代码详解-2" class="headerlink" title="代码详解"></a>代码详解</h3><p>1.获取文件后缀suffix</p>
<p><code>String suffix = StrUtil.subAfter(originalFilename, &quot;.&quot;, true);</code>这段代码是获取文件的后缀名，例如test.jpg，获取到的就是jpg后缀。</p>
<p>2.uuid,d1和d2的作用</p>
<p>首先根据UUID生成一个随机字符串并做为最后的文件名称，再获取这个随机字符串的hash值，根据这个hash值，先取低4位，再右移4位再取低4位。作用就是d1是文件第一层的编号（0-15），d2是文件第二层的编号（0-15）。所以d1和d2就是获取一个随机存放图片的路径。而uuid和suffix结合就是最后存储的文件名称。最后获取的到的文件名不仅包含了文件名，还包含了一部分存储文件路径。</p>
<p>3.transferTo方法作用</p>
<p>transferTo方法会将 MultipartFile 对象中的文件内容写入到目标文件路径中。</p>
<p>如果目标路径的目录不存在，<code>transferTo</code> 方法不会自动创建目录，因此在调用 <code>transferTo</code> 之前，需要确保目标目录已经存在（如在 <code>createNewFileName</code> 方法中已经创建了目录）。</p>
<h2 id="2-查看探店笔记"><a href="#2-查看探店笔记" class="headerlink" title="2.查看探店笔记"></a>2.查看探店笔记</h2><p>核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">    <span class="keyword">if</span>(blog == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取博客对应的作者信息</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">    <span class="comment">// 查询已被点赞</span></span><br><span class="line">    isBlogLiked(blog);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，除了经过数据库查询外，还进行了作者信息查询和点赞信息查询</p>
<p>所以Blog这个实体类中还有额外的参数设置,如下所示，icon、name、和isLike不是数据库对应表中的字段，所以加上了<code>@TableFiled(exist = false)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否点赞过了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isLike;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-点赞功能-ZSet"><a href="#3-点赞功能-ZSet" class="headerlink" title="3.点赞功能-ZSet"></a>3.点赞功能-ZSet</h2><p>对于点赞功能的实现，我们需要保证，每篇笔记每个人只能点一次赞，再点赞只能取消，一个人不能刷赞。这个功能基于数据库来实现的话，还需要存储额外的一张表来对于用户id和笔记id。比较浪费时间，空间也比较浪费。所以我们基于redis中的zset这个数据类型来存储每篇笔记的点赞用户。</p>
<p>核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查看用户是否点赞过该篇博客</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//若用户未登录，则无法点赞</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户未登录，无法点赞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKE_KEY + id;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    <span class="comment">//2.若没点赞过，则点赞数加一</span></span><br><span class="line">    <span class="keyword">if</span>(score == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="built_in">this</span>.update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span>(success)&#123;</span><br><span class="line">            <span class="comment">//2.1.保存用户到set集合</span></span><br><span class="line">            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3.若已点赞，则数据库点赞数减一</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="built_in">this</span>.update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span>(success)&#123;</span><br><span class="line">            <span class="comment">//3.1.把用户从redis的Set集合移出</span></span><br><span class="line">            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，首先在redis中校验当前用户是否已经点赞过，若已点赞，则先在数据库中点赞数减一，再把用户从redis集合中移出。未点赞同理。</p>
<h2 id="4-点赞排行榜"><a href="#4-点赞排行榜" class="headerlink" title="4.点赞排行榜"></a>4.点赞排行榜</h2><p>上面点赞功能的实现为什么使用zset而不使用set，主要是因为为了实现点赞排行榜这个功能。</p>
<p>首先，先明确这个点赞排行榜的功能指的是最近点赞的用户，即越新的赞，排行越靠前。而zset中，我们存储的是点赞的当前时间戳，所以需要使用rever</p>
<p>核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询近期点赞的top5用户</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKE_KEY + id;</span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().reverseRange(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//2.解析其中的用户id</span></span><br><span class="line">    <span class="keyword">if</span>(top5 == <span class="literal">null</span> || top5.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//若top5为空，表明没有人点赞。则直接返回空集合</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//3.根据用户id查询用户,并赋值信息到userDto，避免重要数据泄露</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>,ids);</span><br><span class="line">    List&lt;User&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>,ids).last(<span class="string">&quot;order by Field(id,&quot;</span> + str+ <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    List&lt;UserDTO&gt; userDtos = users.stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDtos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提问-4"><a href="#提问-4" class="headerlink" title="提问"></a>提问</h3><p>1.Set集合不是无序吗，为什么能保证最后ids是有序的？</p>
<p>答：因为使用了Stream的方式。虽然 <code>Set</code> 是无序的，但在迭代时，<code>Stream</code> 会按照提取的顺序处理这些值。</p>
<ul>
<li><code>reverseRange</code> 方法返回的 <code>Set&lt;String&gt;</code> 的内容是按照 Redis 中有序集合的倒序排列提取的。</li>
<li>使用 <code>Stream</code> 和 <code>collect</code> 方法将 <code>Set&lt;String&gt;</code> 转换为 <code>List&lt;Long&gt;</code> 时，会保留 <code>Set</code> 的迭代顺序。</li>
<li>因此，<code>ids</code> 的顺序会和 Redis 中的有序集合的倒序一致。</li>
</ul>
<p>2.为什么sql语句查询最后要使用<code>order by Field(id,&quot; + str+ &quot;)&quot;</code></p>
<p>答：为了让最后获取到的字段按照ids的顺序排列，保证获取到的用户信息严格按照点赞顺序排列。</p>
<p><code>ORDER BY FIELD()</code> 是一种特殊的排序方式，用于根据指定的值列表对结果进行排序。它允许你定义一个自定义的排序顺序，而不是按照默认的升序或降序排序。</p>
<p><code>ORDER BY FIELD()</code> 的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> FIELD(column_name, value1, value2, value3, ...)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>column_name</code>：需要排序的列名。</li>
<li><code>value1, value2, value3, ...</code>：定义的排序顺序。这些值是列中可能存在的值，它们将按照指定的顺序进行排序。</li>
<li>如果查询到的字段的value并没有在order by field()的value中，则默认排到最后。它们之间的排序顺序是按照默认的升序或降序。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在上面代码中，很好的使用了stream流的方式处理数据，先是Set转为List,然后是User转为UserDTO避免不必要字段泄露。</p>
<h1 id="六、好友关注"><a href="#六、好友关注" class="headerlink" title="六、好友关注"></a>六、好友关注</h1><h2 id="1-关注功能"><a href="#1-关注功能" class="headerlink" title="1.关注功能"></a>1.关注功能</h2><p>好友关注功能一共有三个接口，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">IFollowService followService;</span><br><span class="line"><span class="comment">//关注好友</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isfollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@PathVariable(&quot;isfollow&quot;)</span> Boolean isfollow)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(id, isfollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.isFollow(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询共同好友</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.followCommons(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的实现方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long id, Boolean isfollow)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取登录用户的id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follow:&quot;</span>+userId;</span><br><span class="line">    <span class="comment">//2.判断是取关还是关注</span></span><br><span class="line">    <span class="keyword">if</span>(isfollow)&#123;</span><br><span class="line">        <span class="comment">//3.1关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setFollowUserId(id);</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        <span class="comment">//3.2添加关注信息到redis</span></span><br><span class="line">        stringRedisTemplate.opsForSet().add(key, id.toString());</span><br><span class="line">        save(follow);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//4.1取关</span></span><br><span class="line">        remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, id));</span><br><span class="line">        <span class="comment">//4.2从redis中移除信息</span></span><br><span class="line">        stringRedisTemplate.opsForSet().remove(key, id.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2.查询是否关注</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;follow_user_id&quot;</span>, id).eq(<span class="string">&quot;user_id&quot;</span>, userId).count();</span><br><span class="line">    <span class="comment">//3.判断返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follow:&quot;</span>+userId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;follow:&quot;</span>+id;</span><br><span class="line">    <span class="comment">//2.获取双方的关注set交集</span></span><br><span class="line">    Set&lt;String&gt; commons = stringRedisTemplate.opsForSet().intersect(key, key1);</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(commons))&#123;</span><br><span class="line">        <span class="comment">//若无交集，则返回空集合</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; list = commons.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//4.获取用户</span></span><br><span class="line">    List&lt;UserDTO&gt; userDtos = userService.listByIds(list).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDtos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，添加关注和查看共同关注功能利用了redis的set集合。用户的关注消息存储到set集合中可以方便获取共同好友以及获取动态推送的粉丝信息，避免读取数据库花费较多时间。</p>
<h2 id="2-好友动态推送-Feed流"><a href="#2-好友动态推送-Feed流" class="headerlink" title="2.好友动态推送-Feed流"></a>2.好友动态推送-Feed流</h2><p>首先介绍下什么是Feed流</p>
<p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p>
<p><img src="/../images/1653808641260.png" alt="1653808641260"></p>
<p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p><img src="/../images/1653808993693.png" alt="1653808993693"></p>
<p>Feed流的实现有两种模式：</p>
<p>Feed流产品有两种常见模式：<br><strong>Timeline</strong>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p><strong>智能排序</strong>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>
</ul>
<p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p>
<p>，因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<p><strong>拉模式</strong>：也叫做读扩散</p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序。</p>
<p>简单来说就是把消息写到自己的发件箱，粉丝都从这个发件箱里拉信息。</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src="/../images/1653809450816.png" alt="1653809450816"></p>
<p><strong>推模式</strong>：也叫做写扩散。</p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>简单来说就是把消息写到粉丝的收件箱，粉丝读他们自己的收件箱即可。</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src="/../images/1653809875208.png" alt="1653809875208"></p>
<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src="/../images/1653812346852.png" alt="1653812346852"></p>
<p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ul>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src="/../images/1653813047671.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src="/../images/1653813462834.png" alt="1653813462834"></p>
<p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-获取推送信息"><a href="#3-获取推送信息" class="headerlink" title="3.获取推送信息"></a>3.获取推送信息</h2><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<p><img src="/../images/1653819821591.png" alt="1653819821591"></p>
<p>一、定义出来具体的返回值实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogController</p>
<p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码详解-3"><a href="#代码详解-3" class="headerlink" title="代码详解"></a>代码详解</h3><h4 id="1-下面这段代码在做什么"><a href="#1-下面这段代码在做什么" class="headerlink" title="1.下面这段代码在做什么"></a>1.下面这段代码在做什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>答：这段代码用于获取<strong>最小时间戳minTime</strong>，并且获取<strong>偏移量os</strong>。最小时间戳作为下一次查询的最大时间戳，offset是下一次查询时跳过的元素个数（默认为一，因为最大时间戳是上一次遍历的最小时间戳，所以查询时起码要跳过这1条）。设置偏移量是为了<strong>防止多条动态发布的时间戳一样</strong>的情况下，记录已经获取了的相同最小时间戳的动态的条数。在接着往下查询时会跳过偏移量数量的动态。这段代码是for循环，所以从前往后遍历，所以需要在time不等于minTime的情况下更新minTime并重置os,因为越后面时间戳越小。</p>
<h4 id="2-reverseRangeByScoreWithScores-方法"><a href="#2-reverseRangeByScoreWithScores-方法" class="headerlink" title="2.reverseRangeByScoreWithScores 方法"></a>2.reverseRangeByScoreWithScores 方法</h4><p>reverseRangeByScoreWithScores 方法用于从 Redis 的有序集合（ZSet）中，按照分数范围从高到低获取元素及其分数。<br>参数说明：</p>
<ul>
<li>key: 指定操作的 ZSet 键。</li>
<li>min 和 max: 分别表示分数范围的下限和上限（这里是 0 和 max）。</li>
<li>offset: 表示跳过的元素个数，即从符合条件的元素中跳过前面的 offset 个元素。</li>
<li>count: 表示最多返回的元素个数（这里是 3）。</li>
</ul>
<h1 id="七、附近商户"><a href="#七、附近商户" class="headerlink" title="七、附近商户"></a>七、附近商户</h1><h2 id="1-GEO数据结构的基本用法"><a href="#1-GEO数据结构的基本用法" class="headerlink" title="1.GEO数据结构的基本用法"></a>1.GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li><p>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</p>
<p><code>geoadd geo:1 10 10 dongyang 10.1 10.1 yiwu</code></p>
</li>
<li><p>GEODIST：计算指定的两个点之间的距离并返回</p>
<p><code>geodist geo:1 dongyang yiwu km</code></p>
<p><img src="/../images/image-20250408202246048.png" alt="image-20250408202246048"></p>
</li>
<li><p>GEOHASH：将指定member的坐标转为hash字符串形式并返回</p>
<p><code>geohash geo:1 dongyang</code></p>
<p><img src="/../images/image-20250408202434818.png" alt="image-20250408202434818"></p>
</li>
<li><p>GEOPOS：返回指定member的坐标</p>
<p><img src="/../images/image-20250408202457694.png" alt="image-20250408202457694"></p>
</li>
<li><p>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</p>
</li>
<li><p>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</p>
<p><img src="/../images/image-20250408204702412.png" alt="image-20250408204702412"></p>
</li>
<li><p>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</p>
</li>
</ul>
<p>注意：<strong>GEO数据结构本质就是ZSet数据结构</strong></p>
<p><img src="/../images/image-20250408201915030.png" alt="image-20250408201915030"></p>
<h2 id="2、-导入店铺数据到GEO"><a href="#2、-导入店铺数据到GEO" class="headerlink" title="2、 导入店铺数据到GEO"></a>2、 导入店铺数据到GEO</h2><p>具体场景说明：</p>
<p><img src="/../images/1653822036941.png" alt="1653822036941"></p>
<p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p>
<p><img src="/../images/1653822021827.png" alt="1653822021827"></p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p>代码</p>
<p>HmDianPingApplicationTests</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">//方法1，每得到一个地理信息就添加到redis</span></span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            <span class="comment">//方法2，先存到集合里，最后再一次性添加到redis中</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法2,一次性添加</span></span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码详解-4"><a href="#代码详解-4" class="headerlink" title="代码详解"></a>代码详解</h3><h4 id="1-stream流分组"><a href="#1-stream流分组" class="headerlink" title="1.stream流分组"></a>1.stream流分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, List&lt;Shop&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br></pre></td></tr></table></figure>

<p>熟悉stream流的分组方法。</p>
<h4 id="2-Geo相关api"><a href="#2-Geo相关api" class="headerlink" title="2.Geo相关api"></a>2.Geo相关api</h4><p>看代码注释。</p>
<h2 id="3-附近商户-实现附近商户功能"><a href="#3-附近商户-实现附近商户功能" class="headerlink" title="3 附近商户-实现附近商户功能"></a>3 附近商户-实现附近商户功能</h2><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p>
<p>第一步：导入pom</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.1</span><span class="number">.6</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>ShopController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key, </span><br><span class="line">                        GeoReference.fromCoordinate(x, y), <span class="comment">//以（x, y）为坐标点</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>), <span class="comment">//搜素范围，5000米</span></span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)<span class="comment">// limit表示返回的结果数量，includeDistance表示返回结果包含与中心点距离</span></span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码详解-5"><a href="#代码详解-5" class="headerlink" title="代码详解"></a>代码详解</h3><p><strong>1.geoSearch方法看代码注释</strong></p>
<p>new Distance(5000), 默认单位为米。若指定，则可以<code>new Distance(50000, Metrics.KILOMETERS)</code>，代表50000公里。所以，<strong>多用ctrl+p查看有什么重载方法</strong>。</p>
<p><strong>2.stream流的过滤</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">content.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">    ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">    distanceMap.put(shopIdStr, result.getDistance());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.根据id查询shop</span></span><br><span class="line"><span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">List&lt;Shop&gt; shopList = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD( id, &quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"><span class="keyword">for</span> (Shop shop : shopList) &#123;</span><br><span class="line">    shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">    System.out.println(shop.getDistance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是分页查询，虽然查了end个，但最后还是得跳过前面的from个数量。</p>
<p>同时，为了按位置顺序排列，使用forEach遍历时，要按序存储id到ids列表为sql查询作排序，此外，为了记录距离，还需要设置一个distanceMap存储对应id的离中心点的距离,方便最后查找出结果后再添加上距离。</p>
<h1 id="八、用户签到"><a href="#八、用户签到" class="headerlink" title="八、用户签到"></a>八、用户签到</h1><p>用户</p>
<h2 id="1-BitMap数据结构"><a href="#1-BitMap数据结构" class="headerlink" title="1.BitMap数据结构"></a>1.BitMap数据结构</h2><ul>
<li><p>SETBIT：向指定位置（offset）存入一个0或1</p>
<p><code>setbit sign:202504:1 0 1</code></p>
</li>
<li><p>GETBIT ：获取指定位置（offset）的bit值</p>
<p><code>getbit sign:202504:1 0</code></p>
</li>
<li><p>BITCOUNT ：统计BitMap中值为1的bit位的数量</p>
<p><code>bitcount sign:202504:1 0 4</code>   闭包统计，即[0-4]</p>
</li>
<li><p>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</p>
<p>bitfield的命令选项有些多</p>
<p>1.get选项，假设当前bit存储内容为10001000</p>
<p><code>bitfield sign:202504:1 get u8 0</code>，获取偏移量0开始的8位无符号整数。得136</p>
<p><code>bitfield sign:202504:1 get u8 4</code>，获取偏移量4开始的8位无符号整数，末尾自动补零。得128</p>
<p><img src="/../images/image-20250409004301279.png" alt="image-20250409004301279"></p>
<p>2.set,选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置位于偏移量0的8位无符号整数为10,即 00001010</span><br><span class="line">BITFIELD mykey SET u8 0 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</p>
<p><img src="/../images/image-20250409004911234.png" alt="image-20250409004911234"></p>
</li>
<li><p>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</p>
</li>
<li><p>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</p>
</li>
</ul>
<p>注意:BitMap本质上是String</p>
<h2 id="2-实现签到功能"><a href="#2-实现签到功能" class="headerlink" title="2.实现签到功能"></a>2.实现签到功能</h2><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p>
<p><img src="/../images/1653833970361.png" alt="1653833970361"></p>
<p><strong>代码</strong></p>
<p>UserController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以年月为key进行存储,因为dayOfMonth是从1开始的，所以需要减一从0索引开始存储。</p>
<h2 id="3-签到统计"><a href="#3-签到统计" class="headerlink" title="3. 签到统计"></a>3. 签到统计</h2><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img src="/../images/1653834455899.png" alt="1653834455899"></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>  BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<p><img src="/../images/1653835784444.png" alt="1653835784444"></p>
<p>代码</p>
<p><strong>UserController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码详解-6"><a href="#代码详解-6" class="headerlink" title="代码详解"></a>代码详解</h3><ol>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">           key,</span><br><span class="line">           BitFieldSubCommands.create()</span><br><span class="line">                   .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>其中的<code>BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)</code>用于设置读取方式为无符号的当前天数，偏移量为0。得到的是10进制的整数，从list中取第一个即可。</p>
<p>2.统计连续签到。</p>
<p>利用十进制转二进制的比较进行。每次都进行最低位&amp;1比较，为1则结果加1并将该数往右移一位。若为0则停止统计。</p>
<h1 id="九、UV统计"><a href="#九、UV统计" class="headerlink" title="九、UV统计"></a>九、UV统计</h1><p>使用HyperLogLog数据结构进行访问量统计</p>
<h2 id="1-HyperLogLog数据结构"><a href="#1-HyperLogLog数据结构" class="headerlink" title="1.HyperLogLog数据结构"></a>1.HyperLogLog数据结构</h2><p>先我们搞懂两个概念：</p>
<ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p>
<p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<p><img src="/../images/1653837988985.png" alt="1653837988985"></p>
<p>1.pfadd</p>
<p><code>pfadd myuv 1</code>   <code>pfadd myuv2 3</code></p>
<p>2.pfcount</p>
<p><code>pfcount myuv</code>  结果：1</p>
<p>3.pfmerge</p>
<p><code>pfmerge myuv myuv2</code></p>
<p><code>pfcount myuv</code>  结果：2</p>
<p>注意，HyperLogLog底层是String类型</p>
<p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p>
<p><img src="/../images/1653838053608.png" alt="1653838053608"></p>
<p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>
<h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>至此，黑马点评的复习结束了。总算是复习完成了，现在是2025&#x2F;4&#x2F;9 1:08。比预想的晚了2天才结束，从关注开始就比较快速的过一遍了，不过也算够了吧，但也还是把关键代码都再写了一遍，也算是仓促吧，后面开始复习微服务了，还要背八股&#x2F;(ㄒoㄒ)&#x2F;~~。加油！！！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ldy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">http://example.com/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/" title="微服务总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">微服务总结</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/25/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ldy</div><div class="author-info__description">I am a slow walker,but I never walk backwards.我走得很慢，但是我从来不会后退</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qcqwy"><i class="fab fa-github"></i><span>别点这里</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、项目介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-text">二、短信登录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">2.验证码的获取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BC%93%E5%AD%98"><span class="toc-text">验证码缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C"><span class="toc-text">3.登录校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98"><span class="toc-text">用户信息缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA"><span class="toc-text">4.登录拦截</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89token%E5%88%B7%E6%96%B0%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">（1）token刷新拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">（2）登录拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%97%AE%EF%BC%9A"><span class="toc-text">提问：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">为什么需要有两个拦截器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">三、商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">1.缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">（1）缓存空对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">（2）布隆过滤器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">2.缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%BE%85%E8%A1%A5%E5%85%85"><span class="toc-text">解决方案实现待补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">3.缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">（1）互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%97%AE"><span class="toc-text">提问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="toc-text">（2）逻辑过期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%97%AE-1"><span class="toc-text">提问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-text">方案对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisTemplate%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">RedisTemplate工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E7%94%A8%E5%86%99%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95"><span class="toc-text">1.通用写缓存方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E7%94%A8%E8%AF%BB%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95%E2%80%93%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">2.通用读缓存方法–解决缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E2%80%93%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E2%80%93%E5%9F%BA%E4%BA%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="toc-text">3.通用获取对象–解决缓存击穿–基于逻辑过期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-text">四、优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id"><span class="toc-text">1.全局唯一id</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95"><span class="toc-text">雪花算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">2.乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">3.悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%97%AE-2"><span class="toc-text">提问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">4.分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-text">Redis分布式锁的核心思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%97%AE-3"><span class="toc-text">提问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Lua%E8%84%9A%E6%9C%AC"><span class="toc-text">5.Lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">分布式锁的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Redisson"><span class="toc-text">6.Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redisson%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">分布式锁-Redisson快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-text">重入问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-text">源码解读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8C%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6"><span class="toc-text">锁重试和看门狗机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutiLock%E5%8E%9F%E7%90%86"><span class="toc-text">MutiLock原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-text">7、异步优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redis%E5%AE%8C%E6%88%90%E7%A7%92%E6%9D%80%E8%B5%84%E6%A0%BC%E5%88%A4%E6%96%AD"><span class="toc-text">1.Redis完成秒杀资格判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-text">2.基于阻塞队列实现秒杀优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">代码详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">8.基于redis的消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EList%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">基于List结构模拟消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">基于PubSub结构模拟消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">基于Stream实现消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-text">基于Stream的消息队列-消费者组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84Stream%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-text">基于Redis的Stream结构作为消息队列，实现异步秒杀下单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-1"><span class="toc-text">代码详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%9F%BA%E4%BA%8ERabbitMq%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">9.基于RabbitMq的消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">1.导入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">2.修改配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B0%E5%A2%9E%E6%B6%88%E6%81%AF%E7%9B%91%E5%90%AC%E7%B1%BB"><span class="toc-text">3.新增消息监听类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9VoucherOrderServiceImpl"><span class="toc-text">4.修改VoucherOrderServiceImpl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B0%E5%A2%9E%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-text">5.新增订单超时自动删除功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-text">五、达人探店</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%91%E5%B8%83%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-text">1.发布探店笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-2"><span class="toc-text">代码详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-text">2.查看探店笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD-ZSet"><span class="toc-text">3.点赞功能-ZSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-text">4.点赞排行榜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%97%AE-4"><span class="toc-text">提问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-text">六、好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E6%B3%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">1.关注功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A5%BD%E5%8F%8B%E5%8A%A8%E6%80%81%E6%8E%A8%E9%80%81-Feed%E6%B5%81"><span class="toc-text">2.好友动态推送-Feed流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E6%8E%A8%E9%80%81%E4%BF%A1%E6%81%AF"><span class="toc-text">3.获取推送信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-3"><span class="toc-text">代码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">1.下面这段代码在做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-reverseRangeByScoreWithScores-%E6%96%B9%E6%B3%95"><span class="toc-text">2.reverseRangeByScoreWithScores 方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7"><span class="toc-text">七、附近商户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">1.GEO数据结构的基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81-%E5%AF%BC%E5%85%A5%E5%BA%97%E9%93%BA%E6%95%B0%E6%8D%AE%E5%88%B0GEO"><span class="toc-text">2、 导入店铺数据到GEO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-4"><span class="toc-text">代码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-stream%E6%B5%81%E5%88%86%E7%BB%84"><span class="toc-text">1.stream流分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Geo%E7%9B%B8%E5%85%B3api"><span class="toc-text">2.Geo相关api</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7-%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E5%8A%9F%E8%83%BD"><span class="toc-text">3 附近商户-实现附近商户功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-5"><span class="toc-text">代码详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0"><span class="toc-text">八、用户签到</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BitMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.BitMap数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">2.实现签到功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-text">3. 签到统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-6"><span class="toc-text">代码详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81UV%E7%BB%9F%E8%AE%A1"><span class="toc-text">九、UV统计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HyperLogLog%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.HyperLogLog数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E7%BB%93"><span class="toc-text">完结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/24/Langchain4j%E5%AD%A6%E4%B9%A0/" title="轻松掌握Langchain4j">轻松掌握Langchain4j</a><time datetime="2025-08-24T11:47:55.000Z" title="发表于 2025-08-24 19:47:55">2025-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/18/%E9%9D%A2%E7%BB%8F%E6%94%B6%E9%9B%86/" title="面经收集">面经收集</a><time datetime="2025-08-18T05:03:46.000Z" title="发表于 2025-08-18 13:03:46">2025-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/15/%E6%B7%B1%E5%85%A5java%E9%9B%86%E5%90%88/" title="深入java集合">深入java集合</a><time datetime="2025-08-15T09:57:34.000Z" title="发表于 2025-08-15 17:57:34">2025-08-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/11/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="开发常见问题汇总">开发常见问题汇总</a><time datetime="2025-07-11T15:59:20.000Z" title="发表于 2025-07-11 23:59:20">2025-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/12/%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/" title="面经记录">面经记录</a><time datetime="2025-06-12T12:49:19.000Z" title="发表于 2025-06-12 20:49:19">2025-06-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://t.alcy.cc/fj/')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ldy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>