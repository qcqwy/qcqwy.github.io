<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>后端知识点总结 | Journey</title><meta name="author" content="ldy"><meta name="copyright" content="ldy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="随心记 这篇用于随时记各类八股文，后面会详细拆分各个模块 一、Spring相关1.Spring框架中的单例bean是线程安全的吗？答：不是。首先，Spring中的单例bean是全局共享的。一般情况下，spring的bean中注入的都是无状态的对象（无状态指的是不会存储数据，即没有定义可修改的成员变量），所以不会有线程安全问题。但如果假设这个bean定义了可修改的成员变量，多个线程如果同时访问并修改">
<meta property="og:type" content="article">
<meta property="og:title" content="后端知识点总结">
<meta property="og:url" content="http://example.com/2025/04/20/%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93-%E9%9A%8F%E5%BF%83%E8%AE%B0/index.html">
<meta property="og:site_name" content="Journey">
<meta property="og:description" content="随心记 这篇用于随时记各类八股文，后面会详细拆分各个模块 一、Spring相关1.Spring框架中的单例bean是线程安全的吗？答：不是。首先，Spring中的单例bean是全局共享的。一般情况下，spring的bean中注入的都是无状态的对象（无状态指的是不会存储数据，即没有定义可修改的成员变量），所以不会有线程安全问题。但如果假设这个bean定义了可修改的成员变量，多个线程如果同时访问并修改">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png">
<meta property="article:published_time" content="2025-04-19T16:58:46.000Z">
<meta property="article:modified_time" content="2025-05-19T09:14:34.386Z">
<meta property="article:author" content="ldy">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png"><link rel="shortcut icon" href="/img/logo2.jpeg"><link rel="canonical" href="http://example.com/2025/04/20/%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93-%E9%9A%8F%E5%BF%83%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '后端知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-19 17:14:34'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.alcy.cc/fj/')"><nav id="nav"><span id="blog-info"><a href="/" title="Journey"><img class="site-icon" src="/img/logo.jpeg"/><span class="site-name">Journey</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">后端知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-19T16:58:46.000Z" title="发表于 2025-04-20 00:58:46">2025-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-19T09:14:34.386Z" title="更新于 2025-05-19 17:14:34">2025-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="后端知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>随心记</p>
<p>这篇用于随时记各类八股文，后面会详细拆分各个模块</p>
<h2 id="一、Spring相关"><a href="#一、Spring相关" class="headerlink" title="一、Spring相关"></a>一、Spring相关</h2><h3 id="1-Spring框架中的单例bean是线程安全的吗？"><a href="#1-Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="1.Spring框架中的单例bean是线程安全的吗？"></a>1.Spring框架中的单例bean是线程安全的吗？</h3><p>答：不是。首先，Spring中的单例bean是全局共享的。一般情况下，spring的bean中注入的都是<strong>无状态</strong>的对象（无状态指的是不会存储数据，即没有定义可修改的成员变量），所以不会有线程安全问题。但如果假设这个bean定义了可修改的成员变量，多个线程如果同时访问并修改这个成员变量时，可能会造成数据的不一致，这种情况可用使用<strong>多例或者加锁来解决</strong>。</p>
<p>知识点：无状态Bean（即没有可修改的成员变量）、有状态Bean</p>
<h3 id="2-什么是AOP"><a href="#2-什么是AOP" class="headerlink" title="2.什么是AOP"></a>2.什么是AOP</h3><p>答：AOP的话，指的就是<strong>面向切面编程</strong>，简单说就是把一些业务逻辑中相同的代码抽取到一个独立模块中，通过<strong>动态代理</strong>的方式增强原方法，让业务逻辑更加简洁。</p>
<p>知识点：</p>
<p><strong>JDK动态代理</strong>，被代理的对象必须实现一个接口</p>
<p><strong>CGLIB动态代理</strong>，适用于被代理的对象没有实现接口的场景。</p>
<p><strong>Spring AOP 默认使用JDK动态代理</strong>，但如果目标类没有实现接口，则会自动切换到CGLIB动态代理。</p>
<h3 id="3-项目中有没有用到过AOP"><a href="#3-项目中有没有用到过AOP" class="headerlink" title="3.项目中有没有用到过AOP"></a>3.项目中有没有用到过AOP</h3><p>答: 我之前在尚庭公寓的后台管理系统中使用AOP来记录系统的操作日志，主要思路就是找到要记录日志的方法，使用AOP的环绕通知和切点表达式来获取该方法的相关数据，像是调用的用户信息、类名、方法参数这些，将它们其保存到数据库。此外，在项目里，比如@Transactional开启事务的注解、以及拦截器(实现 HandlerInterceptor 这个接口)、@ExceptionHandler异常处理类注解其实都是用到了aop。</p>
<h3 id="4-Spring中事务失效的场景有哪些"><a href="#4-Spring中事务失效的场景有哪些" class="headerlink" title="4.Spring中事务失效的场景有哪些"></a>4.Spring中事务失效的场景有哪些</h3><p>答：我知道的有4种。</p>
<p>第一种是<strong>异常捕获处理</strong>。就是在方法里对异常进行try catch后，假设发生了异常，而<strong>catch代码块中没有抛出异常</strong>，这种情况就会导致事务失效。解决方法的话就是可以在catch中抛出这个异常。</p>
<p>第二种是<strong>抛出检查型异常</strong>。因为事务的这个注解<strong>默认是对非检查型异常抛出时才会进行事务回滚</strong>。解决方法的话，我就会直接配置rollback属性为Exception,这样可以保证对于任何异常都会进行回滚。</p>
<p>第三种是<strong>方法没有声明public这个访问控制符</strong>。解决方法就是修改方法的访问控制符为public。</p>
<p>第四种是<strong>使用this调用带有@Transaction注解的方法</strong>。</p>
<p>第四种我在生活优选这个项目里碰到过，就是我在这个项目的创建订单业务里，我一开始没有使用分布式锁，使用的是悲观锁和乐观锁，那时我碰到的问题就是，如果在创建订单的这个方法上加上事务的话，会导致锁的提前释放。所以我把锁里面的这部分代码抽取出来到一个方法里，这个方法携带@Transaction注解，但是使用this这个关键字调用这个方法的话，会导致事务失效，需要利用<strong>AopContext的currentProxy()方法</strong>获取这个类的代理对象，使用代理对象调用这个方法才可以让事务成功生效。</p>
<h3 id="5-Spring的Bean的生命周期"><a href="#5-Spring的Bean的生命周期" class="headerlink" title="5.Spring的Bean的生命周期"></a>5.Spring的Bean的生命周期</h3><p>答：bean的声明周期分为7个阶段。</p>
<p>1.首先调用构造函数实例化bean</p>
<p>2.进行bean的依赖注入</p>
<p>3.处理以Aware为后缀的接口</p>
<p>4.执行bean的后置处理器BeanPostProcessor的前置方法</p>
<p>5.执行初始化方法(一个是实现InitializingBean这个接口并重写对应的方法，一种是自己在方法上面加上@PostConstruct这个注解)</p>
<p>6.执行bean的后置处理器的后置方法</p>
<p>7.最后就是bean的销毁</p>
<p>下面是我自定义的测试</p>
<p><img src="/../images/image-20250420182919589.png" alt="image-20250420182919589"></p>
<h3 id="6-Spring的循环依赖问题"><a href="#6-Spring的循环依赖问题" class="headerlink" title="6.Spring的循环依赖问题"></a>6.Spring的循环依赖问题</h3><p>循环依赖：指的是两个及以上的bean相互依赖对方，比如a依赖b，b依赖a。</p>
<p>循环依赖问题大部分可以由<strong>三级缓存</strong>来解决。</p>
<p>一级缓存：单例池，缓存的是已经初始化完成的bean.</p>
<p>二级缓存：缓存的是早期的生命周期未走完的bean对象（来自三级缓存）</p>
<p>三级缓存：缓存的是ObjectFactory对象工厂，用于创建某个对象（可以是原始对象或代理对象）</p>
<p>至于为什么要使用三级缓存而不是二级主要是因为<strong>代理对象的问题</strong>，代理对象的创建是在二级缓存对象之后（即生命周期后期），所以无法（在需要代理对象注入的情况下）将代理对象注入给对方。三级缓存通过<code>ObjectFactory</code>延迟了Bean对象的创建时机，使得Spring可以在需要时动态创建原始对象或代理对象，并将其存入二级缓存。</p>
<p>假设a依赖b，b依赖a的代理对象.</p>
<p>a先初始化，将a的对象工厂存入三级缓存，此时需要依赖注入b。所以b开始初始化，需要依赖注入a的代理对象，三级缓存中的a看到b需要的是代理对象，就创建代理对象存入到二级缓存并注入给b。b成功创建后存入一级缓存并注入给二级缓存中的a,a（代理对象或者原始对象）就创建成功并存入到一级缓存中了。</p>
<p>虽然Spring通过三级缓存解决了大部分循环依赖问题，但仍然有一些限制：</p>
<ul>
<li><strong>构造器注入</strong>：Spring无法解决构造器注入的循环依赖问题，因为构造器注入要求在构造过程中完成所有依赖注入，此时原对象是无法存入三级缓存。解决方法是在构造函数参数上使用<code>@Lazy</code>注解延迟初始化。</li>
</ul>
<h3 id="7-SpringMVC的执行流程"><a href="#7-SpringMVC的执行流程" class="headerlink" title="7.SpringMVC的执行流程"></a>7.SpringMVC的执行流程</h3><p>1.首先用户发起请求到前端控制器DispatcherServlet.</p>
<p>2.DispatcherServlet收到请求后会调用HandlerMapping(处理器映射)</p>
<p>3.HandlerMapping找到具体的处理器，生成处理器对象和处理器拦截器（如果有），再一起返回给DispatcherServlet.</p>
<p>4.DispatcherServlet再调用HandlerAdapter(处理器适配器)</p>
<p>5.HandlerAdapter经过适配调用具体的处理器（handler&#x2F;Controller）</p>
<p>如果是前后端分离的情况下，到这里流程就结束了，返回给前端的一般都是json字符串</p>
<p>但如果是jsp这种前后端不分离的情况下，还会有几个步骤。</p>
<p>6.处理器执行完成会返回ModelAndView给DispatcherServlet</p>
<p>7.DispatcherServlet将ModelAndView传递给ViewReslover视图解析器</p>
<p>8.视图解析器会将ModelAndView解析成View返回给DispatcherServlet</p>
<p>9.DispatcherServlet对View进行视图渲染后返回给用户</p>
<h3 id="8-SpringBoot自动配置原理"><a href="#8-SpringBoot自动配置原理" class="headerlink" title="8.SpringBoot自动配置原理"></a>8.SpringBoot自动配置原理</h3><p>在SpringBoot项目的启动类上面我们会使用@SpringBootApplication这个注解，这个注解是对三个注解进行了封装，包括@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这三个注解。</p>
<p>其中**@EnableAutoConfiguration<strong>这个注解是实现自动配置的核心注解，该注解通过@Import注解导入对应的配置选择器。而这个配置选择器会自动读取一个文件，就是该项目引用的jar包的classpath路径下的META-INF&#x2F;spring.factories文件，这个文件中包含了所要</strong>自动配置类的全类名的列表**。</p>
<p>这些配置类有条件注解，像是<code>@ConditionalOnClass</code>（判断是否有对应的字节码文件）和<code>@ConditionalOnProperty</code>（判断是否有对应的配置信息）这种，<strong>根据条件注解判断是否注入到Spring容器中</strong>，且其中定义的Bean也一样有条件注解。</p>
<p>注意，我现在这个版本的这个文件里面已经没有自动导入的全类名了。查看了下，好像放到了META-INF&#x2F;spring文件下的以imports为后缀的文件里。</p>
<p><img src="/../images/image-20250421222934681.png" alt="image-20250421222934681"></p>
<p><img src="/../images/image-20250421224243054.png" alt="image-20250421224243054"></p>
<p>spring自动装配的实际应用：</p>
<p>1.属性自动装配（Setter注入）</p>
<p>在属性上使用@Autowired注解</p>
<p>2.构造器自动装配</p>
<p>在构造器上使用@Autowired注解或者定义final成员属性，在类上面加上@RequiredArgsConstructor注解</p>
<p>注意，构造器自动装配的参数可以使用final关键字定义成员变量，而属性自动装配是动态注入，无法使用final关键字。所以两者各有应用场景。</p>
<h3 id="9-Spring框架常见注解"><a href="#9-Spring框架常见注解" class="headerlink" title="9.Spring框架常见注解"></a>9.Spring框架常见注解</h3><p>1.Spring常见注解–主要是跟bean的实例化和依赖注入相关</p>
<p><img src="/../images/image-20250421224821837.png" alt="image-20250421224821837"></p>
<p>其中的Scope指的就是作用域，使用在@Component类上面或者@Bean注解的方法上面。默认情况下，Spring 的 Bean 是单例的（<code>singleton</code>），但通过 <code>@Scope</code> 注解，可以指定其他作用域，如原型（<code>prototype</code>）、会话（<code>session</code>）、请求（<code>request</code>）等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 指定作用域为原型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="comment">// 类的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;session&quot;)</span> <span class="comment">// 指定作用域为会话</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.SpringMVC常见注解–主要是跟web相关的（请求和响应）</p>
<p><img src="/../images/image-20250421225352598.png" alt="image-20250421225352598"></p>
<p>3.SpringBoot常见注解–主要是跟自动配置相关</p>
<p><img src="/../images/image-20250421225510711.png" alt="image-20250421225510711"></p>
<h3 id="10-Mybatis执行流程"><a href="#10-Mybatis执行流程" class="headerlink" title="10.Mybatis执行流程"></a>10.Mybatis执行流程</h3><p>1.首先会读取Mybatis的相关配置。SpringBoot下是yml文件里配置，而SSM下是mybatis-config.xml文件里配置。</p>
<p>2.然后会构造一个会话工厂SqlSessionFactory</p>
<p>3.再从会话工厂里创建SqlSession对象，这个对象包含了执行SQL语句的所有方法</p>
<p>4.在 SqlSession 对象内部，包含了一个 Executor 执行器。Executor 是 MyBatis 用于操作数据库的接口，它负责执行 SQL 语句并返回结果。</p>
<p>5.Executor 接口的执行方法会接收一个 <code>MappedStatement</code> 类型的参数。MappedStatement 封装了 SQL 映射信息，包括 SQL 语句、输入参数映射和输出结果映射等。</p>
<p>6.执行sql语句时，会把输入参数映射到sql语句里。</p>
<p>7.执行完毕返回时，会将输出结果转化成java对象。</p>
<p><img src="/../images/image-20250421230608971.png" alt="image-20250421230608971"></p>
<h3 id="11-Mybatis的延迟加载"><a href="#11-Mybatis的延迟加载" class="headerlink" title="11.Mybatis的延迟加载"></a>11.Mybatis的延迟加载</h3><h4 id="（1）什么是延迟加载"><a href="#（1）什么是延迟加载" class="headerlink" title="（1）什么是延迟加载"></a>（1）什么是延迟加载</h4><p>简单来说就是需要用到这个数据才进行加载，不需要用到这个数据时不会加载。</p>
<p>就是Mybatis在进行<strong>一对一或一对多关联查询</strong>对象(比例用户对象除了用户信息，还包含了订单列表，所以需要集合映射查询订单表)时，不会立马执行集合映射那部分的sql语句，只有当使用到这个对象的集合时才会动态的去查询这个集合并赋值给当前对象。</p>
<p>默认情况下，mybatis是关闭延迟加载的。</p>
<p><img src="/../images/image-20250421232949235.png" alt="image-20250421232949235"></p>
<h4 id="（2）延迟对象原理"><a href="#（2）延迟对象原理" class="headerlink" title="（2）延迟对象原理"></a>（2）延迟对象原理</h4><p>就是使用<strong>CGLIB</strong>实现的<strong>动态代理</strong>对象。</p>
<p>以用户这个实体类获取订单列表为例</p>
<p>当调用目标方法user.getOrderList()时，会进入拦截器的invoke方法，如果发现订单列表是null值，则会进行执行sql查询order列表。然后将查询到的order列表调用user.setOrderList()方法将结果传给订单列表。之后结束方法调用。返回订单列表。</p>
<p><img src="/../images/image-20250421233546471.png" alt="image-20250421233546471"></p>
<h3 id="12-Mybatis的一级、二级缓存"><a href="#12-Mybatis的一级、二级缓存" class="headerlink" title="12.Mybatis的一级、二级缓存"></a>12.Mybatis的一级、二级缓存</h3><ul>
<li><strong>一级缓存</strong>：一级缓存是基于 <code>SqlSession</code> 的，当一个 <code>SqlSession</code> 查询了某个数据后，会将其存储在一级缓存中。在同一个 <code>SqlSession</code> 中，如果再次查询相同的数据，会直接从一级缓存中获取，而不会再次查询数据库。当会话关闭或提交后，一级缓存数据会转移到二级缓存。</li>
<li><strong>二级缓存</strong>：二级缓存是跨多个 <code>SqlSession</code> 的，它存储在 <code>Mapper</code> 的级别(就是Mapper这个类下的所有方法都适用)。其下的 <code>SqlSession</code> 在查询相同的数据时，可以直接从二级缓存中获取，而不需要再次查询数据库。默认情况下，二级缓存是禁用的，需要在配置文件里手动开启</li>
<li><strong>数据更新机制</strong>：当数据在某一作用域（一级缓存session&#x2F;二级缓存mapper）发生增删改操作时，默认该作用域下的所有缓存都会被清空。</li>
</ul>
<h2 id="二、java集合相关"><a href="#二、java集合相关" class="headerlink" title="二、java集合相关"></a>二、java集合相关</h2><h3 id="1-为什么数组索引从0开始呢？假如从1开始不行吗"><a href="#1-为什么数组索引从0开始呢？假如从1开始不行吗" class="headerlink" title="1.为什么数组索引从0开始呢？假如从1开始不行吗"></a>1.为什么数组索引从0开始呢？假如从1开始不行吗</h3><p>这主要是跟数组的寻址公式相关。数组在取指定索引的元素时，会使用<strong>首地址+索引值*数组中的元素类型大小</strong>。如果是从1开始，公式就多了一个索引值减1的操作，对于CPU来说相当于多了一次指令，当遍历量大时，性能就会不高。</p>
<h3 id="2-操作数组的时间复杂度"><a href="#2-操作数组的时间复杂度" class="headerlink" title="2.操作数组的时间复杂度"></a>2.操作数组的时间复杂度</h3><p>根据索引查找是O(1)。</p>
<p>查找未排序的数组中的某一元素是O(n)。查找排序后的数组时，利于二分查找的时间复杂度为O(logn)。</p>
<p>添加和删除操作时，时间复杂度为O(n)。</p>
<h3 id="3-ArrayList底层实现原理是什么"><a href="#3-ArrayList底层实现原理是什么" class="headerlink" title="3.ArrayList底层实现原理是什么"></a>3.ArrayList底层实现原理是什么</h3><p>ArrayList底层是基于动态数组实现的。</p>
<p>初始容量是0，当第一次添加数据时才会初始化容量为10。在添加数据时会先确保当前数组已使用长度小于数组容量。如果等于容量大小就会对数组进行扩容。</p>
<p>数组扩容后是大约是原来容量的1.5倍，就是原数大小加上右移一位后的大小。此外，每次扩容都会拷贝数组。</p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p><code>ArrayList list = new Arraylist(10)</code>中的list扩容几次</p>
<p>答：0次，因为源码里这个传入容量的构造方法实际就是按传入的数值大小直接创建存储数据的数组。根本没有涉及扩容。</p>
<p><img src="/../images/image-20250423001656778.png" alt="image-20250423001656778"></p>
<h3 id="4-如何实现数组和List之间的转换"><a href="#4-如何实现数组和List之间的转换" class="headerlink" title="4.如何实现数组和List之间的转换"></a>4.如何实现数组和List之间的转换</h3><p>数组转List使用<code>Arrays.asList()</code>方法。</p>
<p>List转数组使用List的<code>toArray(new数组对象)</code>方法例如<code>String[] array = list.toArray(new String[list.size()]);</code></p>
<p>追问：</p>
<p>1.用Arrays.asList转List后，如果修改了数组内容，list会受影响吗</p>
<p>答：会。因为Arrays.asList方法底层就是把数组传给内部类ArrayList的构造函数，这个构造函数会直接把传入的数组做为自己的底层数组，所以List和数组最终指向的都是同一个内存地址。</p>
<p><img src="/../images/image-20250518020436754.png" alt="image-20250518020436754"></p>
<p>2.List用toArray转数组后，如果修改了List内容，数组会受影响吗</p>
<p>答：不会。因为toArray方法实际上是拷贝了List中的数组，所以新数组和List没有关系。</p>
<p><img src="/../images/image-20250518020551908.png" alt="image-20250518020551908"></p>
<h3 id="5-链表相关"><a href="#5-链表相关" class="headerlink" title="5.链表相关"></a>5.链表相关</h3><p><img src="/../images/image-20250423005036389.png" alt="image-20250423005036389"></p>
<h3 id="6-ArrayList和LinkedList的区别是什么"><a href="#6-ArrayList和LinkedList的区别是什么" class="headerlink" title="6.ArrayList和LinkedList的区别是什么"></a>6.ArrayList和LinkedList的区别是什么</h3><p>从四方面回答：</p>
<p>1.底层数据结构：</p>
<p>ArrayList是动态数组，LinkedList是双向链表。</p>
<p>2.效率</p>
<p>ArrayList访问随机元素的时间复杂度是O(1),而LinkedList是O(n).</p>
<p>A添加和删除数据的时间复杂度是O(n),而LinkedList是O(1).</p>
<p>3.空间</p>
<p>ArrayList底层是数组，数据存储占用的是连续的内存空间，内存更省。</p>
<p>而LinkedList的数据存储占用的是不连续的内存空间，而且除了存储数据还需要存储前后指针，内存开销更大。</p>
<p>4.线程是否安全</p>
<p>两个都不是线程安全的。</p>
<p>要保证线程安全的话可以在方法内做为局部变量使用，直接避免线程不安全问题产生。</p>
<p>或者使用Collections的synchronizedList()方法创列表。</p>
<p><img src="/../images/image-20250423005248216.png" alt="image-20250423005248216"></p>
<p><img src="/../images/image-20250423005339337.png" alt="image-20250423005339337"></p>
<h3 id="7-HashMap底层原理"><a href="#7-HashMap底层原理" class="headerlink" title="7.HashMap底层原理"></a>7.HashMap底层原理</h3><p>HashMap的底层数据结构是数组+链表+红黑树（jdk1.8及以后）。</p>
<p>当我们向HashMap put元素时，会利用key的hashCode重新计算hash值,将hash值和(数组容量-1)进行与运算计算出元素在数组中的下标。</p>
<p>如果出现hash冲突。则会判断key是否相同，key相同则覆盖原值。不同，则会将key-value放入到链表或红黑树中。</p>
<p>至于链表和红黑树之间是有转换规则的。</p>
<p>HashMap一开始创建时是数组+链表的结构，当链表长度超过8以及map容量大小大于64时，会将这个链表转化为红黑树。而如果链表长度超过8但map容量小于64时，会对数组进行扩容而不是转化为红黑树。</p>
<h3 id="8-讲讲HashMap的扩容机制"><a href="#8-讲讲HashMap的扩容机制" class="headerlink" title="8.讲讲HashMap的扩容机制"></a>8.讲讲HashMap的扩容机制</h3><p>对于扩容，HashMap中是设有<strong>扩容阈值</strong>的，其大小是根据<strong>当前数组长度*负载因子</strong>得到的，而负载因子默认大小是0.75。</p>
<p>在添加元素时候，会调用resize方法进行扩容。第一次添加数据时会初始化数组长度为16，之后每次扩容的大小都是原来的2倍大小，扩容时机是根据扩容阈值判断的。</p>
<p>扩容时，会创建一个新数组，把老数组中的数据拷贝到新数组中。在拷贝过程中。要注意三点</p>
<p>一、对于没有hash冲突(判断next是否为null)的<strong>节点</strong>，会直接使用<code>e.hash&amp;(newCap - 1)</code>计算新数组的索引位置。</p>
<p>二、如果是红黑树，则会走红黑树的添加方式。</p>
<p>三、如果是链表，则会对遍历链表，通过判断链表元素节点的hash值和oldCap进行与运算后的结果是否为0，若为0则停留到原始位置，否则移动到原始位置+旧数组大小的这个位置上。</p>
<p>注意：HashMap是懒加载。在创建对象时不会初始化数组，在无参构造函数中会加载默认的负载因子(0.75)。对于索引变更，根据第10点可知，<strong>数组扩容的情况下，索引要么不变，要么加上旧数组大小</strong>。</p>
<h3 id="9-hashMap的寻址算法"><a href="#9-hashMap的寻址算法" class="headerlink" title="9.hashMap的寻址算法"></a>9.hashMap的寻址算法</h3><p>hashMap首先会获取key的hashCode,然后对这个hashCode右移16位后进行异或运算得到hash值。这个右移异或是扰动算法，可以让hash分布更加均匀。</p>
<p>根据hash值跟（数组的容量大小-1）进行与运算后得到索引。</p>
<h3 id="10-为什么HashMap的数组长度一定是2的次幂？"><a href="#10-为什么HashMap的数组长度一定是2的次幂？" class="headerlink" title="10.为什么HashMap的数组长度一定是2的次幂？"></a>10.为什么HashMap的数组长度一定是2的次幂？</h3><p>因为2的次幂-1的与运算可以代替取余运算，计算索引的效率更高。</p>
<p>此外，扩容时计算索引的效率也更高，不是通过<code>hash &amp; (oldCap - 1)</code>获取新索引，而是通过<code>hash &amp; oldCap == 0</code> 判断元素是否留在原来的位置，否则新位置&#x3D;旧位置+oldCap。</p>
<p>oldCap是旧数组大小。</p>
<p>至于为什么会用hash&amp;oldCap &#x3D;&#x3D; 0来判断是基于公式推导得到的</p>
<p>对旧索引：index &#x3D; hash &amp; (oldCap - 1)</p>
<p>对新索引：newIndex &#x3D; hash &amp; (newCap - 1) &#x3D; hash &amp; (oldCap + oldCap  - 1) &#x3D; hash &amp; (oldCap -1) + hash &amp; oldCap &#x3D; index + hash  &amp; oldCap</p>
<p>从公式我们可以看到，新索引的增加数位就是由 hash &amp; oldCap 决定的。</p>
<p>而oldCap是2的次幂，导致oldCap转换为二进制数时只有一位是1，因此hash &amp; oldCap的与运算结果只可能是0或者oldCap;</p>
<p>故而当hashCode &amp; oldCap &#x3D;&#x3D; 0时，索引不变。不等于0时，索引+oldCap。</p>
<h2 id="三、并发编程相关"><a href="#三、并发编程相关" class="headerlink" title="三、并发编程相关"></a>三、并发编程相关</h2><h3 id="1-线程和进程的区别"><a href="#1-线程和进程的区别" class="headerlink" title="1.线程和进程的区别"></a>1.线程和进程的区别</h3><p>进程可以说是正在运行的程序实例，每个进程都有自己<strong>独立的内存空间</strong>，不同进程之间是相互隔离的。而<strong>线程是进程里面的执行单元</strong>，一个进程里可以有多个线程，这些线程<strong>共享进程的内存空间</strong>。</p>
<p>另外，<strong>线程比进程更轻量</strong>，上下文切换成本也低很多。因为切换线程时，系统只需要保存和恢复线程的上下文信息，而切换进程则需要处理更多资源和状态信息，开销更大。</p>
<h3 id="2-并行和并发有什么区别"><a href="#2-并行和并发有什么区别" class="headerlink" title="2.并行和并发有什么区别"></a>2.并行和并发有什么区别</h3><p><strong>并发</strong>指的是<strong>多个任务交替执行</strong>，在宏观上看是同时运行的，而微观上看其实就是快速切换，比如单核CPU处理多个任务。</p>
<p>而<strong>并行</strong>指的是<strong>多个任务同时执行</strong>，比如说多核CPU同时运行多个程序。</p>
<h3 id="3-创建线程的方式有哪些"><a href="#3-创建线程的方式有哪些" class="headerlink" title="3.创建线程的方式有哪些"></a>3.创建线程的方式有哪些</h3><p>有四种方式</p>
<p><strong>继承Thread类</strong>、<strong>实现Runnable接口</strong>、<strong>实现Callable接口</strong>和<strong>使用线程池创建线程</strong>。</p>
<p>关于如何使用Callable接口</p>
<p>主要就是重写call方法，然后将该类做为<code>FutureTask</code>构造函数的参数。在把<code>FutureTask</code>做为Thread构造函数的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start(); <span class="comment">//future只能供一个线程，所有这个不生效</span></span><br><span class="line">        System.out.println(future.get()); <span class="comment">//获取执行完的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>（1）一个<code>FutureTask</code>类只能被一个线程获取，再开其他线程不生效。这是因为<code>FutureTask</code> 是一个线程安全的类，它内部会管理任务的执行状态。如果尝试用多个线程启动同一个 <code>FutureTask</code>，只有第一个线程会真正执行任务，其他线程会发现任务已经被启动，从而不会重复执行。</p>
<p>（2）<code>FutureTask</code>实际上是<code>Runnable</code>的实现类。</p>
<p><img src="/../images/image-20250425200843184.png" alt="image-20250425200843184"></p>
<h4 id="追问1-Runnable和Callable有什么区别"><a href="#追问1-Runnable和Callable有什么区别" class="headerlink" title="追问1.Runnable和Callable有什么区别"></a>追问1.Runnable和Callable有什么区别</h4><p>Runnbale接口的run方法没有没有返回值，且不允许抛出异常。</p>
<p>Callable接口有返回值，需要用FutureTask获取返回值，且允许抛出异常。</p>
<h4 id="追问2-run-和start-有什么区别"><a href="#追问2-run-和start-有什么区别" class="headerlink" title="追问2.run()和start()有什么区别"></a>追问2.run()和start()有什么区别</h4><p><strong>start()是用来启动线程</strong>的，并在新线程中调用run方法。一个线程的start方法只能被调用一次（尝试多次会抛出异常）。</p>
<p>如果直接调用run方法，<strong>run方法只是会做为一个普通方法被调用</strong>，仍旧在当前线程执行，并不会启动新线程。</p>
<h3 id="4-线程包含哪些状态"><a href="#4-线程包含哪些状态" class="headerlink" title="4.线程包含哪些状态"></a>4.线程包含哪些状态</h3><p>有六种状态。新建(New)、可运行(Runnable)、阻塞(Blocked)、等待(waiting)、时间等待(Timed_waiting)、终止(Terminated)。</p>
<h3 id="5-线程状态之间是如何变化的"><a href="#5-线程状态之间是如何变化的" class="headerlink" title="5.线程状态之间是如何变化的"></a>5.线程状态之间是如何变化的</h3><p>创建线程对象是<strong>新建状态</strong>。</p>
<p>调用start()方法后转变为<strong>可执行状态</strong>。</p>
<p>线程获取到CPU执行权时会开始执行，执行结束是<strong>终止态</strong>。</p>
<p>在执行过程中，可能会切换为其他状态。</p>
<ul>
<li>若要当前线程要获取锁，而<strong>锁被其他线程占有</strong>，则会进入<strong>阻塞态</strong>。</li>
<li>若当前线程调用了<strong>wait()<strong>方法进入</strong>等待状态</strong>，则需要其他线程调用notify()唤醒为可执行态。</li>
<li>若当前线程调用了<strong>sleep(500)<strong>方法，则会进入</strong>计时等待状态</strong>，到时间后切换可执行态。</li>
</ul>
<p><img src="/../images/image-20250425213446655.png" alt="image-20250425213446655"></p>
<p>注意：wait方法会让当前线程释放锁，进入等待唤醒状态。而notify方法会随机唤醒在等待中的线程。notifyAll方法会唤醒所有在等待中的线程。notify和notifyAll不会释放锁，只是唤醒线程让它们可以重新获取锁。</p>
<h3 id="6-新建T1、T2、T3三个线程，如何保证按顺序执行"><a href="#6-新建T1、T2、T3三个线程，如何保证按顺序执行" class="headerlink" title="6.新建T1、T2、T3三个线程，如何保证按顺序执行"></a>6.新建T1、T2、T3三个线程，如何保证按顺序执行</h3><p>可以使用线程的join()方法解决。比如说要保证执行顺序为T1、T2、T3,那么可以在T2线程的run方法开头调用T1线程的join方法，T3线程的run方法开头调用T2线程的join方法。</p>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程3执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在上面的代码中，t1的方法参数的匿名内部类不能调用t2和t3的join方法，因为t2、t3的变量的声明在t1之后。此外，在匿名内部类在调用外部类的局部变量时，变量必须是final或实际上不可变(指的是创建后并没有发生改变)，否则会编译错误。</p>
<h3 id="7-wait和sleep方法的不同"><a href="#7-wait和sleep方法的不同" class="headerlink" title="7.wait和sleep方法的不同"></a>7.wait和sleep方法的不同</h3><p><strong>共同点</strong>:都是让当前线程暂时放弃对CPU的使用权。</p>
<p>1.<strong>方法归属不同</strong></p>
<ul>
<li>sleep是Thread的静态方法</li>
<li>而wait是Object的成员方法，每个对象都有</li>
</ul>
<p>2.<strong>醒来的时机不同</strong></p>
<ul>
<li>执行sleep(long)和wait(long)的线程都会等待相应的毫秒后醒来。</li>
<li>wait()和wait(long)可以被notify唤醒, wait()如果不唤醒就会一直等待下去</li>
</ul>
<p>3.<strong>锁的特性不同</strong></p>
<ul>
<li>wait()方法必须在synchronized代码块中调用，且必须获取wait对象的锁，而sleep无此限制。</li>
<li>wait()方法执行后会<strong>释放对象锁</strong>，允许其他线程获取该对象锁。而sleep如果在synchronized代码块中执行，则<strong>不会释放对象锁</strong>。</li>
</ul>
<h3 id="8-如何停止一个正在运行的线程"><a href="#8-如何停止一个正在运行的线程" class="headerlink" title="8.如何停止一个正在运行的线程"></a>8.如何停止一个正在运行的线程</h3><p>有三种方法</p>
<p>1.使用<strong>退出标志</strong>，使<strong>线程正常退出</strong>，也就是当run方法执行完成后线程就会终止。</p>
<p>2.使用<strong>stop</strong>方法强行终止（方法已作废）</p>
<p>3.使用<strong>interrupt</strong>方法中断线程</p>
<h3 id="9-synchronized关键字底层原理"><a href="#9-synchronized关键字底层原理" class="headerlink" title="9.synchronized关键字底层原理"></a>9.synchronized关键字底层原理</h3><p>synchronized底层是由monitor实现的，就是锁监视器。monitor是jvm级别的对象。<strong>使用synchronized获取线程的某个对象的锁时，实际上是获取对象关联的monitor。</strong></p>
<p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p>
<p>其中的<strong>owner关联的是当前持有锁的线程</strong>，<strong>entrylist关联的是处于阻塞状态的线程</strong>，<strong>waitset关联的是处于waiting状态的线程</strong>。</p>
<p><img src="/../images/image-20250428194935115.png" alt="image-20250428194935115"></p>
<p>注意：在java中，每个对象都有一个与之关联的monitor。monitor是一种同步机制，用于确保同一时刻只有一个线程可以执行某个对象相关的同步代码。</p>
<h3 id="10-JMM-java内存模型"><a href="#10-JMM-java内存模型" class="headerlink" title="10.JMM(java内存模型)"></a>10.JMM(java内存模型)</h3><p>JMM是java内存模型，它<strong>定义了共享内存中多线程程序读写操作的行为规范</strong>，通过这些规则来规范对内存的读写操作，从而保证指令的正确性。</p>
<p>JMM<strong>把内存分为了两块</strong>，一块是线程私有的<strong>工作内存</strong>，一块是所有线程的共享的<strong>主内存</strong>。</p>
<p>线程跟线程之间是相互隔离的，线程跟线程之间的交互需要通过主内存。</p>
<p><img src="/../images/image-20250428195127443.png" alt="image-20250428195127443"></p>
<h3 id="11-CAS"><a href="#11-CAS" class="headerlink" title="11.CAS"></a>11.CAS</h3><p>CAS全称是<strong>Compare And Swap</strong>,它体现的其实就是一种<strong>乐观锁的思想</strong>。实现原理就是<strong>用一个预期值与要更新的值进行比较</strong>，两值相等的情况下才能成功更新。其底层调用的是Unsafe类中的方法，是由操作系统提供的。</p>
<h3 id="12-乐观锁和悲观锁的区别"><a href="#12-乐观锁和悲观锁的区别" class="headerlink" title="12.乐观锁和悲观锁的区别"></a>12.乐观锁和悲观锁的区别</h3><p>乐观锁无需加锁也无需等待，只需要在<strong>提交修改时去验证对应的资源是否被其他线程修改了</strong>即可，可以使用版本号机制或CAS算法。</p>
<p>而悲观锁则是在每次获取到资源时上锁。当有一线程获取到锁时，其他线程需要阻塞等待锁。</p>
<p>在高并发场景下，乐观锁相比悲观锁不存在竞争造成的线程阻塞问题。但如果冲突发生的较为频繁的话，会出现<strong>频繁的失败和重试</strong>，很浪费CPU，因为CPU要花费时间片去不断重试。</p>
<h3 id="12-volatile关键字"><a href="#12-volatile关键字" class="headerlink" title="12.volatile关键字"></a>12.volatile关键字</h3><p>volatile可以保证<strong>数据的可见性</strong>和<strong>禁止指令重排序</strong></p>
<p>数据的可见性：</p>
<p>加了volatile关键字的变量在获取或者修改时会<strong>直接对主内存中进行操作</strong>，而不会经过线程私有的工作内存。能够<strong>防止编译优化产生的问题</strong>。</p>
<p>禁止指令重排序：</p>
<p>用valatile修饰的变量会在读和写时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</p>
<p>比如双重校验锁实现对象单例的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行的：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空(因为已经指向内存地址了)，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>
<h3 id="13-什么是AQS"><a href="#13-什么是AQS" class="headerlink" title="13.什么是AQS"></a>13.什么是AQS</h3><p><img src="/../images/image-20250428214445414.png" alt="image-20250428214445414"></p>
<p>AQS（抽象队列同步器） 是一个<strong>抽象类</strong>，它维护了<strong>一个共享变量 state</strong> 和<strong>一个线程等待队列</strong>，为 ReentrantLock 等类提供底层支持。</p>
<p>AQS 的思想是，如果被请求的共享资源处于空闲状态，则当前线程成功获取锁；否则，将当前线程加入到等待队列中，当其他线程释放锁时，从等待队列中挑选一个线程，把锁分配给它。</p>
<h4 id="AQS底层源码"><a href="#AQS底层源码" class="headerlink" title="AQS底层源码"></a>AQS底层源码</h4><p>源码阅读指的是<strong>AbstractQueuedSynchronizer</strong>这个抽象类。</p>
<p>第一，状态变量state由volatile修饰，用于保证<strong>多线程之间变量的可见性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>第二，同步队列由内部定义的<strong>Node类</strong>实现，每个 Node 包含了<strong>等待状态、前后节点、线程的引用</strong>等，是一个先进先出的双向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;       <span class="comment">// 前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;       <span class="comment">// 后继节点</span></span><br><span class="line">        Thread waiter;            <span class="comment">// 当前节点所关联的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> status;      <span class="comment">// 等待状态</span></span><br><span class="line">        <span class="comment">//剩下方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外</p>
<p>AQS 支持两种同步方式，具体看state的赋值情况：</p>
<ul>
<li><strong>独占模式</strong>下：每次只能有一个线程持有锁，例如 ReentrantLock。</li>
<li><strong>共享模式</strong>下：多个线程可以同时获取锁，例如 Semaphore （信号量）和 CountDownLatch（计数器）。</li>
</ul>
<p>AQS 使用一个 CLH 队列来维护等待线程，CLH 是三个作者 Craig、Landin 和 Hagersten 的首字母缩写，是一种基于链表的自旋锁。</p>
<p>在 CLH 中，当一个线程尝试获取锁失败后，会被添加到队列的尾部并自旋，等待前一个节点的线程释放锁。</p>
<p>CLH 的优点是，假设有 100 个线程在等待锁，锁释放之后，只会通知队列中的第一个线程去竞争锁。避免同时唤醒大量线程，浪费 CPU 资源。</p>
<h4 id="CountDownLatch源码"><a href="#CountDownLatch源码" class="headerlink" title="CountDownLatch源码"></a>CountDownLatch源码</h4><p>CountDownLatch内部维护了一个继承AQS的静态内部类Sync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">     Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">         setState(count);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getState();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//计数器减一操作</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">         <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">             <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">//调用父类AQS的CAS方法，保证原子性</span></span><br><span class="line">                 <span class="keyword">return</span> nextc == <span class="number">0</span>; </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS的CAS方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetInt(<span class="built_in">this</span>, STATE, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建CountDownLatch对象时，其实就是把计数值传递给AQS的state变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">100</span>);</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的底层实现</span></span><br><span class="line"><span class="comment">//1.对象创建，实际就是创建AQS子类Sync对象并赋值给成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);<span class="comment">//看上面Sync的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.减一操作，Sync内存重写了AQS的releaseShared方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-ReentrantLock实现原理"><a href="#14-ReentrantLock实现原理" class="headerlink" title="14.ReentrantLock实现原理"></a>14.ReentrantLock实现原理</h3><p>ReentrantLock翻译过来是<strong>可重入锁</strong>，相对应synchronized，它具备以下特点：</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置公平锁</li>
<li>支持多个条件变量</li>
<li>与synchronized一样，都支持重入</li>
</ul>
<p>ReentrantLock主要是利用<strong>CAS和AQS队列</strong>来实现的。</p>
<p>支持公平锁和非公平锁。在构造函数中，无参默认非公平锁，也可以传参设置为公平锁。</p>
<p><img src="/../images/image-20250428214321303.png" alt="image-20250428214321303"></p>
<p><img src="/../images/image-20250428214318357.png" alt="image-20250428214318357"></p>
<h3 id="15-ConcurrentHashMap"><a href="#15-ConcurrentHashMap" class="headerlink" title="15.ConcurrentHashMap"></a>15.ConcurrentHashMap</h3><p>jdk1.7底层采用分段数组+链表实现</p>
<p>采用的是Segment分段锁，底层使用的是ReentrantLock。</p>
<p>而jdk1.8及以上，ConcurrentHashMap的数据结构和HashMap一样，都是数组+链表&#x2F;红黑树，只是在添加节点时用到了<strong>CAS和Synchronized</strong>来保证<strong>线程的安全</strong>。</p>
<p>在对<strong>数组的空节点</strong>进行添加时，会使用<strong>CAS算法</strong>。(解决两个数据同时添加到数组的同一个位置时的问题)</p>
<p>而在对<strong>链表或者红黑树</strong>进行节点添加时，会对通过<strong>Synchronized</strong>，对<strong>首节点</strong>进行锁定。</p>
<p>以下是源码截图</p>
<p>给空节点添加时</p>
<p><img src="/../images/image-20250428215707901.png" alt="image-20250428215707901"></p>
<p><img src="/../images/image-20250428220319085.png" alt="image-20250428220319085"></p>
<p><img src="/../images/image-20250428220736895.png" alt="image-20250428220736895"></p>
<p>目标元素的实际内存地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tabAddress + ((long)i &lt;&lt; ASHIFT) + ABASE</span><br></pre></td></tr></table></figure>

<p>首节点锁定</p>
<p><img src="/../images/image-20250428222341524.png" alt="image-20250428222341524"></p>
<p>如果首节点被其他线程替换了，就会迭代循环（无限，直至遇到break）。</p>
<p><img src="/../images/image-20250428222731113.png" alt="image-20250428222731113"></p>
<h3 id="16-ThreadLocal"><a href="#16-ThreadLocal" class="headerlink" title="16.ThreadLocal"></a>16.ThreadLocal</h3><p><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 是一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离。</p>
<p>在 Web 应用中，可以使用 ThreadLocal 存储用户会话信息，这样每个线程在处理用户请求时都能方便地访问当前用户的会话信息。</p>
<h4 id="ThreadLocal实现的底层原理"><a href="#ThreadLocal实现的底层原理" class="headerlink" title="ThreadLocal实现的底层原理"></a>ThreadLocal实现的底层原理</h4><p>首先，ThreadLocal 自身并不保存任何线程的数据，ThreadLocal 只是一个操作接口，真正的线程本地值存储在当前调用的线程的 ThreadLocalMap 中。</p>
<p>当我们创建一个 ThreadLocal 对象并调用 set 方法时，其实是在当前线程中初始化了一个 ThreadLocalMap。</p>
<p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类，它内部维护了一个 Entry 数组，<strong>key 是 ThreadLocal 对象</strong>，<strong>value 是我们所传入的变量</strong>，所以每个ThreadLocal虽然只能存一个value值，但我们可以创建多个ThreadLocal对象用于保存各种信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalMap的构造方法，firstKey是ThreadLocal实例，firstValue是传入的值</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY]; <span class="comment">//初始化entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>); <span class="comment">//计算索引位置</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue); <span class="comment">//存放具体Entry</span></span><br><span class="line">    size = <span class="number">1</span>; <span class="comment">//已用的数组节点大小</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY); <span class="comment">//设置扩容阈值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置扩容阈值为容量大小的2/3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以ThreadLocal为key，进行赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table; <span class="comment">//获取entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//若hash冲突，则会</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; </span><br><span class="line">         e != <span class="literal">null</span>;<span class="comment">//为null，则跳出遍历</span></span><br><span class="line">         e = tab[i = nextIndex(i, len)]  <span class="comment">//若hash冲突，线性探测下一个索引位置) &#123;</span></span><br><span class="line">        <span class="comment">//判断是否是同一个ThreadLocal实例.若是，则直接进行值替换</span></span><br><span class="line">        <span class="keyword">if</span> (e.refersTo(key)) &#123; </span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//表示这个 Entry 的 Key 已经被 GC 回收了，现在是个无效 Entry。就是ThreadLocal实例已经不存在了。那么就可以替换掉这个entry了</span></span><br><span class="line">        <span class="keyword">if</span> (e.refersTo(<span class="literal">null</span>)) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//若哈希冲突，且无遇到无效Entry，则创建新Entry并赋值</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">//进行无效entry的清理</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();<span class="comment">// 这是扩容， 即清理没效果，并且已经达到了扩容阈值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性探测索引位置，因为扩容阈值为2/3大小，所以不会有无限循环探测的问题</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在 ThreadLocalMap 中，Key 是 ThreadLocal 实例本身。所以如果你每次调用方法都 new 一个新的 ThreadLocal()，即使值一样，也会被认为是不同的 Key。导致同一个线程多次 set()，其实是存了多个 Entry，浪费内存且无法复用。</p>
<p>总之，将 ThreadLocal 设置为 static final 是一种最佳实践，它确保 <strong>Key 唯一</strong>、<strong>可重用</strong>，<strong>避免不必要的对象创建</strong>，并减少因 Key 不一致或弱引用导致的潜在内存泄漏风险。</p>
<h2 id="四、Mysql"><a href="#四、Mysql" class="headerlink" title="四、Mysql"></a>四、Mysql</h2><h3 id="1-如何定位慢查询"><a href="#1-如何定位慢查询" class="headerlink" title="1.如何定位慢查询"></a>1.如何定位慢查询</h3><p>Mysql本身提供了慢查询日志功能。可以在系统的配置文件中开启慢查询日志，设置SQL执行超过多长时间就记录到日志文件中。</p>
<h3 id="2-那这个SQL语句执行很慢，如何分析呢？"><a href="#2-那这个SQL语句执行很慢，如何分析呢？" class="headerlink" title="2.那这个SQL语句执行很慢，如何分析呢？"></a>2.那这个SQL语句执行很慢，如何分析呢？</h3><p>如果一条SQL执行很慢，我们通常<strong>会使用MySQL的<code>EXPLAIN</code>命令来分析这条SQL的执行情况</strong>。通过<code>key</code>和<code>key_len</code>可以检查是否命中了索引，如果已经添加了索引，也可以判断索引是否有效。通过<code>type</code>字段可以查看SQL是否有优化空间，比如是否存在全索引扫描或全表扫描。通过<code>extra</code>建议可以判断是否出现回表情况，如果出现，可以尝试添加索引或修改返回字段来优化。</p>
<h3 id="3-索引的底层数据结构了解过吗？"><a href="#3-索引的底层数据结构了解过吗？" class="headerlink" title="3. 索引的底层数据结构了解过吗？"></a>3. 索引的底层数据结构了解过吗？</h3><p><strong>MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构</strong>。选择B+树的原因包括：节点可以有更多子节点，路径更短；磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；B+树适合范围查询和扫描，因为叶子节点之间形成了一个双向链表。</p>
<p><img src="/../images/image-20250513184525036.png" alt="image-20250513184525036"></p>
<h3 id="4-B树和B-树的区别是什么呢？"><a href="#4-B树和B-树的区别是什么呢？" class="headerlink" title="4.B树和B+树的区别是什么呢？"></a>4.B树和B+树的区别是什么呢？</h3><ol>
<li>B树的非叶子节点和叶子节点都存放数据，而B+树的所有数据只出现在叶子节点，这使得B+树在查询时效率更稳定。</li>
<li>B+树在进行范围查询时效率更高，因为所有数据都在叶子节点，并且叶子节点之间形成了双向链表。</li>
</ol>
<h3 id="5-什么是聚簇索引和非聚簇索引"><a href="#5-什么是聚簇索引和非聚簇索引" class="headerlink" title="5.什么是聚簇索引和非聚簇索引"></a>5.什么是聚簇索引和非聚簇索引</h3><p><strong>聚簇索引是指数据与索引放在一起</strong>，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。</p>
<p><strong>非聚簇索引则是数据与索引分开存储</strong>，B+树的叶子节点保存的是主键值，可以有多个非聚簇索引，通常我们自定义的索引都是非聚簇索引。</p>
<h3 id="6-什么是回表查询"><a href="#6-什么是回表查询" class="headerlink" title="6.什么是回表查询"></a>6.什么是回表查询</h3><p><strong>回表查询是指通过二级索引找到对应的主键值</strong>，然后再通过主键值查询聚簇索引中对应的整行数据的过程。</p>
<p>注意二级索引和非聚簇索引的区别：</p>
<ul>
<li><p><strong>二级索引</strong>：是一种在数据库表中除了主索引（聚簇索引）之外的其他索引。它允许用户根据非主键列进行快速查找。二级索引的结构通常是一个独立的索引结构，它存储了索引列的值和指向数据行的指针。</p>
</li>
<li><p><strong>非聚簇索引</strong>：是一种索引类型，它不改变数据行的物理存储顺序。非聚簇索引的存储结构是一个独立的索引表，它存储了索引列的值和指向数据行的指针。数据行的存储顺序与非聚簇索引的顺序无关。</p>
</li>
<li><p>在实际应用中，非聚簇索引通常是二级索引的一种实现方式，但二级索引也可以是其他类型的索引，如哈希索引等。</p>
</li>
</ul>
<h3 id="7-什么是覆盖索引"><a href="#7-什么是覆盖索引" class="headerlink" title="7.什么是覆盖索引"></a>7.什么是覆盖索引</h3><p>覆盖索引指的是使用select查询数据时，<strong>所需的列全部能在索引中找到，避免了回表查询</strong>。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率。</p>
<h3 id="8-超大分页怎么处理"><a href="#8-超大分页怎么处理" class="headerlink" title="8.超大分页怎么处理"></a>8.超大分页怎么处理</h3><p>超大分页通常发生在数据量大的情况下，使用<code>LIMIT</code>分页查询且需要排序时效率较低。可以通过覆盖索引和子查询来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升。</p>
<p><img src="/../images/image-20250513185734032.png" alt="image-20250513185734032"></p>
<p>我的理解是，对于超大分页，如果直接对所有数据进行limit的话，需要扫描全表并排序，数据量不仅大还耗时。但如果我们先使用子查询的方式获取排序后的id临界值，因为只需要id值，所以是覆盖索引，效率可以提升。再把获取到的id值做为主查询的临界值，这样子主查询就可以避免对全表的扫描和排序。</p>
<p>例如：select * from tb_user limit 90000,10      这个语句会先遍历前90000行，再往后取10行，效率很低</p>
<h3 id="9-什么情况下，索引会失效"><a href="#9-什么情况下，索引会失效" class="headerlink" title="9.什么情况下，索引会失效"></a>9.什么情况下，索引会失效</h3><p>1.没有遵循最左匹配原则</p>
<p>2.使用了模糊查询且%在前面</p>
<p>3.在索引字段上进行了运算或者类型转换</p>
<p>4.使用了联合索引，但在中间使用了范围查询，导致右边的条件索引失效</p>
<h3 id="面渣八股文"><a href="#面渣八股文" class="headerlink" title="面渣八股文"></a>面渣八股文</h3><h3 id="1-为什么InnoDB要使用B-树做为索引？"><a href="#1-为什么InnoDB要使用B-树做为索引？" class="headerlink" title="1.为什么InnoDB要使用B+树做为索引？"></a>1.为什么InnoDB要使用B+树做为索引？</h3><p>因为 B+ 树是一种<strong>高度平衡的多路查找树</strong>，能<strong>有效降低磁盘的 IO 次数</strong>，并且<strong>支持有序遍历和范围查询</strong>。</p>
<p>再换一种回答：</p>
<ul>
<li>相比哈希表：B+ 树支持范围查询和排序</li>
<li>相比二叉树和红黑树：B+ 树<strong>更“矮胖”，层级更少</strong>，磁盘 IO 次数更少</li>
<li>相比 B 树：B+ 树的非叶子节点只存储键值，<strong>叶子节点存储数据并通过链表连接，支持范围查询</strong></li>
</ul>
<p><strong>tip:</strong></p>
<p>多路查找树是一种树形数据结构，每个节点可以有多个子节点。例如，一个三路查找树的每个节点最多有三个子节点。</p>
<p>高度平衡的树是指树的左右子树的高度差不超过一个固定值（通常是1）。</p>
<h3 id="2-事务的四大特性-ACID"><a href="#2-事务的四大特性-ACID" class="headerlink" title="2.事务的四大特性-ACID"></a>2.事务的四大特性-ACID</h3><p>分别是原子性、一致性、隔离性和持久性</p>
<p><img src="/../images/image-20250513192209329.png" alt="image-20250513192209329"></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性:"></a>原子性:</h4><p>原子性指的是事务中所有的操作，<strong>要么全部执行成功，要么全部失败</strong>。事务中只要任何一个操作失败了，就会<strong>回滚到事务开始之前</strong>的状态。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性:"></a>一致性:</h4><p>一致性确保数据的状态<strong>从一个一致状态转变为另一个一致状态</strong>。一致性与业务规则有关，比如银行转账，不论事务成功还是失败，转账双方的<strong>总金额应该是不变的</strong>。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性:"></a>隔离性:</h4><p>指的是多个并发事务之间相互隔离，即一个事务的执行<strong>不能被其他事务干扰</strong>。</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性:"></a>持久性:</h4><p><strong>一旦事务提交</strong>，则其所做的修改将<strong>永久保存</strong>到 MySQL 中。即使发生系统崩溃，修改的数据也不会丢失。</p>
<h3 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h3><p>MySQL中支持4种隔离级别，分别是读未提交、读已提交、可重复读和串行化。</p>
<p><img src="/../images/image-20250513193331803.png" alt="image-20250513193331803"></p>
<p>读未提交：会出现脏读、不可重复读、幻读</p>
<p>读已提交：会出现不可重复读、幻读</p>
<p>可重复读：会出现幻读</p>
<p>串行化：无</p>
<h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p>事务可以读取其他未提交事务修改的数据。也就是说，如果未提交的事务一旦回滚，读取到的数据就会变成了“脏数据”，通常不会使用。</p>
<h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p>读已提交避免了脏读，但可能会出现不可重复读，即同一事务内多次读取同一数据结果会不同，<strong>因为其他事务提交的修改，对当前事务是可见的</strong>。</p>
<h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>可重复读能确保同一事务内多次读取相同数据的结果一致，即使其他事务已提交修改。可重复读是MySQL的默认隔离级别。但不可避免幻读。</p>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>串行化是最高的隔离级别，通过<strong>强制事务串行执行</strong>来解决“幻读”问题。</p>
<p><img src="/../images/image-20250513193812078.png" alt="image-20250513193812078"></p>
<p>但会导致大量的锁竞争问题，实际应用中很少用。</p>
<h3 id="4-事务的隔离级别是如何实现的"><a href="#4-事务的隔离级别是如何实现的" class="headerlink" title="4.事务的隔离级别是如何实现的"></a>4.事务的隔离级别是如何实现的</h3><p>注意：针对MySQL的MVCC，事务的隔离级别的底层实现相较于传统的三级封锁协议有些区别。因为用到了ReadView。</p>
<p>下面写的是针对MVCC和传统的封锁协议写的，不要等价了。</p>
<p><strong>读未提交</strong>，写操作加行级排他锁（<code>X</code> 锁），防止其他事务同时修改同一行。但<strong>读操作不加锁</strong>，所以<strong>允许读取其他事务未提交的数据</strong>，也就导致了脏读的问题。</p>
<p>对应一级封锁协议。会在数据更新前添加行级排他锁，行级排他锁会阻止其他事务对数据再加排他锁或者共享锁，但由于一级封锁协议没有共享锁这个概念，导致其他事务读取数据时，排他锁并不会拦截。也就会导致脏读问题。</p>
<p><strong>读已提交</strong>，写操作会加行级排他锁，每次读操作时，都会生成一个新的ReadView，确保<strong>读取到的数据是最新已提交的</strong>，从而解决脏读的问题。但因为每次读都是最新已提交的数据，所以会出现不可重复读的问题。</p>
<p>对应二级封锁协议。在一级封锁协议上引入了共享锁，使得其他事务读取数据时需要先添加共享锁，而数据修改时会添加排他锁，导致获取锁必须在拥有排他锁的事务释放锁之后才可以读取数据，所以可以避免脏读问题。但二级封锁协议的共享锁是在查询时添加共享锁，查询结束就立刻释放共享锁。所以并不能解决不可重复读问题。</p>
<p><strong>可重复读</strong>，可重复读<strong>只在第一次读操作时生成 ReadView</strong>，后续读操作都会使用这个 ReadView，从而避免不可重复读的问题。另外，对于当前读操作，可重复读会通过临键锁来锁住当前行和前间隙，防止其他事务在这个范围内插入数据，从而避免幻读的问题。</p>
<p>对应三级封锁协议。可重复读的共享锁的释放必须在事务结束之后，所以可以解决不可重复读的问题。但由于排他锁和共享锁只能针对已经存在的数据加锁。对于不存在的数据，其他事务可以进行增加操作，所以可能会有幻读问题存在。</p>
<p><strong>串行化</strong>，事务在读操作时，会先加<strong>表级共享锁</strong>；在写操作时，会先加<strong>表级排他锁</strong>。所以可以避免幻读问题的发生。</p>
<p>我的理解是串行化超过了三级封锁协议，主要原因还是标准的三级封锁协议无法对不存在的数据加锁，不可避免幻读的产生。</p>
<h3 id="5-MVCC机制"><a href="#5-MVCC机制" class="headerlink" title="5.MVCC机制"></a>5.MVCC机制</h3><p>MVCC指的是多并发版本控制，每次修改数据时，都会生成一个新的版本，而不是直接在原有的数据上进行修改。并且每个事务只能看到在它开始之前已经提交的数据版本。</p>
<p>这样的话，读操作和写操作之间就不会相互阻塞，从而避免了频繁加锁带来的性能损耗。</p>
<p>底层实现主要依赖于Undo Log和Read View。</p>
<p>每次修改数据前，会将当前的记录拷贝到Undo Log中，其中的每条记录都包含三个隐藏列，DB_TRX_ID用于记录当前修改该行的事务ID，DB_ROLL_PTR用来指向Undo Log中的前一个版本，DB_ROW_ID用来唯一标识改行数据（仅无主键时生成）。</p>
<p>如下图所示，当前的行数据会指向undo log中最近的数据版本，这样子使得数据的版本串行连接，方便数据的回滚等。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20250419152549.png" alt="guozhchun：额外的存储信息"></p>
<p>每次读取数据时，都会生成一个 ReadView，其中记录了当前活跃事务的 ID 集合、最小事务 ID、最大事务 ID 等信息，通过与 DB_TRX_ID 进行对比，判断当前事务是否可以看到该数据版本。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20250419152750.png" alt="luozhiyun：ReadView"></p>
<h4 id="什么是版本链"><a href="#什么是版本链" class="headerlink" title="什么是版本链"></a>什么是版本链</h4><p>版本链是指 InnoDB 中同一条记录的多个历史版本，通过 <strong>DB_ROLL_PTR 字段</strong>将它们像链表一样串起来，用来支持 MVCC 的快照读。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20240415084347.png" alt="二哥的 Java 进阶之路：版本链"></p>
<p>当更新一行数据时，innoDB不会覆盖原有的数据，会记录上一次的数据版本到undo日志中，并创建一个新的数据版本，更新DB_TRX_ID和DB_ROLL_PTR，使他们存放当前的事务ID和上一次数据版本在undo日志中的指针。</p>
<p>这样，老版本的数据就不会丢失，可以通过版本链找到。</p>
<p>由于 undo 日志会记录每一次的 update，并且新插入的行数据会记录上一条 undo 日志的指针，所以可以通过 DB_ROLL_PTR 这个指针找到上一条记录，这样就形成了一个版本链。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/mysql-765b3d83-14eb-4b56-8940-9d60bfaf1737.jpg" alt="三分恶面渣逆袭：版本链"></p>
<h4 id="什么是Read-View"><a href="#什么是Read-View" class="headerlink" title="什么是Read View"></a>什么是Read View</h4><p><strong>ReadView 是 InnoDB 为每个事务创建的一份“可见性视图”，用于判断在执行快照读时，哪些数据版本是当前这个事务可以看到的，哪些不能看到。</strong></p>
<p>当事务开始执行时，InnoDB 会为该事务创建一个 ReadView，这个 ReadView 会记录 4 个重要的信息：</p>
<ul>
<li>creator_trx_id：创建该 ReadView 的事务 ID。</li>
<li>m_ids：所有活跃事务的 ID 列表，<strong>活跃事务</strong>是指那些<strong>已经开始但尚未提交的事务</strong>。</li>
<li>min_trx_id：所有活跃事务中最小的事务 ID。它是 m_ids 数组中最小的事务 ID。</li>
<li>max_trx_id ：事务 ID 的最大值加一。换句话说，它是下一个将要生成的事务 ID。</li>
</ul>
<p>如何判断记录的某个版本是否可见？</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20240415094939.png" alt="二哥的 Java 进阶之路：ReadView判断规则"></p>
<p>①、如果某个数据版本的 DB_TRX_ID 小于 min_trx_id，则该数据版本在生成 ReadView 之前就已经提交，因此对当前事务是可见的。</p>
<p>②、如果 DB_TRX_ID 大于 max_trx_id，则表示创建该数据版本的事务在生成 ReadView 之后开始，因此对当前事务不可见。</p>
<p>③、如果 DB_TRX_ID 在 min_trx_id 和 max_trx_id 之间，需要判断 DB_TRX_ID 是否在 m_ids 列表中：</p>
<ul>
<li>不在，表示创建该数据版本的事务在生成 ReadView 之后已经提交，因此对当前事务也是可见的。</li>
<li>在，表示事务仍然活跃，或者在当前事务生成 ReadView 之后才开始，因此是不可见的。</li>
</ul>
<p>总之，readView规定了当前事务可见的范围，可见的只能是不在活跃事务范围内、且事务id不超过当前记录的未来事务id(即事务可见)的已经提交的事务。</p>
<h4 id="可重复读和读已提交在ReadView上的区别"><a href="#可重复读和读已提交在ReadView上的区别" class="headerlink" title="可重复读和读已提交在ReadView上的区别"></a>可重复读和读已提交在ReadView上的区别</h4><p>可重复读：在第一次读取数据时生成一个 ReadView，这个 ReadView 会一直保持到事务结束，这样可以保证在事务中多次读取同一行数据时，读取到的数据是一致的。</p>
<p>读已提交：每次读取数据前都生成一个 ReadView，这样就能保证每次读取的数据都是最新的。</p>
<h4 id="如果两个-AB-事务并发修改一个变量，那么-A-读到的值是什么，怎么分析"><a href="#如果两个-AB-事务并发修改一个变量，那么-A-读到的值是什么，怎么分析" class="headerlink" title="如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析"></a>如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析</h4><p>事务 A 在读取时是否能读到事务 B 的修改，<strong>取决于 A 是快照读还是当前读</strong>。如果是快照读，InnoDB 会使用 MVCC 的 ReadView 判断记录版本是否可见，若事务 B 尚未提交或在 A 的视图不可见，则 A 会读到旧值；如果是当前读，则需要加锁，若 B 已提交可直接读取，否则 A 会阻塞直到 B 结束。</p>
<p>知识点速过：UndoLog记录数据的历史版本（记录指针来连接），ReadView可以使快照读操作不阻塞。</p>
<p>到这里，豁然开朗了，原来mysql的事务隔离并不是完全参考遵循三级封锁协议的，它原来是用到了MVCC来减少频繁创建锁带来的性能损耗以及优化读操作的性能。</p>
<h3 id="6-什么是快照读和当前读"><a href="#6-什么是快照读和当前读" class="headerlink" title="6.什么是快照读和当前读"></a>6.什么是快照读和当前读</h3><ul>
<li><strong>快照读（Snapshot Read）</strong>：<ul>
<li>读取的是符合当前事务可见性规则的历史版本数据。</li>
<li>不加锁，适用于非阻塞读取。</li>
<li>适用于 <code>REPEATABLE READ</code> 和 <code>READ COMMITTED</code> 隔离级别下的普通查询。</li>
</ul>
</li>
<li><strong>当前读（Current Read）</strong>：<ul>
<li>读取的是数据的最新版本。</li>
<li>通常会加锁，适用于需要最新数据的场景。</li>
<li>适用于 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别下的 <code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... LOCK IN SHARE MODE</code> 查询。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ldy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/20/%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93-%E9%9A%8F%E5%BF%83%E8%AE%B0/">http://example.com/2025/04/20/%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93-%E9%9A%8F%E5%BF%83%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/30/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/" title="黑马头条项目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">黑马头条项目</div></div></a></div><div class="next-post pull-right"><a href="/2025/04/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/" title="微服务总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">微服务总结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/qcqwy/blog-img@main/img/poke1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ldy</div><div class="author-info__description">I am a slow walker,but I never walk backwards.我走得很慢，但是我从来不会后退</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qcqwy"><i class="fab fa-github"></i><span>别点这里</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Spring%E7%9B%B8%E5%85%B3"><span class="toc-text">一、Spring相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">1.Spring框架中的单例bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="toc-text">2.什么是AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E8%BF%87AOP"><span class="toc-text">3.项目中有没有用到过AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">4.Spring中事务失效的场景有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring%E7%9A%84Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">5.Spring的Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Spring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-text">6.Spring的循环依赖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">7.SpringMVC的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">8.SpringBoot自动配置原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Spring%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-text">9.Spring框架常见注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">10.Mybatis执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Mybatis%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-text">11.Mybatis的延迟加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-text">（1）什么是延迟加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%BB%B6%E8%BF%9F%E5%AF%B9%E8%B1%A1%E5%8E%9F%E7%90%86"><span class="toc-text">（2）延迟对象原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">12.Mybatis的一级、二级缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3"><span class="toc-text">二、java集合相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%91%A2%EF%BC%9F%E5%81%87%E5%A6%82%E4%BB%8E1%E5%BC%80%E5%A7%8B%E4%B8%8D%E8%A1%8C%E5%90%97"><span class="toc-text">1.为什么数组索引从0开始呢？假如从1开始不行吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">2.操作数组的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ArrayList%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">3.ArrayList底层实现原理是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="toc-text">小问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8CList%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">4.如何实现数组和List之间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3"><span class="toc-text">5.链表相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">6.ArrayList和LinkedList的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">7.HashMap底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AE%B2%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">8.讲讲HashMap的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-hashMap%E7%9A%84%E5%AF%BB%E5%9D%80%E7%AE%97%E6%B3%95"><span class="toc-text">9.hashMap的寻址算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84%E6%AC%A1%E5%B9%82%EF%BC%9F"><span class="toc-text">10.为什么HashMap的数组长度一定是2的次幂？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-text">三、并发编程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.线程和进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2.并行和并发有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">3.创建线程的方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE1-Runnable%E5%92%8CCallable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">追问1.Runnable和Callable有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE2-run-%E5%92%8Cstart-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">追问2.run()和start()有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="toc-text">4.线程包含哪些状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-text">5.线程状态之间是如何变化的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%96%B0%E5%BB%BAT1%E3%80%81T2%E3%80%81T3%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-text">6.新建T1、T2、T3三个线程，如何保证按顺序执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">7.wait和sleep方法的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">8.如何停止一个正在运行的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">9.synchronized关键字底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-JMM-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">10.JMM(java内存模型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-CAS"><span class="toc-text">11.CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12.乐观锁和悲观锁的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">12.volatile关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AFAQS"><span class="toc-text">13.什么是AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="toc-text">AQS底层源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch%E6%BA%90%E7%A0%81"><span class="toc-text">CountDownLatch源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-ReentrantLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">14.ReentrantLock实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-ConcurrentHashMap"><span class="toc-text">15.ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ThreadLocal"><span class="toc-text">16.ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">ThreadLocal实现的底层原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Mysql"><span class="toc-text">四、Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.如何定位慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%82%A3%E8%BF%99%E4%B8%AASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%91%A2%EF%BC%9F"><span class="toc-text">2.那这个SQL语句执行很慢，如何分析呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">3. 索引的底层数据结构了解过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-text">4.B树和B+树的区别是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">5.什么是聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">6.什么是回表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">7.什么是覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">8.超大分页怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-text">9.什么情况下，索引会失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E6%B8%A3%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-text">面渣八股文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E8%A6%81%E4%BD%BF%E7%94%A8B-%E6%A0%91%E5%81%9A%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">1.为什么InnoDB要使用B+树做为索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7-ACID"><span class="toc-text">2.事务的四大特性-ACID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">原子性:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">一致性:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-text">隔离性:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-text">持久性:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">3.事务的隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="toc-text">读未提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="toc-text">读已提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="toc-text">串行化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">4.事务的隔离级别是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-MVCC%E6%9C%BA%E5%88%B6"><span class="toc-text">5.MVCC机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-text">什么是版本链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRead-View"><span class="toc-text">什么是Read View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%9C%A8ReadView%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">可重复读和读已提交在ReadView上的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA-AB-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%E9%82%A3%E4%B9%88-A-%E8%AF%BB%E5%88%B0%E7%9A%84%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90"><span class="toc-text">如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">6.什么是快照读和当前读</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" title="Java深入学习">Java深入学习</a><time datetime="2025-05-14T09:24:59.000Z" title="发表于 2025-05-14 17:24:59">2025-05-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/08/%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" title="项目面试准备">项目面试准备</a><time datetime="2025-05-08T05:47:51.000Z" title="发表于 2025-05-08 13:47:51">2025-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/30/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/" title="黑马头条项目">黑马头条项目</a><time datetime="2025-04-30T08:15:21.000Z" title="发表于 2025-04-30 16:15:21">2025-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/20/%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93-%E9%9A%8F%E5%BF%83%E8%AE%B0/" title="后端知识点总结">后端知识点总结</a><time datetime="2025-04-19T16:58:46.000Z" title="发表于 2025-04-20 00:58:46">2025-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/" title="微服务总结">微服务总结</a><time datetime="2025-04-16T11:03:26.000Z" title="发表于 2025-04-16 19:03:26">2025-04-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://t.alcy.cc/fj/')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ldy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>