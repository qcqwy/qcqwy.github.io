<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Langchain4j学习</title>
      <link href="/2025/08/24/Langchain4j%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/08/24/Langchain4j%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、快速入门"><a href="#一、快速入门" class="headerlink" title="一、快速入门"></a>一、快速入门</h2><h3 id="普通maven项目"><a href="#普通maven项目" class="headerlink" title="普通maven项目"></a>普通maven项目</h3><h4 id="1-创建maven工程"><a href="#1-创建maven工程" class="headerlink" title="1.创建maven工程"></a>1.创建maven工程</h4><h4 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2.引入依赖"></a>2.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个依赖额外提供 OpenAI 模型调用能力 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-open-ai<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-构建聊天对象OpenAiChatModel"><a href="#3-构建聊天对象OpenAiChatModel" class="headerlink" title="3.构建聊天对象OpenAiChatModel"></a>3.构建聊天对象OpenAiChatModel</h4><p>因为Deepseek使用与OpenAi兼容的API格式，所以这里我创建了连接DeepSeek的模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.构建openAiChatModel对象</span></span><br><span class="line">        <span class="type">OpenAiChatModel</span> <span class="variable">model</span> <span class="operator">=</span> OpenAiChatModel.builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.deepseek.com&quot;</span>) <span class="comment">//模型的url</span></span><br><span class="line">                .modelName(<span class="string">&quot;deepseek-chat&quot;</span>) <span class="comment">//模型的名称</span></span><br><span class="line">                .apiKey(<span class="string">&quot;&quot;</span>) <span class="comment">//自己获取的apikey</span></span><br><span class="line">                .logRequests(<span class="literal">true</span>) <span class="comment">//打印请求日志</span></span><br><span class="line">                .logResponses(<span class="literal">true</span>) <span class="comment">//打印响应日志</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//2.调用chat方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> model.chat(<span class="string">&quot;你好啊&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/../images/image-20250824200254269.png" alt="image-20250824200254269"></p><h3 id="Spring整合Langchain4j"><a href="#Spring整合Langchain4j" class="headerlink" title="Spring整合Langchain4j"></a>Spring整合Langchain4j</h3><p>springboot项目创建看之前的博客。</p><h4 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1.核心依赖"></a>1.核心依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        langchain4j的springboot启动依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-open-ai-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1-beta6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-在配置文件中配置大模型信息"><a href="#2-在配置文件中配置大模型信息" class="headerlink" title="2.在配置文件中配置大模型信息"></a>2.在配置文件中配置大模型信息</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">langchain4j:</span></span><br><span class="line">  <span class="attr">open-ai:</span></span><br><span class="line">    <span class="attr">chat-model:</span> <span class="comment">#普通模型</span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">https://api.deepseek.com</span></span><br><span class="line">      <span class="attr">model-name:</span> <span class="string">deepseek-chat</span></span><br><span class="line">      <span class="attr">api-key:</span> <span class="string">自己的apikey</span></span><br><span class="line">      <span class="attr">log-requests:</span> <span class="literal">true</span>   <span class="comment"># 打印请求日志</span></span><br><span class="line">      <span class="attr">log-responses:</span> <span class="literal">true</span>   <span class="comment"># 打印响应日志</span></span><br><span class="line">    <span class="attr">streaming-chat-model:</span> <span class="comment">#流式模型</span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">https://api.deepseek.com</span></span><br><span class="line">      <span class="attr">model-name:</span> <span class="string">deepseek-chat</span></span><br><span class="line">      <span class="attr">api-key:</span> <span class="string">自己的apikey</span></span><br><span class="line">      <span class="attr">log-requests:</span> <span class="literal">true</span>   <span class="comment"># 打印请求日志</span></span><br><span class="line">      <span class="attr">log-responses:</span> <span class="literal">true</span>   <span class="comment"># 打印响应日志</span></span><br></pre></td></tr></table></figure><h4 id="3-创建Controller调用接口"><a href="#3-创建Controller调用接口" class="headerlink" title="3.创建Controller调用接口"></a>3.创建Controller调用接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;chat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line">    <span class="comment">//引入自动装配好的model</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OpenAiChatModel chatModel;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">chat</span> <span class="operator">=</span> chatModel.chat(msg);</span><br><span class="line">        <span class="keyword">return</span> chat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/../images/image-20250824201201790.png" alt="image-20250824201201790"></p><p>综上，最简单的与大模型的交互就完成了。</p><h2 id="二、进阶篇"><a href="#二、进阶篇" class="headerlink" title="二、进阶篇"></a>二、进阶篇</h2><h3 id="1-AiService工具类"><a href="#1-AiService工具类" class="headerlink" title="1.AiService工具类"></a>1.AiService工具类</h3><p>LangChain4j提供的工具类AiServices，是一个非常宝藏的工具。在快速入门中，访问大模型是借助于OpenAiChatModel的chat方法完成的。其实这种方式在实际开发中并不是很常用，因为如果使用这种方式调用大模型，将来我们完成一些高阶的功能，比如<strong>会话记忆&#x2F;RAG知识库&#x2F;Tools工具</strong>的时候，在调用chat方法访问大模型前，我们需要自己做很多很多的工作，完成起来是比较复杂的。</p><p>为了简化使用，Langchain4j提供了AiService工具类，封装了有关model对象和其他一些功能的操作。这里以spring集成langchain4j为例来介绍。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   AiService相关依赖     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1-beta6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="声明用于封装聊天方法的接口"><a href="#声明用于封装聊天方法的接口" class="headerlink" title="声明用于封装聊天方法的接口"></a>声明用于封装聊天方法的接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatService</span> &#123;</span><br><span class="line">    <span class="comment">//用于聊天的方法，message为用户输入的内容</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用AiService工具类创建接口的动态代理对象"><a href="#使用AiService工具类创建接口的动态代理对象" class="headerlink" title="使用AiService工具类创建接口的动态代理对象"></a>使用AiService工具类创建接口的动态代理对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OpenAiChatModel model;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//注册到Spring容器中</span></span><br><span class="line">    <span class="keyword">public</span> ChatService <span class="title function_">chatService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AiServices.builder(ChatService.class)</span><br><span class="line">                .chatModel(model) <span class="comment">//设置对话时使用的模型对象</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注入Controller并使用"><a href="#注入Controller并使用" class="headerlink" title="注入Controller并使用"></a>注入Controller并使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;chat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ChatService chatService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getChat</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">chat</span> <span class="operator">=</span> chatService.chat(msg);</span><br><span class="line">        <span class="keyword">return</span> chat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h5><p><img src="/../images/image-20250824202309660.png" alt="image-20250824202309660"></p><h5 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h5><p>当调用chatService.chat(msg)时，实际发生的过程是：</p><ol><li>Java动态代理拦截了这个方法调用</li><li>Langchain4j将方法名和参数转换为对AI模型的请求</li><li>根据配置，向DeepSeek API发送HTTP请求</li><li>接收并处理AI模型的响应</li><li>将响应结果作为方法返回值返回</li></ol><p>这种设计的优势在于，开发者只需要定义接口和方法，而不需要编写具体的实现代码，大大简化了与AI模型交互的复杂性。Langchain4j负责处理所有底层细节，包括HTTP通信、JSON序列化&#x2F;反序列化、错误处理等。</p><p>在单个参数的情况下，默认给大模型发送的是用户信息，如果是<strong>多个参数，则需要通过注解指定各个参数的作用</strong>。</p><h4 id="声明式使用"><a href="#声明式使用" class="headerlink" title="声明式使用"></a>声明式使用</h4><p>为了简化AIServices工具类的使用，LangChain4j提供了声明式使用方法，想为哪个接口创建代理对象，只需要在该接口上添加@AiService注解并指定要使用的模型，将来LangChain4j扫描到该注解后会自动的创建该接口的代理对象并注入到IOC容器中，这样子就不需要我们手动在配置类中创建Bean对象了。接下来修改ConsultantService中的代码，并重新测试。</p><h5 id="接口配置"><a href="#接口配置" class="headerlink" title="接口配置"></a>接口配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AiService(</span></span><br><span class="line"><span class="meta">        wiringMode = AiServiceWiringMode.EXPLICIT, //装配模式，手动</span></span><br><span class="line"><span class="meta">        chatModel = &quot;openAiChatModel&quot; //要使用的模型在容器中的bean名称</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatService</span> &#123;</span><br><span class="line">    <span class="comment">//用于聊天的方法，message为用户输入的内容</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Langchain4j中，@AiService注解的wiringMode参数用于指定AI服务组件的装配模式。它有两个可选值：</p><p>1.AUTOMATIC（自动装配模式）</p><p>这是默认模式，不需要显式指定组件。Langchain4j会自动从Spring应用上下文中查找并装配所有可用的Langchain4j组件，包括：</p><ol><li>ChatModel</li><li>StreamingChatLanguageModel</li><li>ChatMemory</li><li>ChatMemoryProvider</li><li>ContentRetriever</li><li>RetrievalAugmentor</li><li>所有标记为@Tool的方法</li></ol><p>2.EXPLICIT（显式装配模式）</p><p>当应用中有多个AI服务，并且希望为每个服务指定不同的Langchain4j组件时，就需要使用显式装配模式。</p><h3 id="2-流式调用"><a href="#2-流式调用" class="headerlink" title="2.流式调用"></a>2.流式调用</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  引入流式调用的相关依赖      --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-reactor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1-beta6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置流式模型对象"><a href="#配置流式模型对象" class="headerlink" title="配置流式模型对象"></a>配置流式模型对象</h4><p>之前使用的是阻塞式对话模型对象，在流式调用中，需要使用流式模型对象，故也需要进行配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">langchain4j:</span></span><br><span class="line">  <span class="attr">open-ai:</span></span><br><span class="line">    <span class="attr">streaming-chat-model:</span> <span class="comment"># 流式模型对象</span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">https://api.deepseek.com</span></span><br><span class="line">      <span class="attr">model-name:</span> <span class="string">deepseek-chat</span></span><br><span class="line">      <span class="attr">api-key:</span> <span class="string">自己的apikey</span></span><br><span class="line">      <span class="attr">log-requests:</span> <span class="literal">true</span>   <span class="comment"># 打印请求日志</span></span><br><span class="line">      <span class="attr">log-responses:</span> <span class="literal">true</span>   <span class="comment"># 打印响应日志</span></span><br></pre></td></tr></table></figure><h4 id="在接口中配置流式模型对象"><a href="#在接口中配置流式模型对象" class="headerlink" title="在接口中配置流式模型对象"></a>在接口中配置流式模型对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AiService(</span></span><br><span class="line"><span class="meta">        wiringMode = AiServiceWiringMode.EXPLICIT, //</span></span><br><span class="line"><span class="meta">        chatModel = &quot;openAiChatModel&quot;, //阻塞式模型，模型在容器中的bean名称</span></span><br><span class="line"><span class="meta">        streamingChatModel = &quot;openAiStreamingChatModel&quot;//流式模型</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatService</span> &#123;</span><br><span class="line">    <span class="comment">//用于聊天的方法，message为用户输入的内容</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="comment">//流式返回</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">fluxChat</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>langchain4j中，会根据方法的返回值来自动选择使用哪个模型</p><p>同步返回类型（String、Response等）→ 使用chatModel</p><p>流式返回类型（Flux、Publisher等）→ 使用streamingChatModel</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/flux&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">getFlux</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    Flux&lt;String&gt; res = chatService.fluxChat(msg);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250824204847416.png" alt="image-20250824204847416"></p><p>可以看到，浏览器返回了乱码</p><h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>在访问String的get接口时，响应标头携带了utf-8的编码格式，</p><p><img src="/../images/image-20250824210558957.png" alt="image-20250824210558957"></p><p>但在flux接口却没有携带</p><p><img src="/../images/image-20250824210918937.png" alt="image-20250824210918937"></p><p>乱码产生原因还是编码和解码不匹配的问题：</p><p>SpringBoot默认使用utf-8进行编码，并在响应头中告诉浏览器编码方式为utf-8。但在流式响应中，没有告诉浏览器编码方式为utf-8,导致浏览器使用默认的解码方式（非utf-8）进行解码，导致乱码问题产生。</p><h4 id="解决乱码问题"><a href="#解决乱码问题" class="headerlink" title="解决乱码问题"></a>解决乱码问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/flux&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">getFlux</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    Flux&lt;String&gt; res = chatService.fluxChat(msg);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>produces参数作用：</p><p>1.决定请求能不能匹配到这个接口，即判断前端的Accept头里声明的能接收的媒体类型是否符合  </p><p>2.返回响应时，在响应头中的Content-Type中设置为<code>text/html;charset=指定编码格式</code></p><h3 id="3-消息注解"><a href="#3-消息注解" class="headerlink" title="3.消息注解"></a>3.消息注解</h3><p>在langchain4j中提供了两个有关消息的注解，一个是SystemMessage,另一个是UserMessage。</p><h4 id="SystemMessage"><a href="#SystemMessage" class="headerlink" title="SystemMessage"></a>SystemMessage</h4><p>SystemMessage用于设置系统消息，可以直接在接口方法中添加这个注解，然后在注解中添加指定的系统消息即可。如果说消息很长，写在代码中不方便，也可以通过fromResource属性指定外部的文件，这样子可以一次性把系统消息写入到外部文件中，管理起来也很方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    @SystemMessage(&quot;你是高考志愿填报者,禁止回答与高考志愿无关的问题&quot;)</span></span><br><span class="line"><span class="meta">@SystemMessage(fromResource = &quot;system.txt&quot;)</span> <span class="comment">//访问位置：resource文件下的system.txt文件</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">fluxChat</span><span class="params">(String msg)</span>;</span><br></pre></td></tr></table></figure><h4 id="UserMessage"><a href="#UserMessage" class="headerlink" title="UserMessage"></a>UserMessage</h4><p>@UserMessage可以帮助我们把用户传递的消息拼接上我们预设的消息，使用方式如下，注意使用<code>&#123;&#123;&#125;&#125;</code>和@V注解进行绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个参数情况</span></span><br><span class="line"><span class="meta">@SystemMessage(fromResource = &quot;system.txt&quot;)</span></span><br><span class="line"><span class="meta">@UserMessage(&quot;您好，我有个志愿填报问题：&#123;&#123;it&#125;&#125;&quot;)</span> <span class="comment">//只有一个参数情况下默认使用msg进行拼接</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">fluxChat</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个参数情况</span></span><br><span class="line"><span class="meta">@UserMessage(&quot;您好，我是&#123;&#123;name&#125;&#125;, 想请教您：&#123;&#123;msg&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">chat2</span><span class="params">(<span class="meta">@V(&quot;name&quot;)</span> String msg1, <span class="meta">@V(&quot;msg&quot;)</span> String msg2)</span>;</span><br></pre></td></tr></table></figure><p>这里有一点需要说明，在没有@V情况下，这个花括号内的it是固定的，不能随便写（写了别的就会报异常）。假设你不想使用it这个名字，langchain4j提供了一个V注解，用于解决这个问题。我们在参数前面通过V注解给这个参数起一个名字，然后在花括号内写上同样的名字就能获取到了。</p><p><img src="/../images/image-20250824215038830.png" alt="image-20250824215038830"></p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>以上面的接口配置为准，单参测试</p><p><img src="/../images/image-20250824215204856.png" alt="image-20250824215204856"></p><p>多参测试</p><p><img src="/../images/image-20250824215459088.png" alt="image-20250824215459088"></p><h3 id="4-会话记忆"><a href="#4-会话记忆" class="headerlink" title="4.会话记忆"></a>4.会话记忆</h3><p>大模型是如何记住我们之前的问题的，来回答后续的问题的呢？答案就是<strong>在当前问题发送的同时，将之前的问题和回答一并发送了过去</strong>！！！这就是会话记忆的实现方式。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>来源：<a href="https://fhg2d1ub6i.feishu.cn/docx/X2o7dVT0XoszQvxFKUCcHv78nVg">第三章：LangChain4j - 飞书云文档</a></p><p><img src="/../images/eed7834f-484d-415f-944e-c16ad2de95c6.gif" alt="eed7834f-484d-415f-944e-c16ad2de95c6"></p><p>当用户问西北大学是211吗？它会把消息传递给后端，后端接收到消息后，会自动把消息存放到存储对象中，然后再获取存储对象中记录的所有会话消息，一块发送给大模型，当然现在存储对象中只记录了一条消息，所以只把一条消息发送给大模型。大模型根据接收到的消息，生成答案，比如说是的，再把答案响应给web后端，此时web后端会把得到的响应消息往存储对象中拷贝一份，然后再把响应消息发送给用户。</p><p>用户接收到答案后，接着问,是985吗？这条消息发送给web后端后，web后端依然会自动的把消息存放到存储对象中，此时存储对象中就存放了三条消息了，紧接着获取到存储对象中所有的会话消息，一并发送给大模型，这一次大模型就能够根据用户发送的所有会话记录进行推断回答了，这就是会话记忆的原理！</p><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>langchain4j提供了一个接口叫做<strong>ChatMemory</strong>，该接口中提供了add方法用于添加一条记录，messages方法用于获取所有的会话记录，clear方法用于清除所有的会话记录，这里还有一个id方法，它是用于唯一的标识一个存储对象。</p><h5 id="定义会话记忆对象"><a href="#定义会话记忆对象" class="headerlink" title="定义会话记忆对象"></a>定义会话记忆对象</h5><p>在配置类中创建ChatMemory的实现类并注册到IOC容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ChatMemory <span class="title function_">chatMemory</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MessageWindowChatMemory.builder()</span><br><span class="line">            .maxMessages(<span class="number">20</span>) <span class="comment">//最大的会话数量</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置会话记忆对象"><a href="#配置会话记忆对象" class="headerlink" title="配置会话记忆对象"></a>配置会话记忆对象</h5><p>配置到AiService中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AiService(</span></span><br><span class="line"><span class="meta">        wiringMode = AiServiceWiringMode.EXPLICIT, //</span></span><br><span class="line"><span class="meta">        chatModel = &quot;openAiChatModel&quot;, //阻塞式模型，模型在容器中的bean名称</span></span><br><span class="line"><span class="meta">        streamingChatModel = &quot;openAiStreamingChatModel&quot;,//流式模型</span></span><br><span class="line"><span class="meta">        chatMemory = &quot;chatMemory&quot; //配置会话记忆对象，填入bean名称</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatService</span> &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="会话记忆隔离"><a href="#会话记忆隔离" class="headerlink" title="会话记忆隔离"></a>会话记忆隔离</h4><p>上述的配置和实现并没有区分访问的用户对象，导致不同用户会共用同一个会话记忆对象。</p><p>要实现会话记忆隔离，就要使用唯一标识(id)来标记会话记忆对象。</p><p><img src="/../images/ff0f319e-422b-43fd-b3a7-1cd1cb596a58.gif" alt="ff0f319e-422b-43fd-b3a7-1cd1cb596a58"></p><p>在LangChain4j中可以准备一个容器，专门用于存储当前程序中所有的会话记忆对象。假设有一个用户访问我们的程序，此时它除了要把用户问题message携带给后端，还需要携带一个memoryId，假设它携带的memoryId为1，此时LangChain4j会先从容器中找有没有一个ChatMemory对象的id为1，如果有就使用，但是很明显现在没有。所以它会新创建一个ChatMemory对象，并把当前的memoryId  1  设置给这个ChatMemory对象，并把会话记录存储到该对象中使用。</p><p>假设又有一个用户访问我们的程序，它携带的memoryId为2，同样的，LangChain4j也会从容器中找有没有一个ChatMemory对象的id为2，很显然还是没有，所以会创建一个新的ChatMemory对象，并把memoryId 2设置给这个ChatMemory对象，并把会话记录存储到该对象中使用。</p><p>注意，假设第二个用户继续访问我们的程序，它携带了同样的memoryId 2给后端，此时LangChain4j从容器中查找的时候发现已经存在一个ChatMemory对象的id为2，所以直接复用这个已经存在的ChatMemory对象，这样我们就可以借助于ChatMemory的id值实现不同会话之间的记忆隔离效果。</p><h5 id="定义会话记忆对象提供者"><a href="#定义会话记忆对象提供者" class="headerlink" title="定义会话记忆对象提供者"></a>定义会话记忆对象提供者</h5><p>因为要区分不同的会话对象，所以需要创建一个能根据传入的id创建不同ChatMemory的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ChatMemoryProvider <span class="title function_">chatMemoryProvider</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChatMemoryProvider</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ChatMemory <span class="title function_">get</span><span class="params">(Object memoryId)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageWindowChatMemory.builder()</span><br><span class="line">                    .id(memoryId)</span><br><span class="line">                    .maxMessages(<span class="number">20</span>)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置会话记忆对象提供者"><a href="#配置会话记忆对象提供者" class="headerlink" title="配置会话记忆对象提供者"></a>配置会话记忆对象提供者</h5><p>这里原先的charMemory就不需要了，因为它仅仅是固定一个对象，而我们需要的是根据id的不同创建能新的chatMemory对象的提供者来获取或者创建chatMemory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AiService(</span></span><br><span class="line"><span class="meta">        wiringMode = AiServiceWiringMode.EXPLICIT, //</span></span><br><span class="line"><span class="meta">        chatModel = &quot;openAiChatModel&quot;, //阻塞式模型，模型在容器中的bean名称</span></span><br><span class="line"><span class="meta">        streamingChatModel = &quot;openAiStreamingChatModel&quot;,//流式模型</span></span><br><span class="line"><span class="meta">        //chatMemory = &quot;chatMemory&quot;, //会话记忆对象</span></span><br><span class="line"><span class="meta">        chatMemoryProvider = &quot;charMemoryProvider&quot; //会话记忆对象提供者</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatService</span> &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口添加MemoryId参数"><a href="#接口添加MemoryId参数" class="headerlink" title="接口添加MemoryId参数"></a>接口添加MemoryId参数</h5><p>使用@MemoryId注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SystemMessage(fromResource = &quot;system.txt&quot;)</span></span><br><span class="line"><span class="meta">@UserMessage(&quot;您好，我有个志愿填报问题：&#123;&#123;it&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">fluxChat</span><span class="params">(<span class="meta">@MemoryId</span> String memoryId, <span class="meta">@V(&quot;it&quot;)</span> String msg)</span>;</span><br></pre></td></tr></table></figure><h5 id="Controller添加MemoryId参数"><a href="#Controller添加MemoryId参数" class="headerlink" title="Controller添加MemoryId参数"></a>Controller添加MemoryId参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/flux&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">getFlux</span><span class="params">(String memoryId, String msg)</span>&#123;</span><br><span class="line">    Flux&lt;String&gt; res = chatService.fluxChat(memoryId, msg);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><p>memoryId&#x3D;1时测试</p><p><img src="/../images/image-20250824223413311.png" alt="image-20250824223413311"></p><p><img src="/../images/image-20250824223539038.png" alt="image-20250824223539038"></p><p>memory&#x3D;2继续测试</p><p><img src="/images/image-20250824223628874.png" alt="image-20250824223628874"></p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>配置提供者后，是如何判断id对应的会话对象是否已经存在的？</p><ol><li>核心概念澄清<br> 首先需要澄清一个概念：ChatMemoryProvider本身并不判断ID是否存在，它只是根据ID返回ChatMemory实例。真正存储会话ID和消息列表的是底层的ChatMemoryStore。它可以在build ChatMemory时进行指定，跟后面讲的持久化相关。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ChatMemoryProvider <span class="title function_">chatMemoryProvider</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChatMemoryProvider</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ChatMemory <span class="title function_">get</span><span class="params">(Object id)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageWindowChatMemory.builder()</span><br><span class="line">                    .id(id)</span><br><span class="line">                    .chatMemoryStore(myChatMemoryStore)  <span class="comment">// 关键在这里</span></span><br><span class="line">                    .maxMessages(<span class="number">20</span>)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>源码解读</li></ol><p>ChatMemory的实现类MessageWindowChatMemory的部分源码+解读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageWindowChatMemory</span> <span class="keyword">implements</span> <span class="title class_">ChatMemory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer maxMessages;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatMemoryStore store; <span class="comment">//真正存储会话记录的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置会话ID</span></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">id</span><span class="params">(Object id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//添加新消息到对应的store中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(ChatMessage message)</span> &#123;</span><br><span class="line">        <span class="comment">//获取历史消息</span></span><br><span class="line">        List&lt;ChatMessage&gt; messages = <span class="built_in">this</span>.messages();</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> SystemMessage) &#123;</span><br><span class="line">            Optional&lt;SystemMessage&gt; systemMessage = findSystemMessage(messages);</span><br><span class="line">            <span class="keyword">if</span> (systemMessage.isPresent()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((SystemMessage)systemMessage.get()).equals(message)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                messages.remove(systemMessage.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//历史消息拼接上新的消息</span></span><br><span class="line">        messages.add(message);</span><br><span class="line">        <span class="comment">//判断消息容量</span></span><br><span class="line">        ensureCapacity(messages, <span class="built_in">this</span>.maxMessages);</span><br><span class="line">        <span class="comment">//根据消息id,更新store的map对应的消息列表</span></span><br><span class="line">        <span class="built_in">this</span>.store.updateMessages(<span class="built_in">this</span>.id, messages);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;ChatMessage&gt; <span class="title function_">messages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//从sotre中获取会话列表</span></span><br><span class="line">        List&lt;ChatMessage&gt; messages = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(<span class="built_in">this</span>.store.getMessages(<span class="built_in">this</span>.id));</span><br><span class="line">        ensureCapacity(messages, <span class="built_in">this</span>.maxMessages);</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatMemoryStore的实现类InMemoryChatMemoryStore解读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到ChatMemoryStore并没有任何存储对象的方式，所以InMemoryChatMemoryStore的Map只是存储会话记录的一种方式，其他方法也可以使用的，具体怎么存储，还是看自己的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatMemoryStore</span> &#123;</span><br><span class="line">    List&lt;ChatMessage&gt; <span class="title function_">getMessages</span><span class="params">(Object var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateMessages</span><span class="params">(Object var1, List&lt;ChatMessage&gt; var2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteMessages</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InMemoryChatMemoryStore</span> <span class="keyword">implements</span> <span class="title class_">ChatMemoryStore</span> &#123;</span><br><span class="line">    <span class="comment">//维护了一个以memoryId为key,消息列表为value的Map对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;ChatMessage&gt;&gt; messagesByMemoryId = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InMemoryChatMemoryStore</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;ChatMessage&gt; <span class="title function_">getMessages</span><span class="params">(Object memoryId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (List)<span class="built_in">this</span>.messagesByMemoryId.computeIfAbsent(memoryId, (ignored) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//根据会话id，直接把消息列表进行put</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateMessages</span><span class="params">(Object memoryId, List&lt;ChatMessage&gt; messages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messagesByMemoryId.put(memoryId, messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMessages</span><span class="params">(Object memoryId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messagesByMemoryId.remove(memoryId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以知道，当一个用户传入会话id和会话时，会先根据id创建一个新的ChatMemory对象，然后，再调用add方法传入用户当前的消息，在add方法中，它会往它关联的store对象中先读取历史会话列表，在把当前消息添加到列表末尾，最后调用Store对象的updateMessages方法，对InMemoryChatMemoryStore对象维护的Map中，根据会话ID，进行会话列表的更新。</p><p>所以，简单来说，真正存储会话id和会话列表的是ChatMemoryStore对象，ChatMemory对象只是用来操作Store对象的，并不存储消息，Provider对象只是用来创建ChatMemory对象的。</p><p>ok,完成了上面的源码解读还是挺爽的。</p><h4 id="会话记忆持久化"><a href="#会话记忆持久化" class="headerlink" title="会话记忆持久化"></a>会话记忆持久化</h4><p>上面我们已经知道了ChatMemoryStore是如何存储会话记录的，那么问题来了，如果使用已有的ChatMemoryStore实现类，那么当服务器重启时，数据就会丢失，所以我们需要自己去创建ChatMemoryStore的实现，来实现用中间件，比如用redis持久化存储消息。</p><p>下面就使用redis来实现会话的持久化存储</p><h5 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置redis连接信息"><a href="#配置redis连接信息" class="headerlink" title="配置redis连接信息"></a>配置redis连接信息</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">自己的redis的ip地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h5 id="自定义ChatMemoryStore对象的实现类"><a href="#自定义ChatMemoryStore对象的实现类" class="headerlink" title="自定义ChatMemoryStore对象的实现类"></a>自定义ChatMemoryStore对象的实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisChatMemoryStore</span> <span class="keyword">implements</span> <span class="title class_">ChatMemoryStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate template;</span><br><span class="line">    <span class="comment">//会话记录的key前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;chat_memoryId_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ChatMessage&gt; <span class="title function_">getMessages</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//获取存储在redis中的序列化后的json数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> template.opsForValue().get(prefix + o);</span><br><span class="line">        <span class="comment">//对message反序列化为会话列表</span></span><br><span class="line">        List&lt;ChatMessage&gt; chatMessages = ChatMessageDeserializer.messagesFromJson(message);</span><br><span class="line">        <span class="keyword">return</span> chatMessages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateMessages</span><span class="params">(Object o, List&lt;ChatMessage&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//对会话列表序列化为json字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ChatMessageSerializer.messagesToJson(list);</span><br><span class="line">        <span class="comment">//更新会话列表</span></span><br><span class="line">        template.opsForValue().set(prefix+o, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMessages</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//删除会话记录</span></span><br><span class="line">        template.delete(prefix + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里使用了ChatMessageSerializer和ChatMessageDeserializer提供的序列化和反序列化方法。</p><h5 id="在ChatMemoryProvider中配置自定义实现类"><a href="#在ChatMemoryProvider中配置自定义实现类" class="headerlink" title="在ChatMemoryProvider中配置自定义实现类"></a>在ChatMemoryProvider中配置自定义实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OpenAiChatModel model;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisChatMemoryStore redisChatMemoryStore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会话记忆对象提供者</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ChatMemoryProvider <span class="title function_">chatMemoryProvider</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ChatMemoryProvider</span> <span class="variable">chatMemoryProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatMemoryProvider</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ChatMemory <span class="title function_">get</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                ;<span class="keyword">return</span> MessageWindowChatMemory.builder()</span><br><span class="line">                        .id(o)</span><br><span class="line">                        .chatMemoryStore(redisChatMemoryStore) <span class="comment">//使用自定义会话存储对象</span></span><br><span class="line">                        .maxMessages(<span class="number">20</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> chatMemoryProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h5><p>完美存储到redis中，测试时我注意到消息的存储流程正是，用户发送消息 -&gt; 消息存储到redis -&gt; 发送消息给大模型 -&gt; 大模型生成回答 -&gt; 回答存入redis -&gt; 返回给前端</p><p><img src="/../images/image-20250824234216377.png" alt="image-20250824234216377"></p><h5 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h5><p>会话记忆中的主要的三个接口设置的实在是太妙了，由ChatMemoryStore负责会话记录的增删改，ChatMemory负责消息的业务逻辑操作，比如拼接会话记录并存入到store对象中，ChatMemoryProvider则类似于工厂，提供ChatMemory对象的实例。极大程度上进行了解耦，方便扩展。</p><p>职责分离 (Separation of Concerns)</p><ul><li>ChatMemoryStore: 专注于数据的持久化和检索</li><li>ChatMemory: 专注于消息的处理和操作</li><li>ChatMemoryProvider: 专注于实例的创建和管理</li></ul><p>高内聚低耦合 (High Cohesion, Low Coupling)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经收集</title>
      <link href="/2025/08/18/%E9%9D%A2%E7%BB%8F%E6%94%B6%E9%9B%86/"/>
      <url>/2025/08/18/%E9%9D%A2%E7%BB%8F%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="杭州元启视界"><a href="#杭州元启视界" class="headerlink" title="杭州元启视界"></a>杭州元启视界</h2><p>地址</p><p><a href="https://www.nowcoder.com/feed/main/detail/21cd7fb9ba804c649ea653718e7e9afa?sourceSSR=users">27双非本 杭州某500人厂 一面（30min）_牛客网</a></p><h3 id="1-什么是跨域问题？"><a href="#1-什么是跨域问题？" class="headerlink" title="1.什么是跨域问题？"></a>1.什么是跨域问题？</h3><p>跨域问题就是指前端js请求后端接口时，浏览器会判断当前网页的url（这个是网页自身的url地址）和请求的服务器的url是否同源，如果协议、域名和端口有一个不同，那么浏览器就会判定为跨域请求并拦截。</p><h3 id="2-如何解决跨域问题。"><a href="#2-如何解决跨域问题。" class="headerlink" title="2.如何解决跨域问题。"></a>2.如何解决跨域问题。</h3><p>我所知道的就两种方式，一种在后端解决，一种在前端解决。</p><p>1.配置CORS,也就是在服务器上设置相应的响应头。在java的spring中，可以通过创建WebMvcConfigurer对象，重写它的addCorsMappings方法，配置相应的请求域名、请求方式等内容，然后注册到spring容器中来解决。</p><p>2.前端的话可以通过反向代理的方式来解决，就是通过把请求转发给同源的代理服务器，然后由代理服务器代为转发给目标服务器，以绕过浏览器的同源策略检测。</p><table><thead><tr><th align="left"><strong>正向代理（Forward Proxy）</strong></th><th align="left"><strong>反向代理（Reverse Proxy）</strong></th><th></th></tr></thead><tbody><tr><td align="left"><strong>作用对象</strong></td><td align="left">代表 <strong>客户端</strong> 访问服务器</td><td>代表 <strong>服务器</strong> 接收客户端请求</td></tr><tr><td align="left"><strong>客户端是否感知</strong></td><td align="left">客户端知道自己在用代理（如VPN）****</td><td><strong>客户端不知道代理存在（以为是真实服务器）</strong></td></tr><tr><td align="left"><strong>典型用途</strong></td><td align="left">翻墙、隐藏客户端IP</td><td>负载均衡、缓存、跨域、安全防护</td></tr></tbody></table><h3 id="3-Linux中查询当前端口号被占用的命令。"><a href="#3-Linux中查询当前端口号被占用的命令。" class="headerlink" title="3.Linux中查询当前端口号被占用的命令。"></a>3.Linux中查询当前端口号被占用的命令。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp | grep 端口号</span><br><span class="line"><span class="comment"># 或（新系统推荐）</span></span><br><span class="line">ss -tulnp | grep 端口号</span><br><span class="line"><span class="comment"># 查看具体进程</span></span><br><span class="line">lsof -i :端口号</span><br></pre></td></tr></table></figure><h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p><code>netstat</code>（Network Statistics）用于显示 <strong>网络连接、路由表、接口统计</strong> 等网络相关信息。</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>-t</code> (–tcp)</td><td align="left">显示 <strong>TCP</strong> 协议相关的连接</td></tr><tr><td align="left"><code>-u</code> (–udp)</td><td align="left">显示 <strong>UDP</strong> 协议相关的连接</td></tr><tr><td align="left"><code>-l</code> (–listening)</td><td align="left"><strong>仅显示监听（LISTEN）状态的端口</strong></td></tr><tr><td align="left"><code>-n</code> (–numeric)</td><td align="left"><strong>禁用域名解析</strong>，直接显示 IP 和端口（加快查询速度）</td></tr><tr><td align="left"><code>-p</code> (–program)</td><td align="left"><strong>显示占用端口的进程名和 PID</strong></td></tr></tbody></table><p>典型输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address    Foreign Address   State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:80      0.0.0.0:*         LISTEN      1234/nginx</span><br><span class="line">tcp6       0      0 :::22           :::*              LISTEN      567/sshd</span><br><span class="line">udp        0      0 0.0.0.0:53      0.0.0.0:*                     789/dnsmasq</span><br></pre></td></tr></table></figure><h4 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h4><p><code>lsof</code>（List Open Files）列出 <strong>系统中被打开的文件</strong>（Linux 中一切皆文件，包括网络连接、设备、管道等）。</p><p> <strong>常用用法</strong></p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>lsof -i :80</code></td><td align="left">查看 <strong>80 端口</strong> 被哪个进程占用</td></tr><tr><td align="left"><code>lsof -i tcp</code></td><td align="left">查看所有 <strong>TCP 连接</strong></td></tr><tr><td align="left"><code>lsof -u root</code></td><td align="left">查看 <strong>root 用户</strong> 打开的文件</td></tr><tr><td align="left"><code>lsof -c nginx</code></td><td align="left">查看 <strong>nginx 进程</strong> 打开的文件</td></tr></tbody></table><h3 id="4-什么是MVCC？解决了什么问题？MVCC原理？"><a href="#4-什么是MVCC？解决了什么问题？MVCC原理？" class="headerlink" title="4.什么是MVCC？解决了什么问题？MVCC原理？"></a>4.什么是MVCC？解决了什么问题？MVCC原理？</h3><p>八股吟唱</p><h3 id="5-什么是单例模式？常用的实现方式？每种实现方式的优缺点？"><a href="#5-什么是单例模式？常用的实现方式？每种实现方式的优缺点？" class="headerlink" title="5.什么是单例模式？常用的实现方式？每种实现方式的优缺点？"></a>5.什么是单例模式？常用的实现方式？每种实现方式的优缺点？</h3><h4 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h4><p>单例模式就是确保一个类只有一个实例，并对外提供获取这个唯一实例的方法。</p><h4 id="（1）饿汉式"><a href="#（1）饿汉式" class="headerlink" title="（1）饿汉式"></a>（1）饿汉式</h4><p>就是直接在类上创建一个由final修饰的该类的静态变量，直接在类加载阶段就完成初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：<strong>实现简单</strong>。而且因为在类加载阶段就完成了初始化，<strong>避免了线程安全问题</strong>。</p><p>缺点：如果实例未被使用的情况下，会导致<strong>内存浪费</strong>。此外，因为不是延迟加载，所以<strong>程序启动的速度</strong>也会受到影响。</p><h4 id="（2）懒汉式"><a href="#（2）懒汉式" class="headerlink" title="（2）懒汉式"></a>（2）懒汉式</h4><p>就是给获取实例的方法加上synchronized关键字，在方法内部会判断实例是否为null,如果为null就进行初始化。然后再返回该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：实现了延迟加载，提升程序启动速度，在实例未被使用的情况下不会浪费内存。</p><p>缺点：因为给方法加了synchronized关键字，所以每次获取实例时都需要同步获取，性能较差、效率低。</p><h4 id="（3）双重检查锁"><a href="#（3）双重检查锁" class="headerlink" title="（3）双重检查锁"></a>（3）双重检查锁</h4><p>特点就是给实例变量加上volatile关键字来保证变量的可见性和避免指令重排序产生的问题，在方法内部会先判断实例是否为null,为null时在调用synchronized获取当前类的Class对象锁，获取到锁之后，再次判断实例变量是否为null。最后返回创建好后的实例变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：实现了延迟加载（节省内存、提升程序的响应速度），还解决了懒汉式方法的实例获取效率低的问题。</p><p>缺点：实现比较复杂，需要使用volatile关键字吧。</p><h4 id="（4）静态内部类"><a href="#（4）静态内部类" class="headerlink" title="（4）静态内部类"></a>（4）静态内部类</h4><p>就是把对象的实例放到静态内部类的静态变量上进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：静态内部类本身就是延迟加载，只有第一次访问时才会加载，根据类的加载过程，它内部的静态变量也只会初始化一次，所以也不存在线程安全问题。实现更加简单。</p><p>缺点：无法传参初始化。</p><p>记忆方式：有synchronized：懒汉式和双重检查锁。无synchronized：饿汉式和静态内部类实现</p><h3 id="6-场景题：让你设计一个在线题库系统你会如何去设计？"><a href="#6-场景题：让你设计一个在线题库系统你会如何去设计？" class="headerlink" title="6.场景题：让你设计一个在线题库系统你会如何去设计？"></a>6.场景题：让你设计一个在线题库系统你会如何去设计？</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><h4 id="技术栈选择"><a href="#技术栈选择" class="headerlink" title="技术栈选择"></a>技术栈选择</h4><p>既然是在线题库，那肯定要在数据库中存储响应的题目和标准答案，那么为了保证数据的持久性，存储在mysql中肯定更合适，但访问mysql的速度较慢，所以可以在redis中创建题目的缓存。还有就是，既然是题目，那么肯定要有题目搜索功能，这里我觉得可以使用es来实现题目的检索。对于带有图片的题目，可以通过minio来存储对应的图片。</p><h4 id="追问，表结构如何设计？"><a href="#追问，表结构如何设计？" class="headerlink" title="追问，表结构如何设计？"></a>追问，表结构如何设计？</h4><p>临场发挥吧</p><h3 id="7-平常在做项目的时候，发现你的逻辑方法突然不适用当前业务，你会怎么做？"><a href="#7-平常在做项目的时候，发现你的逻辑方法突然不适用当前业务，你会怎么做？" class="headerlink" title="7.平常在做项目的时候，发现你的逻辑方法突然不适用当前业务，你会怎么做？"></a>7.平常在做项目的时候，发现你的逻辑方法突然不适用当前业务，你会怎么做？</h3><h3 id="8-项目中的3难点以及你如何思考解决？"><a href="#8-项目中的3难点以及你如何思考解决？" class="headerlink" title="8.项目中的3难点以及你如何思考解决？"></a>8.项目中的3难点以及你如何思考解决？</h3><h3 id="9-项目中的压测如何操作的给出具体的数据？"><a href="#9-项目中的压测如何操作的给出具体的数据？" class="headerlink" title="9.项目中的压测如何操作的给出具体的数据？"></a>9.项目中的压测如何操作的给出具体的数据？</h3>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入java集合</title>
      <link href="/2025/08/15/%E6%B7%B1%E5%85%A5java%E9%9B%86%E5%90%88/"/>
      <url>/2025/08/15/%E6%B7%B1%E5%85%A5java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容概览"><a href="#一、内容概览" class="headerlink" title="一、内容概览"></a>一、内容概览</h1><p><img src="/../images/image-20250815180052814.png" alt="image-20250815180052814"></p><h1 id="二、算法复杂度"><a href="#二、算法复杂度" class="headerlink" title="二、算法复杂度"></a>二、算法复杂度</h1><p>要想深入学习集合的底层原理，就要先对复杂度的概念有个清晰的认知。</p><h2 id="（1）时间复杂度"><a href="#（1）时间复杂度" class="headerlink" title="（1）时间复杂度"></a>（1）时间复杂度</h2><p>时间复杂度表示了<strong>算法的执行时间与数据规模n之间的增长关系</strong>。</p><p>常见的时间复杂度：O(1)、O(n)、O(n^2)、O(logn)</p><p>速记口诀：<strong>常对幂指阶</strong></p><p><img src="/../images/image-20250815181257525.png" alt="image-20250815181257525"></p><h2 id="（2）空间复杂度"><a href="#（2）空间复杂度" class="headerlink" title="（2）空间复杂度"></a>（2）空间复杂度</h2><p>空间复杂度表示<strong>算法占用的额外存储空间和数据规模n之间的增长关系</strong>。</p><h1 id="三、List"><a href="#三、List" class="headerlink" title="三、List"></a>三、List</h1><h2 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="(1)数据结构"></a>(1)数据结构</h3><p>ArrayList底层使用数组来存储数据的。数组是一种用连续的内存空间存储相同数据类型的线性数据结构。</p><h3 id="2-基础问题"><a href="#2-基础问题" class="headerlink" title="(2)基础问题"></a>(2)基础问题</h3><h4 id="1-数组下标为什么从0开始"><a href="#1-数组下标为什么从0开始" class="headerlink" title="1.数组下标为什么从0开始"></a>1.数组下标为什么从0开始</h4><p>这就涉及到了数组元素的内存地址的计算问题了。</p><p>寻址公式 ：<strong>baseAddress + i * dataType</strong>，计算下标的内存地址速率高。</p><p>人话：基地址 + 索引下标 * 元素类型占用的空间大小</p><p>如果索引是从1开始，那么寻址公式就需要对（i-1），对于cpu来说，相当于多了一个减法指令。</p><h4 id="2-查找的时间复杂度"><a href="#2-查找的时间复杂度" class="headerlink" title="2.查找的时间复杂度"></a>2.查找的时间复杂度</h4><ul><li>随机(通过下标)查找的时间复杂度是O(1)</li><li>查找未知下标的元素的时间复杂度是O(n)</li><li>如果未知下标，但数组是排好序的，那么利用二分查找的时间复杂度是O(logn)</li></ul><h4 id="3-插入和删除的时间复杂度"><a href="#3-插入和删除的时间复杂度" class="headerlink" title="3.插入和删除的时间复杂度"></a>3.插入和删除的时间复杂度</h4><p>插入和删除的时间复杂度，在<strong>尾插和尾删的情况下是O(1)<strong>。这种情况下不需要</strong>挪动数组的其他元素</strong>。但它们的**平均复杂度均为O(n)**。</p><h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="(3)源码分析"></a>(3)源码分析</h3><p>分析源码主要从三方面进行分析：成员变量、构造函数和关键方法</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//指定容量为0时的使用到的空实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//使用默认的无参构造函数时创建的空实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//存放元素的数组对象</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">//数组元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><h5 id="区分两个空实例"><a href="#区分两个空实例" class="headerlink" title="区分两个空实例"></a>区分两个空实例</h5><p>关键看grow方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">//获取当前数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//如果数组长度&gt;0 又或者该ArrayList是通过有参构造器传入0值创建的一个暂未添加任何元素的空实例</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//容量扩充为1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">        <span class="comment">//拷贝旧数组元素至新容量数组</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//对于使用无参构造函数创建的ArrayList，在数组长度为0时，容量扩充为10</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取1.5倍容量大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">    <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">    <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"><span class="comment">//数组初始容量为0时，容量扩容为1，就是因为这里判断了容量差值和扩充容量的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// put code cold in a separate method</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，<strong>两个空实例主要区别就是在数组长度为0时，会使用的不同的扩容策略</strong>。使用无参构造器创建的对象，在第一次add元素时，容量直接扩充为10。对于使用有参构造函数创建的对象，扩容策略直接就是使用1.5倍扩容，即使传入的参数是0，也是1.5倍方式扩容为1。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//赋值 无参构造函数所以使用的空实例</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//赋值 有参构造函数传入容量为0时的空实例</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++; <span class="comment">//记录集合的修改次数，用于迭代过程中判断是否发生了并发修改</span></span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//grow方法详解在成员变量处</span></span><br></pre></td></tr></table></figure><h3 id="4-面试题"><a href="#4-面试题" class="headerlink" title="(4)面试题"></a>(4)面试题</h3><h4 id="ArrayList底层的实现原理是什么"><a href="#ArrayList底层的实现原理是什么" class="headerlink" title="ArrayList底层的实现原理是什么"></a>ArrayList底层的实现原理是什么</h4><ul><li><p>ArrayList底层是用<strong>动态数组</strong>实现的</p></li><li><p>ArrayList使用无参构造函数创建时，初始容量为0，当第一次添加元素时，容量扩充为10。</p></li><li><p>而当使用有参构造函数创建时，初始容量为传入的容量值。</p></li><li><p>无参第一次扩容之后和有参每次扩容都是扩容为原来大小的1.5倍。</p></li><li><p>ArrayList在添加元素时</p><p>会确保数组已使用长度加1之后足够存放下一个数据。</p><p>如果已使用长度加1大于当前数组容量，则调用grow()方法进行1.5倍扩容。</p><p>添加成功之后就会返回布尔值。</p></li></ul><h4 id="ArrayList-list-new-ArrayList-10-中list会扩容几次"><a href="#ArrayList-list-new-ArrayList-10-中list会扩容几次" class="headerlink" title="ArrayList list &#x3D; new ArrayList(10)中list会扩容几次"></a>ArrayList list &#x3D; new ArrayList(10)中list会扩容几次</h4><p>扩容0次，看有参构造函数的具体实现就知道了，是直接创建一个对应容量的数组进行赋值，根本没进行扩容。</p><h4 id="如何实现数组和List之间的转换"><a href="#如何实现数组和List之间的转换" class="headerlink" title="如何实现数组和List之间的转换"></a>如何实现数组和List之间的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//数组转list,使用Arrays工具类的asList方法</span></span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    List&lt;Integer&gt; list1 = Arrays.asList(arr);</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; list2 = Arrays.asList(a); <span class="comment">//因为int类型不属于引用类型，所以把整个int数组作为元素类型了</span></span><br><span class="line"><span class="comment">//list转数组,使用toArray方法</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Object[] array = list.toArray(); <span class="comment">//无参，返回一个Object数组</span></span><br><span class="line">    Integer[] array1 = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>]); <span class="comment">//有参，返回传入的数组对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="追问，用Arrays-asList转List后，如果修改了数组内容，list受影响吗？"><a href="#追问，用Arrays-asList转List后，如果修改了数组内容，list受影响吗？" class="headerlink" title="追问，用Arrays.asList转List后，如果修改了数组内容，list受影响吗？"></a>追问，用Arrays.asList转List后，如果修改了数组内容，list受影响吗？</h5><p>受影响，asList是把原数组作为List的动态数组，也就是List的数组引用的是原来的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line">ArrayList(E[] array) &#123;</span><br><span class="line">a = Objects.requireNonNull(array); <span class="comment">//判断数组是否为null，不为null则直接引用，为null则跑异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="List用toArray转数组之后，如果修改了list内容，数组受影响吗？"><a href="#List用toArray转数组之后，如果修改了list内容，数组受影响吗？" class="headerlink" title="List用toArray转数组之后，如果修改了list内容，数组受影响吗？"></a>List用toArray转数组之后，如果修改了list内容，数组受影响吗？</h5><p>不受影响，因为toArray其实是把list中的数组进行了拷贝并返回的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">//返回一个相同容量的拷贝数组</span></span><br><span class="line"><span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">//把list中的数组元素拷贝到传入的数组对象上</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h2><h3 id="1-数据结构-1"><a href="#1-数据结构-1" class="headerlink" title="(1)数据结构"></a>(1)数据结构</h3><p>LinkedList底层使用的是<strong>双向链表</strong>的数据结构。</p><p>对于传入LinkedList的每个元素，都会封装到Node对象上。Node对象包含了存储元素和前后驱指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="(2)源码分析"></a>(2)源码分析</h3><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾节点</span></span><br></pre></td></tr></table></figure><p>LinkedList底层就是基于节点的操作，没什么好分析的，所以就先不写了</p><h3 id="3-面试题"><a href="#3-面试题" class="headerlink" title="(3)面试题"></a>(3)面试题</h3><h4 id="ArrayList跟LinkedList的区别是什么"><a href="#ArrayList跟LinkedList的区别是什么" class="headerlink" title="ArrayList跟LinkedList的区别是什么"></a>ArrayList跟LinkedList的区别是什么</h4><h5 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h5><p>ArrayList使用<strong>动态数组</strong>，LinkedList使用<strong>双向链表</strong></p><h5 id="2-操作效率"><a href="#2-操作效率" class="headerlink" title="2.操作效率"></a>2.操作效率</h5><p>增删改查的时间复杂度角度</p><p>对于查询来说，ArrayList可以使用下标来查询，时间复杂度是O(1)。当未知下标时，ArrayList和LinkedList一样都是O(n)。</p><p>对于增删来说，两者基于头尾时间复杂度都是O(1)。其他情况，由于ArrayList增删元素需要挪动数组，Linked需要顺序遍历，所以两者一样都是O(n)。</p><h5 id="3-占用空间"><a href="#3-占用空间" class="headerlink" title="3.占用空间"></a>3.占用空间</h5><p>LinkedList占用空间更大，因为每个元素都存储了前后驱节点指针。</p><h5 id="4-线程是否安全"><a href="#4-线程是否安全" class="headerlink" title="4.线程是否安全"></a>4.线程是否安全</h5><p><strong>两者线程都不安全</strong>。</p><p>如果需要保证线程安全，有两种方案：</p><p>第一种，<strong>在方法内使用</strong>来直接避免，因为局部变量是线程安全的。</p><p>第二种，使用线程安全的ArrayList和LinkedList。即使用<strong>Collections工具类的synchronizedList方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objects = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">List&lt;Object&gt; objects1 = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><p>synchronizedList方法底层就是给方法添加synchronized悲观锁来保证的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="comment">// Conditionally serializable</span></span><br><span class="line"><span class="keyword">final</span> List&lt;E&gt; list; <span class="comment">//传入的list对象</span></span><br><span class="line"><span class="keyword">final</span> Object mutex;     <span class="comment">// Object on which to synchronize</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Map"><a href="#四、Map" class="headerlink" title="四、Map"></a>四、Map</h1><h2 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h2><h3 id="1-数据结构-2"><a href="#1-数据结构-2" class="headerlink" title="(1)数据结构"></a>(1)数据结构</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>又名二叉查找树、有序二叉树或者排序二叉树。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>树的任意一个节点，<strong>其左节点的值小于当前节点值，右节点的值大于当前节点值，没有键值（节点值）相同的节点</strong></p><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>**通常情况下时间复杂度为O(logn)<strong>，但最坏情况就是，如果二叉搜索树退化成了链表，</strong>也就是左右子树极度不平衡的情况下，时间复杂度为O(n)**。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>也叫自平衡的二叉搜索树。</p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ol><li>节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>叶子节点是黑色的空节点</li><li>红色节点的子节点都是黑色</li><li>从任一节点到它的后代叶子节点的所有路径上，黑色节点数目相同</li></ol><p>这5个特点本质上就是用来保证二叉树的平衡。</p><p>当规则被打破时，通过颜色翻转和左旋右旋来恢复规则。</p><p><img src="/../images/image-20250816004436535.png" alt="image-20250816004436535"></p><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表，又名哈希表。是根据键（key）直接访问在内存存储位置值（value）的数据结构。由数组演化而来，利用率数组支持按照下标随机访问数据的特点。</p><h5 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h5><p>又名哈希冲突，指多个key映射到同一个数组的下标位置的情况。</p><p>解决方法：链表法。</p><p>数组的每个下标位置称为桶或者槽。每个桶会对应一个链表。hash冲突后的元素都放到相同槽位对应的链表中或者红黑树中。</p><h3 id="2-源码分析-1"><a href="#2-源码分析-1" class="headerlink" title="(2)源码分析"></a>(2)源码分析</h3><h4 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化的数组容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的负载因子大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//转化为红黑树时的所需的链表长度阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//红黑树退化为链表时的节点数阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//转化为红黑树时的所需的数组容量阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="comment">//节点对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他方法略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//node类型的数组，存放链表或者hash表的头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//缓存entrySet()方法的放回值</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">//键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>Hashmap的数组是懒加载，只有第一次put时才会初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用默认的负载因子</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY; <span class="comment">//容量不能超过最大值</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) <span class="comment">//负载因子不能为空或者小于等于0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor; </span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算大于等于给定容量大小的最小的2的幂次，确保数组大小为2的幂次</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键方法-1"><a href="#关键方法-1" class="headerlink" title="关键方法"></a>关键方法</h4><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//onlyIfAbsent:是否仅在键不存在的情况下才插入值。evict:控制是否启用驱逐机制</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//第一次put时，数组初始化。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//将（数组容量-1）和key的hash值进行与运算得到下标，如果下标对应的元素为null,则直接添加该节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//否则进行key判断后,进行value替换或者添加节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//key相同，则直接进行value替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果首元素节点p是红黑树节点，则走红黑树添加节点方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//走链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//获取当前节点的下一个节点，并进行判断</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//e为null值，添加至链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//若添加节点前，链表元素个数已经大于等于7了，则试着转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//key相同，进行value替换</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//大于扩容阈值，就进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//数组长度大于等于64阈值时，才可以转化为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();  <span class="comment">//扩容</span></span><br><span class="line">    <span class="comment">//计算要转化为红黑树的链表，在数组中的下标</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//构建双向链表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//通过头节点进行树化，构建红黑树</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">//右移16位后进行&amp;运算，扰动算法，让hash值分布更均匀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//容量安全校验</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由带初始容量的构造函数可知，初始化容量是存放在了threadshold，所以这里才把threadshold赋值给了newCap</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//无初始容量构造函数创建的对象，使用默认的初始化容量大小</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新的扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新的扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//处理每个桶中的元素</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//没有hash冲突，则计算新的索引位置后直接添加到新的数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是红黑树，则走红黑树添加</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//否则，是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//为0，则将当前节点添加到loHead所在的链表中</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//为1，将当前节点添加到hiHead所在的链表中</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// loHead停留在原始位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// hiHead移动到原始位置 + oldCap的位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-面试题-1"><a href="#3-面试题-1" class="headerlink" title="(3)面试题"></a>(3)面试题</h3><h4 id="说下HaspMap的实现原理"><a href="#说下HaspMap的实现原理" class="headerlink" title="说下HaspMap的实现原理"></a>说下HaspMap的实现原理</h4><p>HashMap底层使用的是hash表数据结构，就是数组+链表&#x2F;红黑树。</p><p>添加数据时，会通过计算key的hash值来确定元素在数组中的下标。当链表或者红黑树的中的元素key和当前key相同的话，就会进行value替换，不同的话，就会存入链表或者红黑树中。</p><h4 id="HashMap的jdk1-7和jdk1-8有什么区别"><a href="#HashMap的jdk1-7和jdk1-8有什么区别" class="headerlink" title="HashMap的jdk1.7和jdk1.8有什么区别"></a>HashMap的jdk1.7和jdk1.8有什么区别</h4><p>JDK1.8之前采用的是拉链法，就是数组+链表。</p><p>JDK1.8及以后使用的是数组+链表&#x2F;红黑树的形式。当链表长度大于8且数组长度大于64，就会把链表转化为红黑树。当扩容时，如果红黑树的结构个数小于等于临界值6时，就会退化成链表。</p><h4 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a>HashMap的put方法的具体流程</h4><ol><li><p>HashMap的table数组是懒加载，所以第一次put才会进行初始化。</p></li><li><p>判断键值对数组table是否为空或为null,执行resize()进行扩容（初始化）。</p></li><li><p>根据键值key计算hash值得到数组索引。</p></li><li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加。</p><p>如果table[i]!&#x3D;null,则进行判断</p><p>先判断table[i]的首个元素是否和key一样，如果相同则直接覆盖value</p><p>否则再判断节点类型是否是TreeNode,如果是，则说明是红黑树，那么就在红黑树中进行节点判断和添加。</p><p>否则就是链表，那么遍历整个链表，有key相同的节点，就进行value替换，不然就尾插。尾插完成之后，会判断是否需要转化为红黑树，先进行链表节点个数的阈值判断，再进行数组长度的阈值判断，决定是否将该链表转化为红黑树。</p></li></ol><p>5.插入完成之后，会判断当前节点个数是否大于扩容阈值，如果大于就进行扩容。</p><h4 id="HashMap的resize方法的具体流程"><a href="#HashMap的resize方法的具体流程" class="headerlink" title="HashMap的resize方法的具体流程"></a>HashMap的resize方法的具体流程</h4><p>HashMap的数组是懒加载模式，在第一次put时，就会调用resize方法来进行数组初始化，如果在构造HashMap时，传入了初始化大小，就初始化为大于等于大小的2的幂次，否则使用默认初始化大小16对数组进行初始化。</p><p>以后每次扩容都是在容量到达了扩容阈值（数组长度*0.75）时进行扩容，每次扩容的时候，都是扩容前容量的2倍。</p><p>扩容之后，会创建一个新的数组，需要把老数组中的数据挪动到新的数组中。</p><p>没有hash冲突的节点，则直接使用e.hash &amp;(newCap-1)计算新数组的索引位置。</p><p>如果是红黑树，则走红黑树的添加。</p><p>如果是链表，则需要遍历链表，判断链表中的每个元素的hash &amp; oldCap的值是否为0，若为0，则该位置的元素要么停留在原始位置，要么移动到原始位置+增加的数组大小的这个位置上。</p><h4 id="HashMap的寻址算法"><a href="#HashMap的寻址算法" class="headerlink" title="HashMap的寻址算法"></a>HashMap的寻址算法</h4><p>计算对象的HashCode()</p><p>再<strong>调用hash方法进行二次哈希</strong>，就是hashcode值右移16位再进行异或运算，让哈希分布更为均匀</p><p>最后通过（capacity-1）&amp; hash 得到索引</p><h4 id="为什么HashMap数组的长度一定是2的次幂"><a href="#为什么HashMap数组的长度一定是2的次幂" class="headerlink" title="为什么HashMap数组的长度一定是2的次幂"></a>为什么HashMap数组的长度一定是2的次幂</h4><p>因为这样子计算索引的效率更高，如果是2的n次幂，可以使用位与运算代替取模</p><p>扩容时，重新计算索引效率更高，hash&amp;oldCap &#x3D;&#x3D; 0 的元素留在原来位置，否则新位置&#x3D;旧位置 + oldCap</p><h4 id="HashMap在jdk1-7情况下的多线程死循环问题"><a href="#HashMap在jdk1-7情况下的多线程死循环问题" class="headerlink" title="HashMap在jdk1.7情况下的多线程死循环问题"></a>HashMap在jdk1.7情况下的多线程死循环问题</h4><p><img src="/../images/image-20250816205238537.png" alt="image-20250816205238537"></p><p>jdk1.7的hashMap在数组进行扩容的时候，因为链表是采用头插法，如果有多个线程对hashMap进行扩容，在数据迁移过程中有可能导致死循环问题。</p><p>比如说，有两个线程1和2</p><p>线程1，读取到hashmap的数据，在准备扩容时，</p><p>线程2介入，线程2先进行了扩容，对数据进行了迁移，由于采用头插法，比如原来链表的顺序是A-&gt;B，扩容之后的顺序是B-&gt;A，线程2执行结束。</p><p>此时，线程1再去扩容就会出现死循环问题。</p><p>线程1先将A移入新链表，然后B又插入到链表头。由于线程2的介入，导致B的next不是null,而是A，导致A又重新插入到链表头，从而出现了A -&gt; B -&gt; A的死循环引用。</p><p><img src="/../images/image-20250816205242556.png" alt="image-20250816205242556"></p><h2 id="2-ConcurrentHashMap"><a href="#2-ConcurrentHashMap" class="headerlink" title="2.ConcurrentHashMap"></a>2.ConcurrentHashMap</h2><h3 id="1-数据结构-3"><a href="#1-数据结构-3" class="headerlink" title="(1)数据结构"></a>(1)数据结构</h3><p>ConcurrentHashMap在JDK1.7及以前采用分段数组+链表实现。</p><p>分段数组叫做Segment数组，它是默认<strong>固定</strong>长度为16的数组，也可以指定。每个Segment元素（继承了Reentrantlock）内部维护了一个数组，叫做HashEntry数组，但这个数组可扩容，且会通过链表连接相同索引下的元素。当多个线程往同个Segment元素维护的数组添加数据时，需要通过ReentrantLock的tryLock方式获取当前元素的锁，只有获取到锁的线程才可以往该节点指向的数组中添加元素，其他线程会通过CAS进行自旋获取。</p><p><img src="/../images/image-20250821202042754.png" alt="image-20250821202042754"></p><p>JDK1.8及以后，采用跟HashMap一样的数据结构，数组+链表&#x2F;红黑树。去掉Segment数组这个臃肿的设计。</p><h3 id="2-源码分析-2"><a href="#2-源码分析-2" class="headerlink" title="(2)源码分析"></a>(2)源码分析</h3><p>put方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组该位置=null,通过CAS来添加元素</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//为了实现putIfAbsent()方法而引入的，如果onlyIfAbsent为true,那么当首节点key相同，且对应val不为null时，返回旧值，不进行添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//使用synchronized锁住首节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//如果onlyIfAbsent==false，才允许替换</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//走红黑树节点的遍历判断，进行节点替换或者添加</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk1.7ConcurrentHashMap源码简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的JDK 1.7 ConcurrentHashMap结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">// 分段数组，默认大小为16</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Segment类继承ReentrantLock，本身就是一种锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">        <span class="comment">// 每个Segment内部维护一个HashEntry数组</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">        <span class="comment">// 其他字段...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据的节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// 构造函数等...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-面试题-2"><a href="#3-面试题-2" class="headerlink" title="(3)面试题"></a>(3)面试题</h3><h4 id="聊下ConcurrentHashMap"><a href="#聊下ConcurrentHashMap" class="headerlink" title="聊下ConcurrentHashMap"></a>聊下ConcurrentHashMap</h4><h5 id="1-底层数据结构-1"><a href="#1-底层数据结构-1" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h5><p>jdk1.7采用分段数组+链表实现</p><p>jdk1.8采用跟HashMap一样的数据结构，数组+链表&#x2F;红黑树</p><h5 id="2-加锁方式"><a href="#2-加锁方式" class="headerlink" title="2.加锁方式"></a>2.加锁方式</h5><p>jdk1.7采用<strong>分段锁</strong>(Segment数组元素本身就继承了ReentrantLock)，使用的是ReentrantLock。</p><p>Jdk1.8在<strong>数组对应元素为null值时，使用CAS来添加新节点</strong>，<strong>元素不为null时，采用synchronized锁定链表或者红黑树的首节点</strong></p><p>Segment分段锁，锁的是一个数组+链表的数据结构；而synchronized方式，锁的是一个链表或者红黑树，<strong>锁的粒度更细，性能更好。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发常见问题汇总</title>
      <link href="/2025/07/11/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2025/07/11/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、项目环境搭建"><a href="#一、项目环境搭建" class="headerlink" title="一、项目环境搭建"></a>一、项目环境搭建</h2><p>每次创建项目时，都要借鉴已有的项目依赖和配置文件进行创建，依赖用于什么功能的，以及配置文件作用于哪些依赖的，都云里雾里的。为此，写一个通用的环境搭建的博客就方便我创建新项目，需要引入什么常见依赖就看看这篇博客，顺便看看依赖之间的关系和配置文件的使用，(●’◡’●)。</p><h3 id="1-1-SpringBoot依赖"><a href="#1-1-SpringBoot依赖" class="headerlink" title="1.1 SpringBoot依赖"></a>1.1 SpringBoot依赖</h3><p>以maven创建的项目为例，仅需基础springboot父工程，然后引入启动器和测试依赖即可。</p><p>注意：springboot父工程定义了很多需要使用的依赖版本，故部分依赖版本号无需手动指定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--继承springboot父工程--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web启动器依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--测试依赖，包含了常用测试框架和工具，如Junit, SpringTest等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Mysql环境"><a href="#1-2-Mysql环境" class="headerlink" title="1.2 Mysql环境"></a>1.2 Mysql环境</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器，是spring Boot 操作数据库的基础模块, 包含Jdbctemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid连接池的依赖 （如果要替换mysql默认连接池的话可以加） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接 MySQL 所需驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相关配置文件设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="comment"># 使用druid连接池</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/steel</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="1-3-Mybatis依赖"><a href="#1-3-Mybatis依赖" class="headerlink" title="1.3 Mybatis依赖"></a>1.3 Mybatis依赖</h3><p>二选一即可正常使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--MyBatis Plus 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相关配置文件设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mybatis配置， 彻底抛弃mybatis-config.xml文件</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span>  <span class="comment">#指定mapper的xml文件的位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.ldy.bean</span>  <span class="comment">#设置包下实体类别名为类名，无需全类名</span></span><br><span class="line">  <span class="attr">configuration:</span> <span class="comment"># setting设置</span></span><br><span class="line">    <span class="attr">auto-mapping-behavior:</span> <span class="string">full</span> <span class="comment">#自动映射，full表示可以嵌套映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#开启驼峰式命名法</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span> <span class="comment">#开启日志输出</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.ldy.mapper:</span> <span class="string">debug</span>  <span class="comment"># 如果在控制台想看到sql语句执行的日志，那么就配置mapper接口所在包日志级别为debug</span></span><br><span class="line">    <span class="attr">org.springframework.transaction:</span> <span class="string">debug</span>  <span class="comment">#如果想看事务开始、提交、回滚等信息，可以设置这个</span></span><br><span class="line">    <span class="attr">org.mybatis:</span> <span class="string">debug</span> <span class="comment">#可以看到 MyBatis 内部行为细节，比如如何解析 SQL、如何映射结果集等</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-4-工具类依赖"><a href="#1-4-工具类依赖" class="headerlink" title="1.4 工具类依赖"></a>1.4 工具类依赖</h3><p>经常用到的工具类依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- lombok依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-Mongdb依赖"><a href="#1-5-Mongdb依赖" class="headerlink" title="1.5 Mongdb依赖"></a>1.5 Mongdb依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Mongodb依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">database:</span> <span class="string">articledb</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经记录</title>
      <link href="/2025/06/12/%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/06/12/%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-处女面-行觅科技"><a href="#1-处女面-行觅科技" class="headerlink" title="1.处女面-行觅科技"></a>1.处女面-行觅科技</h2><p>初创型公司</p><p>时间：2025&#x2F;6&#x2F;12 20:00</p><p>（1）自我介绍</p><p>（2）个人学习项目选择的目的</p><p>（3）elasticsearch的搜索原理</p><p>（4）场景：订单如果要存储在elasticsearch中，那么订单状态字段适合用什么数据类型。——考察es的数据类型，但我忘了</p><p>（5）mysql的慢查询定位</p><p>（6）mysql中B+的实现和优缺点</p><p>（7）最左匹配原则</p><p>（8）mybatis的实现原理 ——学习过，但忘记了</p><p>（9）mybatis-plus和mybatis的区别，以及取舍，什么情况下适合用mp,什么情况不适合。</p><p>（10）linux中搜索日志的命令</p><p>（11）个人提问 </p><p>总结：面试官很好，很热心为我解答不会的地方。但我回答的依托，说明了我的不足之处，需要举一反三，考虑技术的优缺点。挂了。</p><h2 id="2-开斧市"><a href="#2-开斧市" class="headerlink" title="2.开斧市"></a>2.开斧市</h2><p>时间：2025&#x2F;6&#x2F;16 15:15</p><p>（1）vue熟悉吗 ——了解过</p><p>（2）讲讲阻塞队列</p><p>（3）讲讲CountDownLatch</p><p>（4）讲讲Spring的AOP，什么作用，底层实习（两种动态代理）</p><p>（5）Mysql中LEFT JOIN和RIGHT JOIN</p><p>（6）Mysql的存储引擎innodb和mysaim的区别</p><p>（7）java的值传递和引用传递</p><p>（8）HTTP和HTTPS的区别，TCP和HTTP的区别？（没学过，计网还没学，我平常也没学习过）</p><p>总结：答得依托。问的有点奇怪。太突然了，脑袋昏沉的，细节忘了。</p><h3 id="java中值传递和引用传递区分："><a href="#java中值传递和引用传递区分：" class="headerlink" title="java中值传递和引用传递区分："></a>java中值传递和引用传递区分：</h3><h4 id="什么是值传递，什么是引用传递？"><a href="#什么是值传递，什么是引用传递？" class="headerlink" title="什么是值传递，什么是引用传递？"></a>什么是值传递，什么是引用传递？</h4><p>1.引用传递：</p><ul><li>在引用传递中，方法参数接收的是变量的地址（引用），而不是变量的值。</li><li>如果在方法内部修改了传递的参数，这个修改会影响到方法外部的原变量。</li><li>引用传递允许在方法内通过引用直接操作原始数据。</li></ul><p>2.值传递：</p><ul><li>在值传递中，方法参数接收的是变量的值的拷贝，而不是变量本身。</li><li>如果在方法内部修改了传递的参数，这个修改不会影响到方法外部的原变量。</li><li>值传递将参数的实际值传递给方法，使得方法内部无法直接访问原变量的地址。</li></ul><h4 id="java里为什么只有值传递？"><a href="#java里为什么只有值传递？" class="headerlink" title="java里为什么只有值传递？"></a>java里为什么只有值传递？</h4><p>首先，在java中，引用类型变量实际上存储的是引用对象的地址，而不是对象本身。</p><p>在作为方法参数进行传递时，会将变量的值，也就是引用地址传递给方法参数。这与值传递的概念相吻合。所以，尽管对于引用传参，方法接收到的是引用地址，但它实际上是通过值传递的方式进行传递的。</p><h4 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h4><p>嗯，java里实际上是只有值传递。这里有个误区，就是部分观点认为引用类型是引用传递，这个看法是从对象角度理解的，就是引用类型对象进行参数传递时，因为方法内部的引用变量和原变量指向都是同一个对象，导致方法内部对引用变量的修改会反映到原变量上，所以认为java里的引用类型是引用传递，但这个说法并不准确，因为当给方法内的引用变量重新赋值指向一个新的变量时，对这个变量的修改就不会影响到原变量上。而在方法参数传递的角度来看，引用类型就是值传递。因为<strong>引用类型变量存储的是对象的存放地址，而不是对象本身，在传递给方法时，方法接收的就是变量的值的拷贝，也就是对象存放地址的拷贝，从这一角度看，引用类型就是值传递的</strong>。</p><h2 id="3-杭州磐太科技"><a href="#3-杭州磐太科技" class="headerlink" title="3.杭州磐太科技"></a>3.杭州磐太科技</h2><p>20-99人</p><p>时间：2025&#x2F;8&#x2F;15 14:00</p><p>（1）java基本数据类型</p><p>8种，byte、short、int、long、float、double、boolean、char</p><p>byte忘记了，有点尬</p><p>（2）包装类型的缓存</p><p>（3）java集合有哪些，哪些是线程安全的</p><p>集合这块还没系统学习过，线程安全的类只答了个concurrentHashMap</p><p>（4）springIoc和DI</p><p>（5）springBoot自动装配原理</p><p>（6）springmvc工作流程</p><p>没去记过，不会</p><p>（7）controller层常用注解</p><p>（8）bean的生命周期</p><p>（9）mysql有哪些索引类型</p><p>这个没答全</p><p>数据结构：B+Tree索引、Hash索引、R-Tree索引（空间索引）、Full-Text索引（倒排索引）</p><p>逻辑功能：主键索引、唯一索引、普通索引、联合索引、前缀索引</p><p>（10）mysql执行一条sql的执行流程</p><p>（11）四大隔离级别</p><p>（12）什么隔离级别会出现幻读问题</p><p>（13）redis基本数据类型</p><p>（14）redis的持久化策略</p><p>（15）最近最熟悉的项目，项目的业务闭环，开头到结尾怎么进行逻辑处理，就是业务流程。</p><p>这个真的讲不来啊，一个学习的项目，顶多就是实现功能，哪会去想闭环啊。</p><p>（16）项目的身份校验权限怎么实现的</p><p>（17）项目中的redis做什么用的</p><p>（18）redis的热点数据怎么处理</p><p>（19）反问</p><p>面试官说：知识点还是比较全面的，就是还是太紧张了</p><p>总结：</p><p>大部分都答得上来了，比前两次好些，但是还是太紧张了！！！答完之后半小时就打来电话说面试通过了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程</title>
      <link href="/2025/06/01/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/06/01/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="IP："><a href="#IP：" class="headerlink" title="IP："></a>IP：</h3><ul><li><p>用于标记计算机设备,是分配给上网设备的唯一标志。</p></li><li><p>有两种形式：IPv4和IPv6。</p><p>IPv4:</p><p>一共32位，分成四段表示。每段用十进制标志。</p><p>IPv6:</p><p>一共128位，分成八段表示，每段每四位编码成一个十六进制位表示，数之间用冒号分开。</p></li></ul><p><img src="/../images/image-20250601215225001.png" alt="image-20250601215225001"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取主机ip</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost.getHostName());</span><br><span class="line">System.out.println(localHost.getHostAddress());</span><br><span class="line"><span class="comment">//2.获取域名ip</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">ip2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.zhihu.com&quot;</span>);</span><br><span class="line">System.out.println(ip2.getHostName());</span><br><span class="line">System.out.println(ip2.getHostAddress());</span><br><span class="line"><span class="comment">//ping www.zhihu.com</span></span><br><span class="line">System.out.println(ip2.isReachable(<span class="number">6000</span>)); <span class="comment">//6000ms内是否能ping通</span></span><br></pre></td></tr></table></figure><p>执行结果：<img src="/../images/image-20250604001034385.png" alt="image-20250604001034385"></p><h3 id="端口："><a href="#端口：" class="headerlink" title="端口："></a>端口：</h3><p>用于标记计算机设备上运行的应用程序，被规定为一个16位的二进制，范围是0~65535。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="1-UDP（用户数据报协议）"><a href="#1-UDP（用户数据报协议）" class="headerlink" title="1.UDP（用户数据报协议）"></a>1.UDP（用户数据报协议）</h4><p>特点：无连接、不可靠通信</p><p>解释：无连接指的是数据传输之前不事先建立连接。不可靠通信指的是发送端每次把发送的数据(不超过64KB)、接收端IP等信息封装成一个数据包，把这个数据包发出去后就不管了。管它接收端有没有接收到。</p><p>java涉及api:</p><p><img src="/../images/image-20250604001253097.png" alt="image-20250604001253097"></p><p>案例</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.创建服务端对象，端口6666</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建数据包对象用于接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">//设置接收的数据包的大小，固定的</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.接收数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            <span class="comment">//4.获取客户端信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">clientAddress</span> <span class="operator">=</span> packet.getAddress().getHostAddress();</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> packet.getPort();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到客服端：&quot;</span>+clientAddress+<span class="string">&quot;:&quot;</span>+port+<span class="string">&quot;的消息&quot;</span>);</span><br><span class="line">            <span class="comment">//5.得到数据,由于数据包大小固定，但实际获取到的数据填满bytes，所以需要切片</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength(); <span class="comment">//获取客户端发送数据的字节长度</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, length));</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源 socket.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象,未指明端口则随机分配</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//2.创建数据包，封装要发送出去的数据</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">         *         InetAddress address, int port)</span></span><br><span class="line"><span class="comment">         * 参数一：要发送出去的数据</span></span><br><span class="line"><span class="comment">         * 参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">         * 参数三：服务端IP地址</span></span><br><span class="line"><span class="comment">         * 参数四：服务端端口号</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送的信息：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="type">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length,</span><br><span class="line">                    InetAddress.getLocalHost(), <span class="number">6666</span>);</span><br><span class="line">            <span class="comment">//3.发送数据包</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源 socket.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250604005050392.png" alt="image-20250604005050392"></p><p><img src="/../images/image-20250604004925717.png" alt="image-20250604004925717"></p><h4 id="2-TCP（传输控制协议）"><a href="#2-TCP（传输控制协议）" class="headerlink" title="2.TCP（传输控制协议）"></a>2.TCP（传输控制协议）</h4><p>特点：面向连接、可靠通信</p><p>解释：通信前，双方会先采用<strong>三次握手</strong>的方式建立可靠连接，然后再实现端到端的通信；底层能保证数据成功传给服务端。</p><h5 id="多发多收—一服务端一客户端"><a href="#多发多收—一服务端一客户端" class="headerlink" title="多发多收—一服务端一客户端"></a>多发多收—一服务端一客户端</h5><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，并为其注册端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//2.使用serverSocket对象，调用accept方法，等待客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//3.从socket通信管道中获取一个字节输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.包装成数据流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">        <span class="comment">//5.获取数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端地址&quot;</span>+socket.getRemoteSocketAddress());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+<span class="string">&quot;离线了&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">                dis.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TCPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        //1.创建Socket对象，它默认是由TCP传输协议,host和port是收数据的服务端</span><br><span class="line">        Socket socket = new Socket(&quot;localhost&quot;, 6666);</span><br><span class="line">        //2.从Socket通信管道中得到一个字节输出流</span><br><span class="line">        OutputStream os =socket.getOutputStream();</span><br><span class="line">        //3.把低级的字节输出流包装成数据输出流</span><br><span class="line">        DataOutputStream dos = new DataOutputStream(os);</span><br><span class="line"></span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        //4.写数据</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            String msg = sc.nextLine();</span><br><span class="line">            if(msg.equals(&quot;exit&quot;))&#123;</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            //将缓冲区的数据立即写入到目标设备,确保消息能立即发送给服务端</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的案例因为只有一个线程来处理请求，所以无法应多个客户端同时发起连接的情况。所以我们可以使用多线程来处理，服务端主线负责异步线程的创建。</p><h5 id="支持一服务端与多客户端同时通信"><a href="#支持一服务端与多客户端同时通信" class="headerlink" title="支持一服务端与多客户端同时通信"></a>支持一服务端与多客户端同时通信</h5><p>测试时，记得给在idea中设置客户端可以多开</p><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，并为其注册端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//2.使用serverSocket对象，调用accept方法，等待客户端连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">            <span class="comment">//3.得到连接后，创建异步线程来处理socket</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TCPReadThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义异步线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP异步获取消息线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPReadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCPReadThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.从socket通信管道中获取一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//2.包装成数据流</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="comment">//3.获取数据</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;消息:&quot;</span> + msg);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了&quot;</span>);</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取输入流异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象，它默认是由TCP传输协议,host和port是收数据的服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//2.从Socket通信管道中得到一个字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span>socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//4.写数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(msg.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎您下次光临&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            <span class="comment">//将缓冲区的数据立即写入到目标设备,确保消息能立即发送给服务端</span></span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="即时通讯—群聊"><a href="#即时通讯—群聊" class="headerlink" title="即时通讯—群聊"></a>即时通讯—群聊</h5><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象，它默认是由TCP传输协议,host和port是收数据的服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 创建消息接收的异步线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClientReadThread</span>(socket).start();</span><br><span class="line">        <span class="comment">//2.从Socket通信管道中得到一个字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span>socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//4.写数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(msg.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎您下次光临&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            <span class="comment">//将缓冲区的数据立即写入到目标设备,确保消息能立即发送给服务端</span></span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端消息获取线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientReadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientReadThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(<span class="string">&quot;聊天室：&quot;</span> + msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Socket&gt; onLineSocket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，并为其注册端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//2.使用serverSocket对象，调用accept方法，等待客户端连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入到在线socket集合中</span></span><br><span class="line">            onLineSocket.add(socket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.得到连接后，创建异步线程来处理socket</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServiceReadThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端消息获取线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceReadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceReadThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">            sendToAllClient(socket.getRemoteSocketAddress() + <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">            <span class="comment">//1.从socket通信管道中获取一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//2.包装成数据流</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="comment">//3.获取数据</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                String msg;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    msg = dis.readUTF();</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;消息:&quot;</span> + msg);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了&quot;</span>);</span><br><span class="line">                    sendToAllClient(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了&quot;</span>);</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//消息分发给其他客户端</span></span><br><span class="line">                sendToAllClient(socket.getRemoteSocketAddress() + <span class="string">&quot;: &quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取输入流异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从在线socket中移除</span></span><br><span class="line">        TCPService.onLineSocket.remove(socket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendToAllClient</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">for</span> (Socket sc : TCPService.onLineSocket) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!sc.getRemoteSocketAddress().toString().equals(socket.getRemoteSocketAddress().toString()))&#123;</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> sc.getOutputStream();</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">                <span class="comment">//发送至其他客户端的消息管道</span></span><br><span class="line">                dos.writeUTF(msg);</span><br><span class="line">                dos.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BS架构请求"><a href="#BS架构请求" class="headerlink" title="BS架构请求"></a>BS架构请求</h5><p>浏览器也可以对本地开放的端口进行访问，这时就不要客户端了，但返回给浏览器的数据必须要严格按照浏览器请求的协议接收的数据格式进行返回。</p><p><img src="/../images/image-20250821152219269.png" alt="image-20250821152219269"></p><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPService</span> &#123;</span><br><span class="line">    <span class="comment">//使用线程池对线程进行管理，避免线程资源耗尽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1000</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//获取浏览器的socket连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">//将socket连接交给线程池进行处理</span></span><br><span class="line"><span class="comment">//            pool.submit(new ServerReadThread(socket));</span></span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ServerReadThread</span>(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端获取数据线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReadThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;发起请求&quot;</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//为了按照浏览器请求协议格式，使用打印流进行包装</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">//必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size=16px;text-align:center&#x27;&gt; ldy你好 &lt;/div&gt;&quot;</span>);</span><br><span class="line">            <span class="comment">//浏览器一般是短连接，浏览器发起请求，服务端响应请求之后连接就结束了，所以这种情况下就可以直接close了</span></span><br><span class="line">            ps.close();<span class="comment">//及时释放系统资源</span></span><br><span class="line">            socket.close();<span class="comment">//及时释放系统资源</span></span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;请求已关闭&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、面试知识"><a href="#二、面试知识" class="headerlink" title="二、面试知识"></a>二、面试知识</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手：<strong>为了确保双方收发消息都没问题</strong>。</p><p>假设客户端发出连接请求</p><p>第一次握手：客户端发出连接请求，服务端收到请求后，知道客户端发消息没问题。</p><p>第二次握手：服务端返回一个响应。客户端收到响应后，知道服务端收消息和发消息都没问题。</p><p>第三次握手：客户端再次发送确认信息给服务端。服务端收到消息后，知道客户端接收消息没问题。</p><p>这样，经过三次，客户端和服务端都知道对方可以正常收发消息，就可以开始进行通信了。</p><p><img src="/../images/image-20250821133631120.png" alt="image-20250821133631120"></p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>四次挥手：<strong>确保双方的数据收发都已经完毕，保证断开的可靠性</strong></p><p>第一次挥手：客户端发起断开连接请求</p><p>第二次挥手：服务器端可能有客户端的请求还在处理，所以先返回一个稍等的响应</p><p>第三次挥手：服务器端把数据处理完毕之后，确定自己没有数据要收和发了之后，返回确认断开的响应</p><p>第四次挥手：客户端在处理完毕服务器端的数据后，确定自己没有数据要收和发了，处理完成后，发出正式确认断开连接的请求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java深入学习</title>
      <link href="/2025/05/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这篇文章用于记录Java基础知识相关的深入学习。包括了 动态代理、反射、JVM</p><h2 id="一、动态代理篇"><a href="#一、动态代理篇" class="headerlink" title="一、动态代理篇"></a>一、动态代理篇</h2><p>首先先理清<strong>代理</strong>的概念，代理就是用来<strong>增强原对象功能</strong>的。通过代理，可以<strong>无侵入式</strong>的给对象增强其他功能。</p><h3 id="代理长什么样？"><a href="#代理长什么样？" class="headerlink" title="代理长什么样？"></a>代理长什么样？</h3><p>代理类里面就是对象要被代理的方法。</p><h3 id="Java通过什么来保证代理的样子？"><a href="#Java通过什么来保证代理的样子？" class="headerlink" title="Java通过什么来保证代理的样子？"></a>Java通过什么来保证代理的样子？</h3><p>通过接口保证的，<strong>被代理对象和代理都需要实现同一个接口</strong>，而这个接口里的方法就是要被代理的所有方法。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>被代理的原对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> <span class="keyword">implements</span> <span class="title class_">Star_Interface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Star</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Star</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dance</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;在跳舞&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;跳舞结束&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;在唱歌&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;唱歌结束&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理接口（中介）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Star_Interface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理创建类,并不是代理</p><p>通过Proxy的newProxyInstance方法来创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarProxy</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star_Interface <span class="title function_">createProxy</span><span class="params">(Star star)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Star_Interface)Proxy.newProxyInstance(</span><br><span class="line">                StarProxy.class.getClassLoader(), <span class="comment">//当前类的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star_Interface.class&#125;, <span class="comment">//代理要实现的接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123; <span class="comment">//指定了增强逻辑</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//根据调用的代理的方法名称来决定增强内容</span></span><br><span class="line">                        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;dance&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;代理开始收跳舞费&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;sing&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;代理开始收唱歌费&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//method.invoke(对象,方法参数)，这里调用被代理对象的方法</span></span><br><span class="line">                        <span class="keyword">return</span> method.invoke(star ,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//这里通过传递原对象 给 代理创建类 来获取代理对象</span></span><br><span class="line">        <span class="type">Star_Interface</span> <span class="variable">proxy</span> <span class="operator">=</span> StarProxy.createProxy(star);</span><br><span class="line">        proxy.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理对象调用dance()方法时，实际上会通过反射将method对象和参数传递给invoke</p><p><img src="/../images/image-20250514190550452.png" alt="image-20250514190550452"></p><h4 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h4><h2 id="二、反射篇"><a href="#二、反射篇" class="headerlink" title="二、反射篇"></a>二、反射篇</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>反射是指通过获取类的Class对象来获取类的方法、构造函数和成员变量信息。</p><h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><p>创建Class对象(字节码文件对象)一共有三种方法</p><ul><li>Class.forName(“全类名”)</li><li>类名.class</li><li>实例对象.getClass()</li></ul><p>以下是三个方法的详细应用场景</p><h4 id="1-Class-forName-“全类名”"><a href="#1-Class-forName-“全类名”" class="headerlink" title="1.Class.forName(“全类名”)"></a>1.Class.forName(“全类名”)</h4><p>Class.forName用于动态加载类，<strong>适用于不知道类名的情况</strong>。因为有些时候，我们可能<strong>不确定要使用哪些类</strong>，某些类是需要我们在运行时期才可以知道的。</p><p><strong>实现原理</strong>：它通过类加载器（ClassLoader）来加载指定的类的。类加载器会<strong>根据提供的全限定名</strong>，从类路径中<strong>查找对应的字节码文件</strong>（<code>.class</code>文件）。如果找到了字节码文件，那么类加载器会<strong>将字节码文件加载到JVM</strong>中，并将其转换为<code>Class</code>对象。</p><p><strong>使用场景</strong>：就比如Spring中，我们建了多个模块，其中一个模块需要另一个模块的配置类自动装配，但是Spring默认自动装配的是当前路径下的组件，所以我们就需要给另一个模块加上spring.factory来写明要自动装配的全类名。这些类就是通过Class.forName()来加载的。</p><h4 id="2-类名-class"><a href="#2-类名-class" class="headerlink" title="2.类名.class"></a>2.类名.class</h4><p><strong>实现原理</strong>：直接通过类的静态属性 <code>.class</code> 获取 <code>Class</code> 对象。</p><p><strong>使用场景</strong>：通常作用于各种需要Class对象的方法的参数。</p><h4 id="3-实例对象-getClass"><a href="#3-实例对象-getClass" class="headerlink" title="3.实例对象.getClass()"></a>3.实例对象.getClass()</h4><p><strong>实现原理：</strong>通过对象实例的 <code>getClass()</code> 方法获取其运行时类的 <code>Class</code> 对象。</p><p><strong>使用场景：</strong></p><p>1.通过 <code>getClass()</code> <strong>获取被代理对象的真实类型</strong>，实现拦截逻辑。</p><p>2.多态环境下的类型判断</p><ul><li><p>当父类引用指向子类对象时，<code>getClass()</code> 可以获取实际的运行时类。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new ArrayList&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; actualClass = obj.getClass(); // 返回 ArrayList.class，而非 Object.class</span><br></pre></td></tr></table></figure></li></ul><p>至于获取Class对象后，有什么用，看如下这张图</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-36.png" alt="三分恶面渣逆袭：Java反射相关类"></p><p><img src="/../images/image-20250515004448947.png" alt="image-20250515004448947"></p><h3 id="用在哪里？"><a href="#用在哪里？" class="headerlink" title="用在哪里？"></a>用在哪里？</h3><p>反射的使用场景有很多，以下罗列了我已知的</p><h4 id="1-框架开发"><a href="#1-框架开发" class="headerlink" title="1.框架开发"></a>1.框架开发</h4><h5 id="（1）依赖注入"><a href="#（1）依赖注入" class="headerlink" title="（1）依赖注入"></a>（1）依赖注入</h5><p>Spring 通过反射扫描类路径，找到带有 <code>@Component</code>、<code>@Service</code> 等注解的类(反射是可以获取类、成员变量或方法上面的注解的)，并动态创建 Bean 实例。</p><p><strong>底层实现</strong>：Spring 使用 <code>Class.forName()</code> 加载类，再通过反射调用构造方法创建对象。</p><h5 id="（2）AOP"><a href="#（2）AOP" class="headerlink" title="（2）AOP"></a>（2）AOP</h5><p> 代理类在运行时生成，通过反射调用目标方法，并插入额外逻辑（如日志、事务）。</p><h5 id="（3）ORM框架"><a href="#（3）ORM框架" class="headerlink" title="（3）ORM框架"></a>（3）ORM框架</h5><p> ORM 框架通过反射获取类的字段名，并动态生成 SQL。</p><h4 id="2-序列化与反序列化（JSON-XML）"><a href="#2-序列化与反序列化（JSON-XML）" class="headerlink" title="2. 序列化与反序列化（JSON&#x2F;XML）"></a>2. <strong>序列化与反序列化（JSON&#x2F;XML）</strong></h4><p>通过反射获取对象的字段，并转换为 JSON&#x2F;XML。</p><h4 id="3-单元测试（JUnit、Mockito）"><a href="#3-单元测试（JUnit、Mockito）" class="headerlink" title="3. 单元测试（JUnit、Mockito）"></a><strong>3. 单元测试（JUnit、Mockito）</strong></h4><ul><li><p>**JUnit 的 <code>@Test</code>**：<br>测试框架通过反射查找并执行带有 <code>@Test</code> 的方法。<br><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testAdd() &#123;</span><br><span class="line">    Calculator calc = new Calculator();</span><br><span class="line">    assertEquals(3, calc.add(1, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>底层实现</strong>：JUnit 通过 <code>getClass().getMethods()</code> 找到测试方法并执行。</li></ul></li></ul><h4 id="4-绕过访问限制（慎用！）"><a href="#4-绕过访问限制（慎用！）" class="headerlink" title="4. 绕过访问限制（慎用！）"></a><strong>4. 绕过访问限制（慎用！）</strong></h4><ul><li><p><strong>访问私有字段&#x2F;方法</strong>：<br>反射可以突破 <code>private</code> 限制，但破坏封装性，需谨慎使用。<br><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = target.getClass().getDeclaredField(&quot;secret&quot;);</span><br><span class="line">field.setAccessible(true); // 强制访问私有字段</span><br><span class="line">String value = (String) field.get(target);</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-动态生成代码（如-Lombok）"><a href="#5-动态生成代码（如-Lombok）" class="headerlink" title="5.动态生成代码（如 Lombok）"></a><strong>5.动态生成代码（如 Lombok）</strong></h4><ul><li><p>**Lombok 的 <code>@Getter</code>&#x2F;<code>@Setter</code>**：<br>编译时注解处理器（APT）通过反射生成 getter&#x2F;setter 方法。<br><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Getter @Setter</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>底层实现</strong>：Lombok 在编译时修改字节码，添加相应方法。</li></ul></li></ul><h3 id="原理是怎么样的？"><a href="#原理是怎么样的？" class="headerlink" title="原理是怎么样的？"></a>原理是怎么样的？</h3><p>Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-什么是JVM"><a href="#1-什么是JVM" class="headerlink" title="1.什么是JVM"></a>1.什么是JVM</h3><p><img src="/../images/image-20250516212822058.png" alt="image-20250516212822058"></p><p>java之所以一次编译到处运行，就是因为有JVM的存在，使得同一份字节码文件能被不同操作系统的JVM解释执行。<strong>编译</strong>成机器码是非常耗时的，因为涉及<strong>全局的代码分析</strong>和进行<strong>复杂的优化</strong>，而<strong>解释</strong>只需要按照已有的内容<strong>按需翻译</strong>成机器码就行，不需要考虑这些，所以移植性好。</p><p>因为jvm是逐行解释字节码成机器码，并逐行执行机器码，所以执行速度相比于通过编译一次性翻译成全部机器码后执行要更慢，所以jvm在解释字节码那块有通过JIT编译进行优化。</p><p>JVM 的工作方式实际上是解释执行和 JIT（Just-In-Time）编译的结合：</p><ul><li><strong>解释执行</strong>：JVM 可以逐行解释执行字节码，这种方式启动速度快，但运行速度较慢。</li><li><strong>JIT 编译</strong>：为了提高性能，JVM 可以在运行时将热点代码（频繁执行的代码）编译成本地机器码。这种方式可以在不牺牲移植性的前提下提高程序的运行速度。</li></ul><h3 id="2-字节码文件的组成"><a href="#2-字节码文件的组成" class="headerlink" title="2.字节码文件的组成"></a>2.字节码文件的组成</h3><p><img src="/../images/image-20250516212747208.png" alt="image-20250516212747208"></p><h3 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3.运行时数据区"></a>3.运行时数据区</h3><p>就是指由JVM管理的内存区域，分为两大类</p><p>一类是线程共享的，分为<strong>方法区</strong>和<strong>堆</strong></p><p>一类是线程不共享的，分为<strong>本地方法栈</strong>、<strong>虚拟机栈</strong>和<strong>程序计数器</strong></p><p><img src="/../images/image-20250516212439460.png" alt="image-20250516212439460"></p><h3 id="4-内存溢出"><a href="#4-内存溢出" class="headerlink" title="4.内存溢出"></a>4.内存溢出</h3><p><img src="/../images/image-20250521234734514.png" alt="image-20250521234734514"></p><h3 id="5-JDK6-8内存区域上有哪些不同"><a href="#5-JDK6-8内存区域上有哪些不同" class="headerlink" title="5.JDK6-8内存区域上有哪些不同"></a>5.JDK6-8内存区域上有哪些不同</h3><p>1.JDK6，方法区存放在堆中，运行时常量池和字符串常量池存放在方法区</p><p>2.JDK7，方法区存放、字符串常量池在堆中，运行时常量池存放在方法区</p><p>3.JDK8，方法区以及包含的运行时常量池存在元空间，而字符串常量池存放在堆中</p><p>什么是元空间？</p><p>指的是由操作系统管理的内存空间，内存空间大。</p><p>堆是由JVM管理的内存，受制于JVM所被分配的内存大小。</p><p><img src="/../images/image-20250522001933509.png" alt="image-20250522001933509"></p><p><img src="/../images/image-20250522002209038.png" alt="image-20250522002209038"></p><p><img src="/../images/image-20250522002215645.png" alt="image-20250522002215645"></p><p>字符串常量池为什么要移动到堆中？</p><p><img src="/../images/image-20250522002440083.png" alt="image-20250522002440083"></p><h3 id="6-类的生命周期"><a href="#6-类的生命周期" class="headerlink" title="6.类的生命周期"></a>6.类的生命周期</h3><p><img src="/../images/image-20250522001603371.png" alt="image-20250522001603371"></p><h3 id="7-类加载器"><a href="#7-类加载器" class="headerlink" title="7.类加载器"></a>7.类加载器</h3><p>什么是类加载器</p><p>类加载器负责在类的加载过程中，将<strong>字节码信息以流的方式获取并加载到内存</strong>中。</p><p>种类</p><ul><li>启动类加载器：JDK9之前是c++编写，之后是java编写</li><li>扩展&#x2F;平台类加载器： JDK9及以后称为平台类加载器</li><li>应用程序类加载器：加载当前程序的classpath中的类</li><li>自定义类加载器</li></ul><p><strong>每种类加载器都有自己的加载目录</strong>。</p><h3 id="8-双亲委派机制"><a href="#8-双亲委派机制" class="headerlink" title="8.双亲委派机制"></a>8.双亲委派机制</h3><p>首先，类加载器之间是有层级关系的，<strong>上一级称为下一级的父类加载器</strong></p><p>层级关系如下</p><p>BootStrap（启动类加载器） -&gt; Extension（扩展类加载器） -&gt; Application（应用程序类加载器） -&gt; 自定义加载器</p><h4 id="什么是双亲委派机制？"><a href="#什么是双亲委派机制？" class="headerlink" title="什么是双亲委派机制？"></a>什么是双亲委派机制？</h4><p>双亲委派机制指的是，当一个类加载器接收到加载类的任务时，会先检查自己是否加载过这个类，如果没有，则会向上交给父类加载器查看是否加载过，父类没有则上交给父类的父类，直至启动类加载器。如果都没有加载过这个类，则会从顶部开始，往下依次试着加载这个类，直至有类加载器可以加载成功才会停下。</p><p>总之，就是从下往上检查，如果都没有加载过，则从上往下依次试着加载。</p><h4 id="双亲委派机制的作用？"><a href="#双亲委派机制的作用？" class="headerlink" title="双亲委派机制的作用？"></a>双亲委派机制的作用？</h4><h5 id="1-保证类加载的安全性"><a href="#1-保证类加载的安全性" class="headerlink" title="1.保证类加载的安全性"></a>1.保证类加载的安全性</h5><p>是因为可以避免恶意代码替换JDK的核心类库，比如java.lang.String,是由启动类加载器加载的，当我们自己写一个同样全类名的String类时，由于我们自定义的类是交给应用程序类加载器加载的，而启动类加载器会提前加载，所以应用程序类加载器会向上递交给启动类加载器，启动类加载器发现这个类自己已经加载过了，就不加载我们重定义的这个类了，我们自己写的这个就无法使用。确保了核心类库的完整性和安全性。</p><h5 id="2-避免重复加载"><a href="#2-避免重复加载" class="headerlink" title="2.避免重复加载"></a>2.避免重复加载</h5><p>由双亲委派机制可知，如果当前类加载器没有加载过这个类，则会向上传递，而不是直接加载，从而避免了重复加载。</p><h3 id="9-如何打破双亲委派机制"><a href="#9-如何打破双亲委派机制" class="headerlink" title="9.如何打破双亲委派机制"></a>9.如何打破双亲委派机制</h3><p>双亲委派机制主要是因为类加载器ClassLoader的loadClass方法，它是通过递归的方式实现了类的向上检查到向下加载。</p><p>所以想要打破双亲委派机制，就只需要重写ClassLoader的loadClass方法，自定义加载逻辑即可。</p><h3 id="10-如何判断堆上对象也没有被引用？"><a href="#10-如何判断堆上对象也没有被引用？" class="headerlink" title="10.如何判断堆上对象也没有被引用？"></a>10.如何判断堆上对象也没有被引用？</h3><h3 id="11-JVM中的引用类型"><a href="#11-JVM中的引用类型" class="headerlink" title="11.JVM中的引用类型"></a>11.JVM中的引用类型</h3><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li><li>终结器引用</li></ul><p><img src="/../images/image-20250525010700755.png" alt="image-20250525010700755"></p><h3 id="12-ThreadLocal中为什么要使用弱引用"><a href="#12-ThreadLocal中为什么要使用弱引用" class="headerlink" title="12.ThreadLocal中为什么要使用弱引用"></a>12.ThreadLocal中为什么要使用弱引用</h3><p>1.使用弱引用可以让对象被回收。因为仅有弱引用没有强引用的情况下，对象是可以被回收的。</p><p>ThreadLocal使用的示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadLocal</span> &#123;</span><br><span class="line">    <span class="comment">//这里threadLocal变量强引用了new ThreadLocal()对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        threadLocal.set(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadLocal.set(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;thread0：&quot;</span>+threadLocal.get());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                threadLocal.set(<span class="string">&quot;ge&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1：&quot;</span>+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250525010359017.png" alt="image-20250525010359017"></p><p>如果threadLocal使用了set方法的话，当前线程会弱引用这个变量指向的对象，此时如果把threadLocal变量&#x3D;null,那么强引用没了，这个对象就可以随时被回收。<strong>之所以要这样做，是因为没有变量指向这个ThreadLocal对象了,那我们也就无法通过变量使用set和get方法了，那么这个对象也就没有存在的必要了。总之就是，外部都不知道有这个人了，还留着干嘛呢</strong></p><p>但弱引用并没有完全解决对象回收问题。因为弱引用的Entry对象和其value值被当前线程的ThreadLocalMap强引用。</p><p>所以一般需要先手动调用remove()方法进行回收，之后再将ThreadLocal对象的强引用解除(即threadLocal&#x3D;null)。</p><p>试想下，如果没有弱引用，那么即使没有外部变量指向它,只要有一个线程的ThreadLocalMap强引用了它且没有remove，它就无法被回收，一直在map中，直至所有引用它的线程销毁。</p><p>而且ThreadLocalMap在内部的<strong>set，get和扩容时都会清理掉泄漏的Entry</strong>，即如果threadlocal引用被回收时，即便我们没有手动先进行remove(),也会自动清理关联的Entry，这样就不会导致内存泄漏了。</p><h4 id="追问"><a href="#追问" class="headerlink" title="追问"></a>追问</h4><p>Entry对象的key既然是弱引用，那value为什么不是弱引用。</p><p>答：防止value被提前回收。value要是设置成弱引用的话，要是这个value没有被外界其他变量强引用，仅仅是存在Entry对象里，但发生GC时，它就被回收了，变成null。之后要是来获取这个value值，不就为null了吗。总之就是你不知道value有没有被强引用，要是先于ThreadLocal对象被回收了，之后想获取时该怎么办？</p><h3 id="13-常见的垃圾回收方法"><a href="#13-常见的垃圾回收方法" class="headerlink" title="13.常见的垃圾回收方法"></a>13.常见的垃圾回收方法</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目面试准备</title>
      <link href="/2025/05/08/%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>/2025/05/08/%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一、黑马点评"><a href="#一、黑马点评" class="headerlink" title="一、黑马点评"></a>一、黑马点评</h1><h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1.项目介绍"></a>1.项目介绍</h2><p>我做的这个项目主要就是模仿大众点评，是使用springboot开发的前后端分离的项目，实现了商户的搜索、点评，好友关注、动态推送以及优惠券秒杀等功能。其中使用了redis做数据缓存，提高数据的访问效率，以及利用redis实现分布式锁解决一人一单的问题。此外，还利用了RabbitMq异步的创建优惠券订单，提高抢票的相应速度。</p><h2 id="2-项目中遇到的难点"><a href="#2-项目中遇到的难点" class="headerlink" title="2.项目中遇到的难点"></a>2.项目中遇到的难点</h2><p>我认为项目中主要的难点在于优惠券秒杀这个功能的实现。首先这个需要考虑到库存超卖和一人一单问题，针对库存超卖问题，我使用的是乐观锁的思想，考虑到库存如果使用版本号来判断扣减库存是否成功的话，会出现库存充足的情况下依旧会抢券失败的情况。所以我最后没有使用版本号，而是在给扣减库存的sql语句加个where条件判断库存数量是否大于0。然后针对一人一单问题，因为数据库的一人一单判断和库存扣减操作是非原子性的，所以，我的解决方案是我一开始是给用户id放到常量池中，使用synchronized这个关键字获取到用户id的锁后进行相关的抢票校验代码。但后面考虑到在多个相同服务部署的情况下，锁无法跨服务感知，所以使用了redis来创建分布式锁。用的是redisson这个类来创建的锁。</p><p>后面考虑到抢券流程会经过查询优惠券、查询库存、查询一人一单、扣减库存、创建订单等多次的数据库操作，导致的响应速度可能比较慢，所以我就用把优惠券的信息缓存到redis中，在redis上进行优惠券的校验流程。校验成功后使用rabbitMq来异步通知订单的创建，加快抢券的响应速度。</p><h2 id="3-简历上的技术亮点"><a href="#3-简历上的技术亮点" class="headerlink" title="3.简历上的技术亮点"></a>3.简历上的技术亮点</h2><h3 id="1-基于redis做缓存"><a href="#1-基于redis做缓存" class="headerlink" title="(1).基于redis做缓存"></a>(1).基于redis做缓存</h3><p>原话： 基于Redis做数据缓存，使用布隆过滤器+缓存空值解决缓存穿透问题，通过Sentinel的限流和熔断机制解决缓存雪崩问题、利用互斥锁和逻辑过期解决缓存击穿问题。</p><h4 id="提问：为什么要使用redis做缓存？"><a href="#提问：为什么要使用redis做缓存？" class="headerlink" title="提问：为什么要使用redis做缓存？"></a>提问：为什么要使用redis做缓存？</h4><p>因为redis是把数据存放在内存中，而mysql数据库则是存放在磁盘中，磁盘的访问速度比内存要慢的多，使用redis可以提高数据的访问效率。在项目中，我主要是对商户信息做了数据缓存，因为考虑到商户信息访问量很多，如果每次都访问数据库获取商户信息，会给数据库带来很大的压力。</p><h4 id="提问：怎么解决缓存穿透问题？"><a href="#提问：怎么解决缓存穿透问题？" class="headerlink" title="提问：怎么解决缓存穿透问题？"></a>提问：怎么解决缓存穿透问题？</h4><p>缓存穿透指的是请求访问的是数据库中不存在的数据，因为数据库中数据不存在，所以redis中也无法命中，导致每次的这种无效请求都会打到数据库。所以，我使用布隆过滤器和缓存空值这两种方法来解决。在访问redis和数据库时会先经过布隆过滤器的判断来决定是否进行后续的查询。</p><p>布隆过滤器底层是一个大型位数组（二进制数组）+多个无偏hash函数。</p><p>布隆过滤器针对已有的数据，肯定可以校验通过，而不存在的数据可能会有漏放的风险存在。所以我还使用了缓存空值的方式，若请求的商户id不存在，则会在redis中缓存这个商户id，并赋予空值和一个较短的过期时间，来减轻数据库的压力。</p><h4 id="提问：缓存雪崩问题？"><a href="#提问：缓存雪崩问题？" class="headerlink" title="提问：缓存雪崩问题？"></a>提问：缓存雪崩问题？</h4><p>缓存雪崩指的是在同一个时间段内，大量的key同时过期，或者说redis突然宕机，导致请求都直接打到数据库的情况。</p><p>我项目里是给每个key设置过期时间值时，除了固定的过期时间常量外，再额外添加随机的秒数，保证key的过期时间不会过于接近。</p><h4 id="提问：缓存击穿问题"><a href="#提问：缓存击穿问题" class="headerlink" title="提问：缓存击穿问题?"></a>提问：缓存击穿问题?</h4><p>缓存击穿问题指的是对某一个key的访问量很大，当这个key突然过期，且恢复到缓存的时间比较久的情况下，这段时间内的请求都会打到数据库。</p><p>我采用的是互斥锁和逻辑过期的方式来解决的。只使用互斥锁的话，会导致多个请求在获取锁失败的情况下陷入阻塞状态，或者是直接返回请求失败的信息，用户体验上来说并不是很好。所以可以再加个使用逻辑过期的方式，获取到锁时，通过异步的方式刷新缓存。无论有无获取到锁，都是直接返回旧值。所以数据及时性方面还是有欠缺的。基于Token和Redis实现用户认证，利用双拦截器机制（刷新Token拦截器+登录拦截器）实现无感刷新与权限控制，通过ThreadLocal实现用户信息透传，提升接口安全性。</p><h3 id="2-续约token"><a href="#2-续约token" class="headerlink" title="(2)续约token"></a>(2)续约token</h3><p>嗯，我项目中前端调用登录接口后，后端会生成一个随机token令牌，返回给前端，并以token为key,用户信息为value存入redis中并设置过期时间。</p><p>用户访问页面时，使用了两个拦截器，一个是刷新token拦截器，一个是登录拦截器。其中刷新token拦截器优先级最高，是全接口拦截且全放行的拦截器，主要作用就是如果请求头有携带token，那么就解析token，要是redis中存在value值，就存入threadlocal中，并把redis的这个key的过期时间进行延长。至于登录拦截器则是专门对必须登录才能访问的接口进行拦截，会判断threadLocal中用户信息是否为null,如果为null就进行拦截。</p><h1 id="二、黑马头条"><a href="#二、黑马头条" class="headerlink" title="二、黑马头条"></a>二、黑马头条</h1><h2 id="面试话术-技术亮点介绍"><a href="#面试话术-技术亮点介绍" class="headerlink" title="面试话术 - 技术亮点介绍"></a>面试话术 - 技术亮点介绍</h2><h3 id="开场介绍"><a href="#开场介绍" class="headerlink" title="开场介绍"></a>开场介绍</h3><p>“我最近完成了一个基于SpringCloud的分布式自媒体新闻平台项目，这个项目采用了微服务架构，包含了自媒体平台、用户平台和后台管理等多个子系统。在技术选型上，我重点考虑了系统的可扩展性、高可用性和性能优化。”</p><h3 id="1-智能搜索系统"><a href="#1-智能搜索系统" class="headerlink" title="1. 智能搜索系统"></a>1. 智能搜索系统</h3><p>在搜索功能这块，用户输入关键词时，系统会先从MongoDB中查询该用户的历史搜索记录，再去查询联想词库，总计最多10条联想词的一个列表返回给前端，从而实现智能联想功能。同时，基于Elasticsearch构建全文搜索引擎，我实现了标题和正文的加权检索，因为标题通常更能体现文章主题，所以给标题设置了更高的权重。此外，通过es支持高亮的特性，给关键词前后加上font标签来实现关键词红色高亮显示，提升用户体验。</p><p>面试官追问时补充：</p><ul><li><p>“MongoDB主要存储用户搜索历史和联想词，因为它的文档结构更适合这种场景”</p></li><li><p>“ES的加权检索通过multi_match查询实现，标题权重设为2，正文权重为1”</p></li></ul><h3 id="2-消息架构设计"><a href="#2-消息架构设计" class="headerlink" title="2. 消息架构设计"></a>2. 消息架构设计</h3><p>“为了确保数据一致性，我设计了Kafka双Topic的消息管道架构。业务操作和数据同步分别使用不同的Topic，比如文章上下架操作走业务Topic，而ES数据同步走专门的同步Topic。这样设计的好处是即使某个环节出现问题，也不会影响其他业务，同时通过消息重试机制保证最终一致性。”</p><p>面试官追问时补充：</p><ul><li><p>“具体实现是通过@KafkaListener监听不同的Topic”</p></li><li><p>“消息幂等性通过业务状态判断来保证”</p></li></ul><h3 id="3-定时任务调度"><a href="#3-定时任务调度" class="headerlink" title="3. 定时任务调度"></a>3. 定时任务调度</h3><p>“定时任务这块我采用了Redis + XXL-Job的混合架构。Redis负责任务预热和优先级管理，使用一个ZSet存储未来任务，一个List存储当前任务，一个List存储任务完成的id集合来避免任务重复消费。</p><p>XXL-Job主要就是负责未来任务预热、当前任务刷新和任务拉取的定时调度。</p><p>面试官追问时补充：</p><ul><li><p>“Redis的ZSet按执行时间排序，每分钟定时刷新到List中</p></li><li><p>XXL-Job提供了可视化的任务管理界面</p></li></ul><h3 id="4-AI内容审核"><a href="#4-AI内容审核" class="headerlink" title="4. AI内容审核"></a>4. AI内容审核</h3><p>“内容审核是新闻平台的核心功能，我集成了Langchain4j构建AI审核模型。系统采用三级审核机制：首先进行敏感词过滤，然后AI智能审核，最后人工复核。AI模型能够准确识别违规内容，返回PASS、MID、FAIL三种状态，大大减少了人工审核的工作量，同时保证了内容安全。”</p><p>面试官追问时补充：</p><ul><li><p>“AI模型基于OpenAI API，通过SystemMessage定义了审核规则”</p></li><li><p>“敏感词使用Trie树算法实现高效匹配”</p></li></ul><h3 id="5-实时热点计算"><a href="#5-实时热点计算" class="headerlink" title="5. 实时热点计算"></a>5. 实时热点计算</h3><p>热点文章计算我使用了Kafka Streams进行实时流处理。用户的行为数据（点赞、评论、收藏、浏览）实时发送到Kafka，通过KStream进行聚合处理。我设置了10秒的时间窗口，在这个窗口内对同一篇文章的所有行为数据进行聚合，然后将聚合结果发送到文章处理Topic上，触发文章热度的实时更新。”</p><p>面试官追问时补充：</p><ul><li><p>用户行为的消息传递其实就是发送了一个用户行为枚举类（点赞、浏览、评论和收藏）和一个计数值的消息到行为聚合的topic中，由Kstream进行监听并处理。</p></li><li><p>聚合逻辑是先按文章ID分组，然后累加各种行为数据到该文章对应的聚合对象上的</p></li><li><p>“聚合完成后通过.to()方法发送到HOT_ARTICLE_INCR_HANDLE_TOPIC”</p></li><li><p>下游有专门的监听器处理聚合结果，更新mysql中的文章行为数据和Redis中的热点文章缓存</p></li></ul><h3 id="6-性能优化"><a href="#6-性能优化" class="headerlink" title="6. 性能优化"></a>6. 性能优化</h3><p>“在性能优化方面，我实现了多级缓存策略。热点文章数据缓存在Redis中，用户行为数据也进行缓存。同时使用异步处理，通过@Async注解和消息队列，避免阻塞主流程，提升了系统吞吐量。”</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这套技术架构，系统具备了高并发、高可用的特性。搜索响应时间控制在100ms以内，热点文章更新延迟不超过10秒。这个项目让我深入理解了分布式系统的设计原则和性能优化技巧。</p><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><ol><li><p>STAR法则：介绍每个技术点时，先说背景(Situation)，再说任务(Task)，然后说行动(Action)，最后说结果(Result)</p></li><li><p>准备数据：记住一些关键数据，如响应时间、并发量等</p></li><li><p>准备问题：当面试官问”为什么选择这个技术”时，要能说出技术选型的考虑</p></li><li><p>承认不足：如果某个技术点不熟悉，可以诚实地说”这个功能我主要负责了架构设计，具体实现细节还需要进一步学习”</p></li></ol><p>记住，面试时语速要适中，表达要清晰，重点突出你的技术思考能力和解决问题的能力！</p><h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><h3 id="1-实时热点文章的计算"><a href="#1-实时热点文章的计算" class="headerlink" title="1.实时热点文章的计算"></a>1.实时热点文章的计算</h3><p>一开始，我想的方案就是，用户的每次行为都直接记录到数据上，然后通过定时任务去获取数据库中所有的文章的行为进行分值计算，然后再更新到redis热点文章的zset中。</p><p>但这么做的缺点很明显，就是数据库压力比较大，然后每次定时的计算所有文章的热度值，排好序后取出前10到redis的zset中,以热度值为score，不仅耗时，更多的还是说，有些文章可能这个时间段内没人访问，但还是进行了分值计算。所以这个方案很差。</p><p>然后我的解决方案就是，我采用了Kafka的Stream流式分析，把用户的这个行为数据通过kafka发送给Stream进行聚合处理，按文章分组，分别计算点赞数、评论数、浏览数和收藏，然后每隔10秒发送监听器，让监听器把这些数据库当中，然后每更新完一条文章，就去计算当前文章的热度值，然后去redis中进行热度值比对，如果当前文章已经是热点文章，那么更新热度值，否则判断是否大于热点文章的最低热点热度值，如果大于，就进行替换。</p><p>这就是我项目中遇到的难点，主要就是实现了减少了数据库访问的压力，以及提高热点文章实时更新的效率。</p><h3 id="2-分布式延迟队列的设计"><a href="#2-分布式延迟队列的设计" class="headerlink" title="2.分布式延迟队列的设计"></a>2.分布式延迟队列的设计</h3><h1 id="三、自我介绍"><a href="#三、自我介绍" class="headerlink" title="三、自我介绍"></a>三、自我介绍</h1><p>面试官您好，我叫李鼎烨，是杭州电子科技大学计算机科学与技术专业的27届本科生，我在校期间主要学习语言是java,像java基础知识，java虚拟机、java并发编程都有过系统的学习，然后像常用的数据库，像Mysql和Redis也都有过系统的学习，然后像java常用的一套框架，spring还有其他的一些中间件，比如消息队列什么的，都有过系统的学习。</p><p>然后我简历上的项目网上的一个开源项目，但是有对这个项目做过优化，像生活优选的话，就是</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马头条项目</title>
      <link href="/2025/04/30/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"/>
      <url>/2025/04/30/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="有意义的亮点摘要"><a href="#有意义的亮点摘要" class="headerlink" title="有意义的亮点摘要"></a>有意义的亮点摘要</h2><p>后面总结</p><h3 id="1-垂直分表"><a href="#1-垂直分表" class="headerlink" title="1.垂直分表"></a>1.垂直分表</h3><p><img src="/../images/image-20250430161610747.png" alt="image-20250430161610747"></p><p>2.ElasticSearch</p><p>3.xxl-job   分布式任务调度框架</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端知识点总结</title>
      <link href="/2025/04/20/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2025/04/20/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>随心记</p><p>这篇用于随时记各类八股文，后面会详细拆分各个模块</p><h2 id="一、Spring相关"><a href="#一、Spring相关" class="headerlink" title="一、Spring相关"></a>一、Spring相关</h2><h3 id="1-Spring框架中的单例bean是线程安全的吗？"><a href="#1-Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="1.Spring框架中的单例bean是线程安全的吗？"></a>1.Spring框架中的单例bean是线程安全的吗？</h3><p>答：不是。首先，Spring中的单例bean是全局共享的。一般情况下，spring的bean中注入的都是<strong>无状态</strong>的对象（无状态指的是不会存储数据，即没有定义可修改的成员变量），所以不会有线程安全问题。但如果假设这个bean定义了可修改的成员变量，多个线程如果同时访问并修改这个成员变量时，可能会造成数据的不一致，这种情况可用使用<strong>多例或者加锁来解决</strong>。</p><p>知识点：无状态Bean（即没有可修改的成员变量）、有状态Bean</p><h3 id="2-什么是AOP"><a href="#2-什么是AOP" class="headerlink" title="2.什么是AOP"></a>2.什么是AOP</h3><p>答：AOP的话，指的就是<strong>面向切面编程</strong>，简单说就是把一些业务逻辑中相同的代码抽取到一个独立模块中，通过<strong>动态代理</strong>的方式增强原方法，让业务逻辑更加简洁。</p><p>知识点：</p><p><strong>JDK动态代理</strong>，被代理的对象必须实现一个接口</p><p><strong>CGLIB动态代理</strong>，适用于被代理的对象没有实现接口的场景。</p><p><strong>Spring AOP 默认使用JDK动态代理</strong>，但如果目标类没有实现接口，则会自动切换到CGLIB动态代理。</p><p>AOP的具体应用</p><ul><li>事务处理</li><li>统一异常处理</li><li>日志记录</li><li>权限控制</li><li>资源同步</li><li>性能统计等</li></ul><h3 id="3-项目中有没有用到过AOP"><a href="#3-项目中有没有用到过AOP" class="headerlink" title="3.项目中有没有用到过AOP"></a>3.项目中有没有用到过AOP</h3><p>答: 我之前在尚庭公寓的后台管理系统中使用AOP来记录系统的操作日志，主要思路就是找到要记录日志的方法，使用AOP的环绕通知和切点表达式来获取该方法的相关数据，像是调用的用户信息、类名、方法参数这些，将它们其保存到数据库。此外，在项目里，比如@Transactional开启事务的注解、以及拦截器(实现 HandlerInterceptor 这个接口)、@ExceptionHandler异常处理类注解其实都是用到了aop。</p><h3 id="4-Spring中事务失效的场景有哪些"><a href="#4-Spring中事务失效的场景有哪些" class="headerlink" title="4.Spring中事务失效的场景有哪些"></a>4.Spring中事务失效的场景有哪些</h3><p>答：我知道的有4种。</p><p>第一种是<strong>异常捕获处理</strong>。就是在方法里对异常进行try catch后，假设发生了异常，而<strong>catch代码块中没有抛出异常</strong>，这种情况就会导致事务失效。解决方法的话就是可以在catch中抛出这个异常。</p><p>第二种是<strong>抛出检查型异常</strong>。因为事务的这个注解<strong>默认是对非检查型异常抛出时才会进行事务回滚</strong>。解决方法的话，我就会直接配置rollback属性为Exception,这样可以保证对于任何异常都会进行回滚。</p><p>第三种是<strong>方法没有声明public这个访问控制符</strong>。解决方法就是修改方法的访问控制符为public。</p><p>第四种是<strong>使用this调用带有@Transactional注解的方法</strong>。</p><p>第四种我在生活优选这个项目里碰到过，就是我在这个项目的创建订单业务里，我一开始没有使用分布式锁，使用的是悲观锁和乐观锁，那时我碰到的问题就是，如果在创建订单的这个方法上加上事务的话，会导致锁的提前释放。所以我把锁里面的这部分代码抽取出来到一个方法里，这个方法携带@Transactional注解，但是使用this这个关键字调用这个方法的话，会导致事务失效，需要利用<strong>AopContext的currentProxy()方法</strong>获取这个类的代理对象，使用代理对象调用这个方法才可以让事务成功生效。</p><h3 id="5-Spring的Bean的生命周期"><a href="#5-Spring的Bean的生命周期" class="headerlink" title="5.Spring的Bean的生命周期"></a>5.Spring的Bean的生命周期</h3><p>答：bean的生命周期分为7个阶段。</p><p>1.首先调用构造函数实例化bean</p><p>2.进行bean的依赖注入</p><p>3.处理以Aware为后缀的接口</p><p>4.执行bean的后置处理器BeanPostProcessor的前置方法</p><p>5.执行初始化方法(一个是实现InitializingBean这个接口并重写对应的方法，一种是自己在方法上面加上@PostConstruct这个注解)</p><p>6.执行bean的后置处理器的后置方法</p><p>7.最后就是bean的销毁</p><p>下面是我自定义的测试</p><p><img src="/../images/image-20250420182919589.png" alt="image-20250420182919589"></p><h3 id="6-Spring的循环依赖问题"><a href="#6-Spring的循环依赖问题" class="headerlink" title="6.Spring的循环依赖问题"></a>6.Spring的循环依赖问题</h3><p>循环依赖：指的是两个及以上的bean相互依赖对方，比如a依赖b，b依赖a。</p><p>循环依赖问题大部分可以由<strong>三级缓存</strong>来解决。</p><p>一级缓存：单例池，缓存的是已经初始化完成的bean.</p><p>二级缓存：缓存的是早期的生命周期未走完的bean对象（来自三级缓存）</p><p>三级缓存：缓存的是ObjectFactory对象工厂，用于创建某个对象（可以是原始对象或代理对象）</p><p>至于为什么要使用三级缓存而不是二级主要是因为<strong>代理对象的问题</strong>，代理对象的创建是在二级缓存对象之后（即生命周期后期），所以无法（在需要代理对象注入的情况下）将代理对象注入给对方。三级缓存通过<code>ObjectFactory</code>延迟了Bean对象的创建时机，使得Spring可以在需要时动态创建原始对象或代理对象，并将其存入二级缓存。</p><p>假设a依赖b，b依赖a的代理对象.</p><p>a先初始化，将a的对象工厂存入三级缓存，此时需要依赖注入b。所以b开始初始化，需要依赖注入a的代理对象，三级缓存中的a看到b需要的是代理对象，就创建代理对象存入到二级缓存并注入给b。b成功创建后存入一级缓存并注入给二级缓存中的a,a（代理对象或者原始对象）就创建成功并存入到一级缓存中了。</p><p>虽然Spring通过三级缓存解决了大部分循环依赖问题，但仍然有一些限制：</p><ul><li><strong>构造器注入</strong>：Spring无法解决构造器注入的循环依赖问题，因为构造器注入要求在构造过程中完成所有依赖注入，此时原对象是无法存入三级缓存。解决方法是在构造函数参数上使用<code>@Lazy</code>注解延迟初始化。</li></ul><h3 id="7-SpringMVC的执行流程"><a href="#7-SpringMVC的执行流程" class="headerlink" title="7.SpringMVC的执行流程"></a>7.SpringMVC的执行流程</h3><p>1.首先用户发起请求到前端控制器DispatcherServlet.</p><p>2.DispatcherServlet收到请求后会调用HandlerMapping(处理器映射)</p><p>3.HandlerMapping找到具体的处理器，生成处理器对象和处理器拦截器（如果有），再一起返回给DispatcherServlet.</p><p>4.DispatcherServlet再调用HandlerAdapter(处理器适配器)</p><p>5.HandlerAdapter经过适配调用具体的处理器（handler&#x2F;Controller）</p><p>如果是前后端分离的情况下，到这里流程就结束了，返回给前端的一般都是json字符串</p><p>但如果是jsp这种前后端不分离的情况下，还会有几个步骤。</p><p>6.处理器执行完成会返回ModelAndView给DispatcherServlet</p><p>7.DispatcherServlet将ModelAndView传递给ViewReslover视图解析器</p><p>8.视图解析器会将ModelAndView解析成View返回给DispatcherServlet</p><p>9.DispatcherServlet对View进行视图渲染后返回给用户</p><h3 id="8-SpringBoot自动配置原理"><a href="#8-SpringBoot自动配置原理" class="headerlink" title="8.SpringBoot自动配置原理"></a>8.SpringBoot自动配置原理</h3><p>在SpringBoot项目的启动类上面我们会使用@SpringBootApplication这个注解，这个注解是对三个注解进行了封装，包括@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这三个注解。</p><p>其中**@EnableAutoConfiguration<strong>这个注解是实现自动配置的核心注解，该注解通过@Import注解导入对应的配置选择器。而这个配置选择器会自动读取一个文件，就是该项目引用的jar包的classpath路径下的META-INF&#x2F;spring.factories文件，这个文件中包含了所要</strong>自动配置类的全类名的列表**。</p><p>这些配置类有条件注解，像是<code>@ConditionalOnClass</code>（判断是否有对应的字节码文件）和<code>@ConditionalOnProperty</code>（判断是否有对应的配置信息）这种，<strong>根据条件注解判断是否注入到Spring容器中</strong>，且其中定义的Bean也一样有条件注解。</p><p>注意，我现在这个版本的这个文件里面已经没有自动导入的全类名了。查看了下，好像放到了META-INF&#x2F;spring文件下的以imports为后缀的文件里。</p><p><img src="/../images/image-20250421222934681.png" alt="image-20250421222934681"></p><p><img src="/../images/image-20250421224243054.png" alt="image-20250421224243054"></p><p>spring自动装配的实际应用：</p><p>1.属性自动装配（Setter注入）</p><p>在属性上使用@Autowired注解</p><p>2.构造器自动装配</p><p>在构造器上使用@Autowired注解或者定义final成员属性，在类上面加上@RequiredArgsConstructor注解</p><p>注意，构造器自动装配的参数可以使用final关键字定义成员变量，而属性自动装配是动态注入，无法使用final关键字。所以两者各有应用场景。</p><h3 id="9-Spring框架常见注解"><a href="#9-Spring框架常见注解" class="headerlink" title="9.Spring框架常见注解"></a>9.Spring框架常见注解</h3><p>1.Spring常见注解–主要是跟bean的实例化和依赖注入相关</p><p><img src="/../images/image-20250421224821837.png" alt="image-20250421224821837"></p><p>其中的Scope指的就是作用域，使用在@Component类上面或者@Bean注解的方法上面。默认情况下，Spring 的 Bean 是单例的（<code>singleton</code>），但通过 <code>@Scope</code> 注解，可以指定其他作用域，如原型（<code>prototype</code>）、会话（<code>session</code>）、请求（<code>request</code>）等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 指定作用域为原型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="comment">// 类的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;session&quot;)</span> <span class="comment">// 指定作用域为会话</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.SpringMVC常见注解–主要是跟web相关的（请求和响应）</p><p><img src="/../images/image-20250421225352598.png" alt="image-20250421225352598"></p><p>3.SpringBoot常见注解–主要是跟自动配置相关</p><p><img src="/../images/image-20250421225510711.png" alt="image-20250421225510711"></p><h3 id="10-Mybatis执行流程"><a href="#10-Mybatis执行流程" class="headerlink" title="10.Mybatis执行流程"></a>10.Mybatis执行流程</h3><p>1.首先会读取Mybatis的相关配置。SpringBoot下是yml文件里配置，而SSM下是mybatis-config.xml文件里配置。</p><p>2.然后会构造一个会话工厂SqlSessionFactory</p><p>3.再从会话工厂里创建SqlSession对象，这个对象包含了执行SQL语句的所有方法</p><p>4.在 SqlSession 对象内部，包含了一个 Executor 执行器。Executor 是 MyBatis 用于操作数据库的接口，它负责执行 SQL 语句并返回结果。</p><p>5.Executor 接口的执行方法会接收一个 <code>MappedStatement</code> 类型的参数。MappedStatement 封装了 SQL 映射信息，包括 SQL 语句、输入参数映射和输出结果映射等。</p><p>6.执行sql语句时，会把输入参数映射到sql语句里。</p><p>7.执行完毕返回时，会将输出结果转化成java对象。</p><p><img src="/../images/image-20250421230608971.png" alt="image-20250421230608971"></p><h3 id="11-Mybatis的延迟加载"><a href="#11-Mybatis的延迟加载" class="headerlink" title="11.Mybatis的延迟加载"></a>11.Mybatis的延迟加载</h3><h4 id="（1）什么是延迟加载"><a href="#（1）什么是延迟加载" class="headerlink" title="（1）什么是延迟加载"></a>（1）什么是延迟加载</h4><p>简单来说就是需要用到这个数据才进行加载，不需要用到这个数据时不会加载。</p><p>就是Mybatis在进行<strong>一对一或一对多关联查询</strong>对象(比例用户对象除了用户信息，还包含了订单列表，所以需要集合映射查询订单表)时，不会立马执行集合映射那部分的sql语句，只有当使用到这个对象的集合时才会动态的去查询这个集合并赋值给当前对象。</p><p>默认情况下，mybatis是关闭延迟加载的。</p><p><img src="/../images/image-20250421232949235.png" alt="image-20250421232949235"></p><h4 id="（2）延迟对象原理"><a href="#（2）延迟对象原理" class="headerlink" title="（2）延迟对象原理"></a>（2）延迟对象原理</h4><p>就是使用<strong>CGLIB</strong>实现的<strong>动态代理</strong>对象。</p><p>以用户这个实体类获取订单列表为例</p><p>当调用目标方法user.getOrderList()时，会进入拦截器的invoke方法，如果发现订单列表是null值，则会进行执行sql查询order列表。然后将查询到的order列表调用user.setOrderList()方法将结果传给订单列表。之后结束方法调用。返回订单列表。</p><p><img src="/../images/image-20250421233546471.png" alt="image-20250421233546471"></p><h3 id="12-Mybatis的一级、二级缓存"><a href="#12-Mybatis的一级、二级缓存" class="headerlink" title="12.Mybatis的一级、二级缓存"></a>12.Mybatis的一级、二级缓存</h3><ul><li><strong>一级缓存</strong>：一级缓存是基于 <code>SqlSession</code> 的，当一个 <code>SqlSession</code> 查询了某个数据后，会将其存储在一级缓存中。在同一个 <code>SqlSession</code> 中，如果再次查询相同的数据，会直接从一级缓存中获取，而不会再次查询数据库。当会话关闭或提交后，一级缓存数据会转移到二级缓存。</li><li><strong>二级缓存</strong>：二级缓存是跨多个 <code>SqlSession</code> 的，它存储在 <code>Mapper</code> 的级别(就是Mapper这个类下的所有方法都适用)。其下的 <code>SqlSession</code> 在查询相同的数据时，可以直接从二级缓存中获取，而不需要再次查询数据库。默认情况下，二级缓存是禁用的，需要在配置文件里手动开启</li><li><strong>数据更新机制</strong>：当数据在某一作用域（一级缓存session&#x2F;二级缓存mapper）发生增删改操作时，默认该作用域下的所有缓存都会被清空。</li></ul><h3 id="13-什么是IOC、DI"><a href="#13-什么是IOC、DI" class="headerlink" title="13.什么是IOC、DI"></a>13.什么是IOC、DI</h3><p>所谓的<strong>IoC</strong>，就是<strong>由容器来控制对象的生命周期和对象之间的关系</strong>。<strong>控制对象生命周期的不再是引用它的对象，而是容器</strong>，这就叫<strong>控制反转</strong>（Inversion of Control）。</p><p>IOC 是一种思想，<strong>DI (依赖注入)是实现 IOC 的具体方式</strong>，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。</p><h4 id="为什么要使用-IoC-呢？"><a href="#为什么要使用-IoC-呢？" class="headerlink" title="为什么要使用 IoC 呢？"></a><a href="https://javabetter.cn/sidebar/sanfene/spring.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-ioc-%E5%91%A2">为什么要使用 IoC 呢？</a></h4><p>在平时的 Java 开发中，如果我们要实现某一个功能，可能至少需要两个以上的对象来协助完成，在没有 Spring 之前，每个对象在需要它的合作对象时，需要自己 new 一个，比如说 A 要使用 B，A 就对 B 产生了依赖，也就是 A 和 B 之间存在了一种耦合关系。</p><p>有了 Spring 之后，就不一样了，创建 B 的工作交给了 Spring 来完成，Spring 创建好了 B 对象后就放到容器中，A 告诉 Spring 我需要 B，Spring 就从容器中取出 B 交给 A 来使用。</p><p>至于 B 是怎么来的，A 就不再关心了，Spring 容器想通过 newnew 创建 B 还是 new 创建 B，无所谓。</p><p>这就是 IoC 的好处，它<strong>降低了对象之间的耦合度，使得程序更加灵活，更加易于维护。</strong></p><h2 id="二、java集合相关"><a href="#二、java集合相关" class="headerlink" title="二、java集合相关"></a>二、java集合相关</h2><h3 id="1-为什么数组索引从0开始呢？假如从1开始不行吗"><a href="#1-为什么数组索引从0开始呢？假如从1开始不行吗" class="headerlink" title="1.为什么数组索引从0开始呢？假如从1开始不行吗"></a>1.为什么数组索引从0开始呢？假如从1开始不行吗</h3><p>这主要是跟数组的寻址公式相关。数组在取指定索引的元素时，会使用<strong>首地址+索引值*数组中的元素类型大小</strong>。如果是从1开始，公式就多了一个索引值减1的操作，对于CPU来说相当于多了一次指令，当遍历量大时，性能就会不高。</p><h3 id="2-操作数组的时间复杂度"><a href="#2-操作数组的时间复杂度" class="headerlink" title="2.操作数组的时间复杂度"></a>2.操作数组的时间复杂度</h3><p>根据索引查找是O(1)。</p><p>查找未排序的数组中的某一元素是O(n)。查找排序后的数组时，利于二分查找的时间复杂度为O(logn)。</p><p>添加和删除操作时，时间复杂度为O(n)。</p><h3 id="3-ArrayList底层实现原理是什么"><a href="#3-ArrayList底层实现原理是什么" class="headerlink" title="3.ArrayList底层实现原理是什么"></a>3.ArrayList底层实现原理是什么</h3><p>ArrayList底层是基于动态数组实现的。</p><p>初始容量是0，当第一次添加数据时才会初始化容量为10。在添加数据时会先确保当前数组已使用长度小于数组容量。如果等于容量大小就会对数组进行扩容。</p><p>数组扩容后是大约是原来容量的1.5倍，就是原数大小加上右移一位后的大小。此外，每次扩容都会拷贝数组。</p><h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p><code>ArrayList list = new Arraylist(10)</code>中的list扩容几次</p><p>答：0次，因为源码里这个传入容量的构造方法实际就是按传入的数值大小直接创建存储数据的数组。根本没有涉及扩容。</p><p><img src="/../images/image-20250423001656778.png" alt="image-20250423001656778"></p><h3 id="4-如何实现数组和List之间的转换"><a href="#4-如何实现数组和List之间的转换" class="headerlink" title="4.如何实现数组和List之间的转换"></a>4.如何实现数组和List之间的转换</h3><p>数组转List使用<code>Arrays.asList()</code>方法。</p><p>List转数组使用List的<code>toArray(new数组对象)</code>方法例如<code>String[] array = list.toArray(new String[list.size()]);</code></p><p>追问：</p><p>1.用Arrays.asList转List后，如果修改了数组内容，list会受影响吗</p><p>答：会。因为Arrays.asList方法底层就是把数组传给内部类ArrayList的构造函数，这个构造函数会直接把传入的数组做为自己的底层数组，所以List和数组最终指向的都是同一个内存地址。</p><p><img src="/../images/image-20250518020436754.png" alt="image-20250518020436754"></p><p>2.List用toArray转数组后，如果修改了List内容，数组会受影响吗</p><p>答：不会。因为toArray方法实际上是拷贝了List中的数组，所以新数组和List没有关系。</p><p><img src="/../images/image-20250518020551908.png" alt="image-20250518020551908"></p><h3 id="5-链表相关"><a href="#5-链表相关" class="headerlink" title="5.链表相关"></a>5.链表相关</h3><p><img src="/../images/image-20250423005036389.png" alt="image-20250423005036389"></p><h3 id="6-ArrayList和LinkedList的区别是什么"><a href="#6-ArrayList和LinkedList的区别是什么" class="headerlink" title="6.ArrayList和LinkedList的区别是什么"></a>6.ArrayList和LinkedList的区别是什么</h3><p>从四方面回答：</p><p>1.底层数据结构</p><p>ArrayList是动态数组，LinkedList是双向链表。</p><p>2.效率</p><p>ArrayList访问随机元素的时间复杂度是O(1),而LinkedList是O(n).</p><p>A添加和删除数据的时间复杂度是O(n),而LinkedList是O(1).</p><p>3.空间</p><p>ArrayList底层是数组，数据存储占用的是连续的内存空间，内存更省。</p><p>而LinkedList的数据存储占用的是不连续的内存空间，而且除了存储数据还需要存储前后指针，内存开销更大。</p><p>4.线程是否安全</p><p>两个都不是线程安全的。</p><p>要保证线程安全的话可以在方法内做为局部变量使用，直接避免线程不安全问题产生。</p><p>或者使用Collections的synchronizedList()方法创列表。</p><p><img src="/../images/image-20250423005248216.png" alt="image-20250423005248216"></p><p><img src="/../images/image-20250423005339337.png" alt="image-20250423005339337"></p><h3 id="7-HashMap底层原理"><a href="#7-HashMap底层原理" class="headerlink" title="7.HashMap底层原理"></a>7.HashMap底层原理</h3><p>HashMap的底层数据结构是数组+链表+红黑树（jdk1.8及以后）。</p><p>当我们向HashMap put元素时，会利用key的hashCode重新计算hash值,将hash值和(数组容量-1)进行与运算计算出元素在数组中的下标。</p><p>如果出现hash冲突。则会判断key是否相同，key相同则覆盖原值。不同，则会将key-value放入到链表或红黑树中。</p><p>至于链表和红黑树之间是有转换规则的。</p><p>HashMap一开始创建时是数组+链表的结构，当链表长度超过8以及map容量大小大于64时，会将这个链表转化为红黑树。而如果链表长度超过8但map容量小于64时，会对数组进行扩容而不是转化为红黑树。</p><h3 id="8-讲讲HashMap的扩容机制"><a href="#8-讲讲HashMap的扩容机制" class="headerlink" title="8.讲讲HashMap的扩容机制"></a>8.讲讲HashMap的扩容机制</h3><p>对于扩容，HashMap中是设有<strong>扩容阈值</strong>的，其大小是根据<strong>当前数组长度*负载因子</strong>得到的，而负载因子默认大小是0.75。</p><p>在添加元素时候，会调用resize方法进行扩容。第一次添加数据时会初始化数组长度为16，之后每次扩容的大小都是原来的2倍大小，扩容时机是根据扩容阈值判断的。</p><p>扩容时，会创建一个新数组，把老数组中的数据拷贝到新数组中。在拷贝过程中。要注意三点</p><p>一、对于没有hash冲突(判断next是否为null)的<strong>节点</strong>，会直接使用<code>e.hash&amp;(newCap - 1)</code>计算新数组的索引位置。</p><p>二、如果是红黑树，则会走红黑树的添加方式。</p><p>三、如果是链表，则会对遍历链表，通过判断链表元素节点的hash值和oldCap进行与运算后的结果是否为0，若为0则停留到原始位置，否则移动到原始位置+旧数组大小的这个位置上。</p><p>注意：HashMap是懒加载。在创建对象时不会初始化数组，在无参构造函数中会加载默认的负载因子(0.75)。对于索引变更，根据第10点可知，<strong>数组扩容的情况下，索引要么不变，要么加上旧数组大小</strong>。</p><h3 id="9-hashMap的寻址算法"><a href="#9-hashMap的寻址算法" class="headerlink" title="9.hashMap的寻址算法"></a>9.hashMap的寻址算法</h3><p>hashMap首先会获取key的hashCode,然后对这个hashCode右移16位后进行异或运算得到hash值。这个右移异或是扰动算法，可以让hash分布更加均匀。</p><p>根据hash值跟（数组的容量大小-1）进行与运算后得到索引。</p><h3 id="10-为什么HashMap的数组长度一定是2的次幂？"><a href="#10-为什么HashMap的数组长度一定是2的次幂？" class="headerlink" title="10.为什么HashMap的数组长度一定是2的次幂？"></a>10.为什么HashMap的数组长度一定是2的次幂？</h3><p>因为2的次幂-1的与运算可以代替取余运算，计算索引的效率更高。</p><p>此外，扩容时计算索引的效率也更高，不是通过<code>hash &amp; (oldCap - 1)</code>获取新索引，而是通过<code>hash &amp; oldCap == 0</code> 判断元素是否留在原来的位置，否则新位置&#x3D;旧位置+oldCap。</p><p>oldCap是旧数组大小。</p><p>至于为什么会用hash&amp;oldCap &#x3D;&#x3D; 0来判断是基于公式推导得到的</p><p>对旧索引：index &#x3D; hash &amp; (oldCap - 1)</p><p>对新索引：newIndex &#x3D; hash &amp; (newCap - 1) &#x3D; hash &amp; (oldCap + oldCap  - 1) &#x3D; hash &amp; (oldCap -1) + hash &amp; oldCap &#x3D; index + hash  &amp; oldCap</p><p>从公式我们可以看到，新索引的增加数位就是由 hash &amp; oldCap 决定的。</p><p>而oldCap是2的次幂，导致oldCap转换为二进制数时只有一位是1，因此hash &amp; oldCap的与运算结果只可能是0或者oldCap;</p><p>故而当hashCode &amp; oldCap &#x3D;&#x3D; 0时，索引不变。不等于0时，索引+oldCap。</p><h2 id="三、并发编程相关"><a href="#三、并发编程相关" class="headerlink" title="三、并发编程相关"></a>三、并发编程相关</h2><h3 id="1-线程和进程的区别"><a href="#1-线程和进程的区别" class="headerlink" title="1.线程和进程的区别"></a>1.线程和进程的区别</h3><p>进程可以说是正在运行的程序实例，每个进程都有自己<strong>独立的内存空间</strong>，不同进程之间是相互隔离的。而<strong>线程是进程里面的执行单元</strong>，一个进程里可以有多个线程，这些线程<strong>共享进程的内存空间</strong>。</p><p>另外，<strong>线程比进程更轻量</strong>，上下文切换成本也低很多。因为切换线程时，系统只需要保存和恢复线程的上下文信息，而切换进程则需要处理更多资源和状态信息，开销更大。</p><h3 id="2-并行和并发有什么区别"><a href="#2-并行和并发有什么区别" class="headerlink" title="2.并行和并发有什么区别"></a>2.并行和并发有什么区别</h3><p><strong>并发</strong>指的是<strong>多个任务交替执行</strong>，在宏观上看是同时运行的，而微观上看其实就是快速切换，比如单核CPU处理多个任务。</p><p>而<strong>并行</strong>指的是<strong>多个任务同时执行</strong>，比如说多核CPU同时运行多个程序。</p><h3 id="3-创建线程的方式有哪些"><a href="#3-创建线程的方式有哪些" class="headerlink" title="3.创建线程的方式有哪些"></a>3.创建线程的方式有哪些</h3><p>有四种方式</p><p><strong>继承Thread类</strong>、<strong>实现Runnable接口</strong>、<strong>实现Callable接口</strong>和<strong>使用线程池创建线程</strong>。</p><p>关于如何使用Callable接口</p><p>主要就是重写call方法，然后将该类做为<code>FutureTask</code>构造函数的参数。在把<code>FutureTask</code>做为Thread构造函数的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start(); <span class="comment">//future只能供一个线程，所以这个不生效</span></span><br><span class="line">        System.out.println(future.get()); <span class="comment">//获取执行完的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>（1）一个<code>FutureTask</code>类只能被一个线程获取，再开其他线程不生效。这是因为<code>FutureTask</code> 是一个线程安全的类，它内部会管理任务的执行状态。如果尝试用多个线程启动同一个 <code>FutureTask</code>，只有第一个线程会真正执行任务，其他线程会发现任务已经被启动，从而不会重复执行。</p><p>（2）<code>FutureTask</code>实际上是<code>Runnable</code>的实现类。</p><p><img src="/../images/image-20250425200843184.png" alt="image-20250425200843184"></p><h4 id="追问1-Runnable和Callable有什么区别"><a href="#追问1-Runnable和Callable有什么区别" class="headerlink" title="追问1.Runnable和Callable有什么区别"></a>追问1.Runnable和Callable有什么区别</h4><p>Runnbale接口的run方法没有没有返回值，且不允许抛出异常。</p><p>Callable接口有返回值，需要用FutureTask获取返回值，且允许抛出异常。</p><h4 id="追问2-run-和start-有什么区别"><a href="#追问2-run-和start-有什么区别" class="headerlink" title="追问2.run()和start()有什么区别"></a>追问2.run()和start()有什么区别</h4><p><strong>start()是用来启动线程</strong>的，并在新线程中调用run方法。一个线程的start方法只能被调用一次（尝试多次会抛出异常）。</p><p>如果直接调用run方法，<strong>run方法只是会做为一个普通方法被调用</strong>，仍旧在当前线程执行，并不会启动新线程。</p><h3 id="4-线程包含哪些状态"><a href="#4-线程包含哪些状态" class="headerlink" title="4.线程包含哪些状态"></a>4.线程包含哪些状态</h3><p>有六种状态。新建(New)、可运行(Runnable)、阻塞(Blocked)、等待(waiting)、时间等待(Timed_waiting)、终止(Terminated)。</p><h3 id="5-线程状态之间是如何变化的"><a href="#5-线程状态之间是如何变化的" class="headerlink" title="5.线程状态之间是如何变化的"></a>5.线程状态之间是如何变化的</h3><p>创建线程对象是<strong>新建状态</strong>。</p><p>调用start()方法后转变为<strong>可执行状态</strong>。</p><p>线程获取到CPU执行权时会开始执行，执行结束是<strong>终止态</strong>。</p><p>在执行过程中，可能会切换为其他状态。</p><ul><li>若要当前线程要获取锁，而<strong>锁被其他线程占有</strong>，则会进入<strong>阻塞态</strong>。</li><li>若当前线程调用了<strong>wait()<strong>方法进入</strong>等待状态</strong>，则需要其他线程调用notify()唤醒为可执行态。</li><li>若当前线程调用了<strong>sleep(500)<strong>方法，则会进入</strong>计时等待状态</strong>，到时间后切换可执行态。</li></ul><p><img src="/../images/image-20250425213446655.png" alt="image-20250425213446655"></p><p>注意：wait方法会让当前线程释放锁，进入等待唤醒状态。而notify方法会随机唤醒在等待中的线程。notifyAll方法会唤醒所有在等待中的线程。notify和notifyAll不会释放锁，只是唤醒线程让它们可以重新获取锁。</p><h3 id="6-新建T1、T2、T3三个线程，如何保证按顺序执行"><a href="#6-新建T1、T2、T3三个线程，如何保证按顺序执行" class="headerlink" title="6.新建T1、T2、T3三个线程，如何保证按顺序执行"></a>6.新建T1、T2、T3三个线程，如何保证按顺序执行</h3><p>可以使用线程的join()方法解决。比如说要保证执行顺序为T1、T2、T3,那么可以在T2线程的run方法开头调用T1线程的join方法，T3线程的run方法开头调用T2线程的join方法。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程3执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在上面的代码中，t1的方法参数的匿名内部类不能调用t2和t3的join方法，因为t2、t3的变量的声明在t1之后。此外，在匿名内部类在调用外部类的局部变量时，变量必须是final或实际上不可变(指的是创建后并没有发生改变)，否则会编译错误。</p><h3 id="7-wait和sleep方法的不同"><a href="#7-wait和sleep方法的不同" class="headerlink" title="7.wait和sleep方法的不同"></a>7.wait和sleep方法的不同</h3><p><strong>共同点</strong>:都是让当前线程暂时放弃对CPU的使用权。</p><p>1.<strong>方法归属不同</strong></p><ul><li>sleep是Thread的静态方法</li><li>而wait是Object的成员方法，每个对象都有</li></ul><p>2.<strong>醒来的时机不同</strong></p><ul><li>执行sleep(long)和wait(long)的线程都会等待相应的毫秒后醒来。</li><li>wait()和wait(long)可以被notify唤醒, wait()如果不唤醒就会一直等待下去</li></ul><p>3.<strong>锁的特性不同</strong></p><ul><li>wait()方法必须在synchronized代码块中调用，且必须获取wait对象的锁，而sleep无此限制。</li><li>wait()方法执行后会<strong>释放对象锁</strong>，允许其他线程获取该对象锁。而sleep如果在synchronized代码块中执行，则<strong>不会释放对象锁</strong>。</li></ul><h3 id="8-如何停止一个正在运行的线程"><a href="#8-如何停止一个正在运行的线程" class="headerlink" title="8.如何停止一个正在运行的线程"></a>8.如何停止一个正在运行的线程</h3><p>有三种方法</p><p>1.使用<strong>退出标志</strong>，使<strong>线程正常退出</strong>，也就是当run方法执行完成后线程就会终止。</p><p>2.使用<strong>stop</strong>方法强行终止（方法已作废）</p><p>3.使用<strong>interrupt</strong>方法中断线程</p><h3 id="9-synchronized关键字底层原理"><a href="#9-synchronized关键字底层原理" class="headerlink" title="9.synchronized关键字底层原理"></a>9.synchronized关键字底层原理</h3><p>synchronized底层是由monitor实现的，就是锁监视器。monitor是jvm级别的对象。<strong>使用synchronized获取线程的某个对象的锁时，实际上是获取对象关联的monitor。</strong></p><p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p><p>其中的<strong>owner关联的是当前持有锁的线程</strong>，<strong>entrylist关联的是处于阻塞状态的线程</strong>，<strong>waitset关联的是处于waiting状态的线程</strong>。</p><p><img src="/../images/image-20250428194935115.png" alt="image-20250428194935115"></p><p>注意：在java中，每个对象都有一个与之关联的monitor。monitor是一种同步机制，用于确保同一时刻只有一个线程可以执行某个对象相关的同步代码。</p><h3 id="10-JMM-java内存模型"><a href="#10-JMM-java内存模型" class="headerlink" title="10.JMM(java内存模型)"></a>10.JMM(java内存模型)</h3><p>JMM是java内存模型，它<strong>定义了共享内存中多线程程序读写操作的行为规范</strong>，通过这些规则来规范对内存的读写操作，从而保证指令的正确性。</p><p>JMM<strong>把内存分为了两块</strong>，一块是线程私有的<strong>工作内存</strong>，一块是所有线程的共享的<strong>主内存</strong>。</p><p>线程跟线程之间是相互隔离的，线程跟线程之间的交互需要通过主内存。</p><p><img src="/../images/image-20250428195127443.png" alt="image-20250428195127443"></p><h3 id="11-CAS"><a href="#11-CAS" class="headerlink" title="11.CAS"></a>11.CAS</h3><p>CAS全称是<strong>Compare And Swap</strong>,它体现的其实就是一种<strong>乐观锁的思想</strong>。实现原理就是<strong>用一个预期值与要更新的值进行比较</strong>，两值相等的情况下才能成功更新。其底层调用的是Unsafe类中的方法，是由操作系统提供的。</p><h3 id="12-乐观锁和悲观锁的区别"><a href="#12-乐观锁和悲观锁的区别" class="headerlink" title="12.乐观锁和悲观锁的区别"></a>12.乐观锁和悲观锁的区别</h3><p>乐观锁无需加锁也无需等待，只需要在<strong>提交修改时去验证对应的资源是否被其他线程修改了</strong>即可，可以使用版本号机制或CAS算法。</p><p>而悲观锁则是在每次获取到资源时上锁。当有一线程获取到锁时，其他线程需要阻塞等待锁。</p><p>在高并发场景下，乐观锁相比悲观锁不存在竞争造成的线程阻塞问题。但如果冲突发生的较为频繁的话，会出现<strong>频繁的失败和重试</strong>，很浪费CPU，因为CPU要花费时间片去不断重试。</p><h3 id="12-volatile关键字"><a href="#12-volatile关键字" class="headerlink" title="12.volatile关键字"></a>12.volatile关键字</h3><p>volatile可以保证<strong>数据的可见性</strong>和<strong>禁止指令重排序</strong></p><p>数据的可见性：</p><p>加了volatile关键字的变量在获取或者修改时会<strong>直接对主内存中进行操作</strong>，而不会经过线程私有的工作内存。能够<strong>防止编译优化产生的问题</strong>。</p><p>禁止指令重排序：</p><p>用valatile修饰的变量会在读和写时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</p><p>比如双重校验锁实现对象单例的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行的：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空(因为已经指向内存地址了)，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><h3 id="13-什么是AQS"><a href="#13-什么是AQS" class="headerlink" title="13.什么是AQS"></a>13.什么是AQS</h3><p><img src="/../images/image-20250428214445414.png" alt="image-20250428214445414"></p><p>AQS（抽象队列同步器） 是一个<strong>抽象类</strong>，它维护了<strong>一个共享变量 state</strong> 和<strong>一个线程等待队列</strong>，为 ReentrantLock 等类提供底层支持。</p><p>AQS 的思想是，如果被请求的共享资源处于空闲状态，则当前线程成功获取锁；否则，将当前线程加入到等待队列中，当其他线程释放锁时，从等待队列中挑选一个线程，把锁分配给它。</p><h4 id="AQS底层源码"><a href="#AQS底层源码" class="headerlink" title="AQS底层源码"></a>AQS底层源码</h4><p>源码阅读指的是<strong>AbstractQueuedSynchronizer</strong>这个抽象类。</p><p>第一，状态变量state由volatile修饰，用于保证<strong>多线程之间变量的可见性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p>第二，同步队列由内部定义的<strong>Node类</strong>实现，每个 Node 包含了<strong>等待状态、前后节点、线程的引用</strong>等，是一个先进先出的双向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;       <span class="comment">// 前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;       <span class="comment">// 后继节点</span></span><br><span class="line">        Thread waiter;            <span class="comment">// 当前节点所关联的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> status;      <span class="comment">// 等待状态</span></span><br><span class="line">        <span class="comment">//剩下方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外</p><p>AQS 支持两种同步方式，具体看state的赋值情况：</p><ul><li><strong>独占模式</strong>下：每次只能有一个线程持有锁，例如 ReentrantLock。</li><li><strong>共享模式</strong>下：多个线程可以同时获取锁，例如 Semaphore （信号量）和 CountDownLatch（计数器）。</li></ul><p>AQS 使用一个 CLH 队列来维护等待线程，CLH 是三个作者 Craig、Landin 和 Hagersten 的首字母缩写，是一种基于链表的自旋锁。</p><p>在 CLH 中，当一个线程尝试获取锁失败后，会被添加到队列的尾部并自旋，等待前一个节点的线程释放锁。</p><p>CLH 的优点是，假设有 100 个线程在等待锁，锁释放之后，只会通知队列中的第一个线程去竞争锁。避免同时唤醒大量线程，浪费 CPU 资源。</p><h4 id="CountDownLatch源码"><a href="#CountDownLatch源码" class="headerlink" title="CountDownLatch源码"></a>CountDownLatch源码</h4><p>CountDownLatch内部维护了一个继承AQS的静态内部类Sync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">     Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">         setState(count);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getState();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//计数器减一操作</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">         <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">             <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">//调用父类AQS的CAS方法，保证原子性</span></span><br><span class="line">                 <span class="keyword">return</span> nextc == <span class="number">0</span>; </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS的CAS方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetInt(<span class="built_in">this</span>, STATE, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建CountDownLatch对象时，其实就是把计数值传递给AQS的state变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">100</span>);</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的底层实现</span></span><br><span class="line"><span class="comment">//1.对象创建，实际就是创建AQS子类Sync对象并赋值给成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);<span class="comment">//看上面Sync的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.减一操作，Sync内存重写了AQS的releaseShared方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-ReentrantLock实现原理"><a href="#14-ReentrantLock实现原理" class="headerlink" title="14.ReentrantLock实现原理"></a>14.ReentrantLock实现原理</h3><p>ReentrantLock翻译过来是<strong>可重入锁</strong>，相对应synchronized，它具备以下特点：</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置公平锁</li><li>支持多个条件变量</li><li>与synchronized一样，都支持重入</li></ul><p>ReentrantLock主要是利用<strong>CAS和AQS队列</strong>来实现的。</p><p>支持公平锁和非公平锁。在构造函数中，无参默认非公平锁，也可以传参设置为公平锁。</p><p><img src="/../images/image-20250428214321303.png" alt="image-20250428214321303"></p><p><img src="/../images/image-20250428214318357.png" alt="image-20250428214318357"></p><h3 id="15-ConcurrentHashMap"><a href="#15-ConcurrentHashMap" class="headerlink" title="15.ConcurrentHashMap"></a>15.ConcurrentHashMap</h3><p>jdk1.7底层采用分段数组+链表实现</p><p>采用的是Segment分段锁，底层使用的是ReentrantLock。</p><p>而jdk1.8及以上，ConcurrentHashMap的数据结构和HashMap一样，都是数组+链表&#x2F;红黑树，只是在添加节点时用到了<strong>CAS和Synchronized</strong>来保证<strong>线程的安全</strong>。</p><p>在对<strong>数组的空节点</strong>进行添加时，会使用<strong>CAS算法</strong>。(解决两个数据同时添加到数组的同一个位置时的问题)</p><p>而在对<strong>链表或者红黑树</strong>进行节点添加时，会对通过<strong>Synchronized</strong>，对<strong>首节点</strong>进行锁定。</p><p>以下是源码截图</p><p>给空节点添加时</p><p><img src="/../images/image-20250428215707901.png" alt="image-20250428215707901"></p><p><img src="/../images/image-20250428220319085.png" alt="image-20250428220319085"></p><p><img src="/../images/image-20250428220736895.png" alt="image-20250428220736895"></p><p>目标元素的实际内存地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tabAddress + ((long)i &lt;&lt; ASHIFT) + ABASE</span><br></pre></td></tr></table></figure><p>首节点锁定</p><p><img src="/../images/image-20250428222341524.png" alt="image-20250428222341524"></p><p>如果首节点被其他线程替换了，就会迭代循环（无限，直至遇到break）。</p><p><img src="/../images/image-20250428222731113.png" alt="image-20250428222731113"></p><h3 id="16-ThreadLocal"><a href="#16-ThreadLocal" class="headerlink" title="16.ThreadLocal"></a>16.ThreadLocal</h3><p><a href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 是一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离。</p><p>在 Web 应用中，可以使用 ThreadLocal 存储用户会话信息，这样每个线程在处理用户请求时都能方便地访问当前用户的会话信息。</p><h4 id="ThreadLocal实现的底层原理"><a href="#ThreadLocal实现的底层原理" class="headerlink" title="ThreadLocal实现的底层原理"></a>ThreadLocal实现的底层原理</h4><p>首先，ThreadLocal 自身并不保存任何线程的数据，ThreadLocal 只是一个操作接口，真正的线程本地值存储在当前调用的线程的 ThreadLocalMap 中。</p><p>当我们创建一个 ThreadLocal 对象并调用 set 方法时，其实是在当前线程中初始化了一个 ThreadLocalMap。</p><p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类，它内部维护了一个 Entry 数组，<strong>key 是 ThreadLocal 对象</strong>，<strong>value 是我们所传入的变量</strong>，所以每个ThreadLocal虽然只能存一个value值，但我们可以创建多个ThreadLocal对象用于保存各种信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalMap的构造方法，firstKey是ThreadLocal实例，firstValue是传入的值</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY]; <span class="comment">//初始化entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>); <span class="comment">//计算索引位置</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue); <span class="comment">//存放具体Entry</span></span><br><span class="line">    size = <span class="number">1</span>; <span class="comment">//已用的数组节点大小</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY); <span class="comment">//设置扩容阈值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置扩容阈值为容量大小的2/3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以ThreadLocal为key，进行赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table; <span class="comment">//获取entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//若hash冲突，则会</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; </span><br><span class="line">         e != <span class="literal">null</span>;<span class="comment">//为null，则跳出遍历</span></span><br><span class="line">         e = tab[i = nextIndex(i, len)]  <span class="comment">//若hash冲突，线性探测下一个索引位置) &#123;</span></span><br><span class="line">        <span class="comment">//判断是否是同一个ThreadLocal实例.若是，则直接进行值替换</span></span><br><span class="line">        <span class="keyword">if</span> (e.refersTo(key)) &#123; </span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//表示这个 Entry 的 Key 已经被 GC 回收了，现在是个无效 Entry。就是ThreadLocal实例已经不存在了。那么就可以替换掉这个entry了</span></span><br><span class="line">        <span class="keyword">if</span> (e.refersTo(<span class="literal">null</span>)) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//若哈希冲突，且无遇到无效Entry，则创建新Entry并赋值</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">//进行无效entry的清理</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();<span class="comment">// 这是扩容， 即清理没效果，并且已经达到了扩容阈值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性探测索引位置，因为扩容阈值为2/3大小，所以不会有无限循环探测的问题</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在 ThreadLocalMap 中，Key 是 ThreadLocal 实例本身。所以如果你每次调用方法都 new 一个新的 ThreadLocal()，即使值一样，也会被认为是不同的 Key。导致同一个线程多次 set()，其实是存了多个 Entry，浪费内存且无法复用。</p><p>总之，将 ThreadLocal 设置为 static final 是一种最佳实践，它确保 <strong>Key 唯一</strong>、<strong>可重用</strong>，<strong>避免不必要的对象创建</strong>，并减少因 Key 不一致或弱引用导致的潜在内存泄漏风险。</p><h2 id="四、Mysql"><a href="#四、Mysql" class="headerlink" title="四、Mysql"></a>四、Mysql</h2><h3 id="1-如何定位慢查询"><a href="#1-如何定位慢查询" class="headerlink" title="1.如何定位慢查询"></a>1.如何定位慢查询</h3><p>Mysql本身提供了慢查询日志功能。可以在系统的配置文件中开启慢查询日志，设置SQL执行超过多长时间就记录到日志文件中。</p><h3 id="2-那这个SQL语句执行很慢，如何分析呢？"><a href="#2-那这个SQL语句执行很慢，如何分析呢？" class="headerlink" title="2.那这个SQL语句执行很慢，如何分析呢？"></a>2.那这个SQL语句执行很慢，如何分析呢？</h3><p>如果一条SQL执行很慢，我们通常<strong>会使用MySQL的<code>EXPLAIN</code>命令来分析这条SQL的执行情况</strong>。通过<code>key</code>和<code>key_len</code>可以检查是否命中了索引，如果已经添加了索引，也可以判断索引是否有效。通过<code>type</code>字段可以查看SQL是否有优化空间，比如是否存在全索引扫描或全表扫描。通过<code>extra</code>建议可以判断是否出现回表情况，如果出现，可以尝试添加索引或修改返回字段来优化。</p><h3 id="3-索引的底层数据结构了解过吗？"><a href="#3-索引的底层数据结构了解过吗？" class="headerlink" title="3. 索引的底层数据结构了解过吗？"></a>3. 索引的底层数据结构了解过吗？</h3><p><strong>MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构</strong>。选择B+树的原因包括：节点可以有更多子节点，路径更短；磁盘读写代价更低，<strong>非叶子节点只存储键值和指针</strong>，<strong>叶子节点存储数据</strong>；B+树适合范围查询和扫描，因为<strong>叶子节点之间形成了一个双向链表</strong>。</p><p><img src="/../images/image-20250513184525036.png" alt="image-20250513184525036"></p><h3 id="4-B树和B-树的区别是什么呢？"><a href="#4-B树和B-树的区别是什么呢？" class="headerlink" title="4.B树和B+树的区别是什么呢？"></a>4.B树和B+树的区别是什么呢？</h3><ol><li>B树的非叶子节点和叶子节点都存放数据，而B+树的所有数据只出现在叶子节点，这使得B+树在查询时效率更稳定。</li><li>B+树在进行范围查询时效率更高，因为所有数据都在叶子节点，并且叶子节点之间形成了双向链表。</li></ol><h3 id="5-什么是聚簇索引和非聚簇索引"><a href="#5-什么是聚簇索引和非聚簇索引" class="headerlink" title="5.什么是聚簇索引和非聚簇索引"></a>5.什么是聚簇索引和非聚簇索引</h3><p><strong>聚簇索引是指数据与索引放在一起</strong>，B+树的叶子节点<strong>保存了整行数据</strong>，通常只有一个聚簇索引，一般是由主键构成。</p><p><strong>非聚簇索引则是数据与索引分开存储</strong>，B+树的叶子节点<strong>保存的是主键值</strong>，可以有多个非聚簇索引，通常我们自定义的索引都是非聚簇索引。</p><h3 id="6-什么是回表查询"><a href="#6-什么是回表查询" class="headerlink" title="6.什么是回表查询"></a>6.什么是回表查询</h3><p><strong>回表查询是指通过二级索引找到对应的主键值</strong>，然后再通过主键值查询聚簇索引中对应的整行数据的过程。</p><p>注意二级索引和非聚簇索引的区别：</p><ul><li><p><strong>二级索引</strong>：是一种在数据库表中除了主索引（聚簇索引）之外的其他索引。它允许用户根据非主键列进行快速查找。二级索引的结构通常是一个独立的索引结构，它存储了索引列的值和指向数据行的指针。</p></li><li><p><strong>非聚簇索引</strong>：是一种索引类型，它不改变数据行的物理存储顺序。非聚簇索引的存储结构是一个独立的索引表，它存储了索引列的值和指向数据行的指针。数据行的存储顺序与非聚簇索引的顺序无关。</p></li><li><p>在实际应用中，非聚簇索引通常是二级索引的一种实现方式，但二级索引也可以是其他类型的索引，如哈希索引等。</p></li></ul><h3 id="7-什么是覆盖索引"><a href="#7-什么是覆盖索引" class="headerlink" title="7.什么是覆盖索引"></a>7.什么是覆盖索引</h3><p>覆盖索引指的是使用select查询数据时，<strong>所需的列全部能在索引中找到，避免了回表查询</strong>。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率。</p><h3 id="8-超大分页怎么处理"><a href="#8-超大分页怎么处理" class="headerlink" title="8.超大分页怎么处理"></a>8.超大分页怎么处理</h3><p>超大分页通常发生在数据量大的情况下，使用<code>LIMIT</code>分页查询且需要排序时效率较低。可以通过覆盖索引和子查询来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升。</p><p><img src="/../images/image-20250513185734032.png" alt="image-20250513185734032"></p><p>我的理解是，对于超大分页，如果直接对所有数据进行limit的话，需要扫描全表并排序，数据量不仅大还耗时。但如果我们先使用子查询的方式获取排序后的id临界值，因为只需要id值，所以是覆盖索引，效率可以提升。再把获取到的id值做为主查询的临界值，这样子主查询就可以避免对全表的扫描和排序。</p><p>例如：select * from tb_user limit 90000,10      这个语句会先遍历前90000行，再往后取10行，效率很低</p><h3 id="9-什么情况下，索引会失效"><a href="#9-什么情况下，索引会失效" class="headerlink" title="9.什么情况下，索引会失效"></a>9.什么情况下，索引会失效</h3><p>1.没有遵循最左匹配原则</p><p>2.使用了模糊查询且%在前面</p><p>3.在索引字段上进行了运算或者类型转换</p><p>4.使用了联合索引，但在中间使用了范围查询，导致右边的条件索引失效</p><h3 id="面渣八股文"><a href="#面渣八股文" class="headerlink" title="面渣八股文"></a>面渣八股文</h3><h3 id="1-为什么InnoDB要使用B-树做为索引？"><a href="#1-为什么InnoDB要使用B-树做为索引？" class="headerlink" title="1.为什么InnoDB要使用B+树做为索引？"></a>1.为什么InnoDB要使用B+树做为索引？</h3><p>因为 B+ 树是一种<strong>高度平衡的多路查找树</strong>，能<strong>有效降低磁盘的 IO 次数</strong>，并且<strong>支持有序遍历和范围查询</strong>。</p><p>再换一种回答：</p><ul><li>相比哈希表：B+ 树支持范围查询和排序</li><li>相比二叉树和红黑树：B+ 树<strong>更“矮胖”，层级更少</strong>，磁盘 IO 次数更少</li><li>相比 B 树：B+ 树的非叶子节点只存储键值，<strong>叶子节点存储数据并通过链表连接，支持范围查询</strong></li></ul><p><strong>tip:</strong></p><p>多路查找树是一种树形数据结构，每个节点可以有多个子节点。例如，一个三路查找树的每个节点最多有三个子节点。</p><p>高度平衡的树是指树的左右子树的高度差不超过一个固定值（通常是1）。</p><h3 id="2-事务的四大特性-ACID"><a href="#2-事务的四大特性-ACID" class="headerlink" title="2.事务的四大特性-ACID"></a>2.事务的四大特性-ACID</h3><p>分别是原子性、一致性、隔离性和持久性</p><p><img src="/../images/image-20250513192209329.png" alt="image-20250513192209329"></p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性:"></a>原子性:</h4><p>原子性指的是事务中所有的操作，<strong>要么全部执行成功，要么全部失败</strong>。事务中只要任何一个操作失败了，就会<strong>回滚到事务开始之前</strong>的状态。</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性:"></a>一致性:</h4><p>一致性确保数据的状态<strong>从一个一致状态转变为另一个一致状态</strong>。一致性与业务规则有关，比如银行转账，不论事务成功还是失败，转账双方的<strong>总金额应该是不变的</strong>。</p><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性:"></a>隔离性:</h4><p>指的是多个并发事务之间相互隔离，即一个事务的执行<strong>不能被其他事务干扰</strong>。</p><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性:"></a>持久性:</h4><p><strong>一旦事务提交</strong>，则其所做的修改将<strong>永久保存</strong>到 MySQL 中。即使发生系统崩溃，修改的数据也不会丢失。</p><h3 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h3><p>MySQL中支持4种隔离级别，分别是<strong>读未提交</strong>、<strong>读已提交</strong>、<strong>可重复读</strong>和<strong>串行化</strong>。</p><p><img src="/../images/image-20250513193331803.png" alt="image-20250513193331803"></p><p>读未提交：会出现脏读、不可重复读、幻读</p><p>读已提交：会出现不可重复读、幻读</p><p>可重复读：会出现幻读</p><p>串行化：无</p><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p>事务可以读取其他未提交事务修改的数据。也就是说，如果未提交的事务一旦回滚，读取到的数据就会变成了“脏数据”，通常不会使用。</p><h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p>读已提交避免了脏读，但可能会出现不可重复读，即同一事务内多次读取同一数据结果会不同，<strong>因为其他事务提交的修改，对当前事务是可见的</strong>。</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>可重复读能确保同一事务内多次读取相同数据的结果一致，即使其他事务已提交修改。可重复读是MySQL的默认隔离级别。但不可避免幻读。</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>串行化是最高的隔离级别，通过<strong>强制事务串行执行</strong>来解决“幻读”问题。</p><p><img src="/../images/image-20250513193812078.png" alt="image-20250513193812078"></p><p>但会导致大量的锁竞争问题，实际应用中很少用。</p><h3 id="4-事务的隔离级别是如何实现的"><a href="#4-事务的隔离级别是如何实现的" class="headerlink" title="4.事务的隔离级别是如何实现的"></a>4.事务的隔离级别是如何实现的</h3><p>注意：针对MySQL的MVCC，事务的隔离级别的底层实现相较于传统的三级封锁协议有些区别。因为用到了ReadView。</p><p>下面写的是针对MVCC和传统的封锁协议写的，不要等价了。</p><p><strong>读未提交</strong>，写操作加行级排他锁（<code>X</code> 锁），防止其他事务同时修改同一行。但<strong>读操作不加锁</strong>，所以<strong>允许读取其他事务未提交的数据</strong>，也就导致了脏读的问题。</p><p>对应一级封锁协议。会在数据更新前添加行级排他锁，行级排他锁会阻止其他事务对数据再加排他锁或者共享锁，但由于一级封锁协议没有共享锁这个概念，导致其他事务读取数据时，排他锁并不会拦截。也就会导致脏读问题。</p><p><strong>读已提交</strong>，写操作会加行级排他锁，每次读操作时，都会生成一个新的ReadView，确保<strong>读取到的数据是最新已提交的</strong>，从而解决脏读的问题。但因为每次读都是最新已提交的数据，所以会出现不可重复读的问题。</p><p>对应二级封锁协议。在一级封锁协议上引入了共享锁，使得其他事务读取数据时需要先添加共享锁，而数据修改时会添加排他锁，导致获取锁必须在拥有排他锁的事务释放锁之后才可以读取数据，所以可以避免脏读问题。但二级封锁协议的共享锁是在查询时添加共享锁，查询结束就立刻释放共享锁。所以并不能解决不可重复读问题。</p><p><strong>可重复读</strong>，可重复读<strong>只在第一次读操作时生成 ReadView</strong>，后续读操作都会使用这个 ReadView，从而避免不可重复读的问题。另外，对于当前读操作，可重复读会通过临键锁来锁住当前行和前间隙，防止其他事务在这个范围内插入数据，从而避免幻读的问题。</p><p>对应三级封锁协议。可重复读的共享锁的释放必须在事务结束之后，所以可以解决不可重复读的问题。但由于排他锁和共享锁只能针对已经存在的数据加锁。对于不存在的数据，其他事务可以进行增加操作，所以可能会有幻读问题存在。</p><p><strong>串行化</strong>，事务在读操作时，会先加<strong>表级共享锁</strong>；在写操作时，会先加<strong>表级排他锁</strong>。所以可以避免幻读问题的发生。</p><p>我的理解是串行化超过了三级封锁协议，主要原因还是标准的三级封锁协议无法对不存在的数据加锁，不可避免幻读的产生。</p><h3 id="5-MVCC机制"><a href="#5-MVCC机制" class="headerlink" title="5.MVCC机制"></a>5.MVCC机制</h3><p><strong>MVCC指的是多并发版本控制，每次修改数据时，都会生成一个新的版本，而不是直接在原有的数据上进行修改。并且每个事务只能看到在它开始之前已经提交的数据版本。</strong></p><p>这样的话，读操作和写操作之间就不会相互阻塞，从而避免了频繁加锁带来的性能损耗。</p><p><strong>底层实现主要依赖于Undo Log和Read View。</strong></p><p>每次修改数据前，会将当前的记录拷贝到Undo Log中，其中的每条记录都包含三个隐藏列，DB_TRX_ID用于记录当前修改该行的事务ID，DB_ROLL_PTR用来指向Undo Log中的前一个版本，DB_ROW_ID用来唯一标识改行数据（仅无主键时生成）。</p><p>如下图所示，当前的行数据会指向undo log中最近的数据版本，这样子使得数据的版本串行连接，方便数据的回滚等。</p><p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20250419152549.png" alt="guozhchun：额外的存储信息"></p><p>每次读取数据时，都会生成一个 ReadView，其中记录了当前活跃事务的 ID 集合、最小事务 ID、最大事务 ID 等信息，通过与 DB_TRX_ID 进行对比，判断当前事务是否可以看到该数据版本。</p><p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20250419152750.png" alt="luozhiyun：ReadView"></p><h4 id="什么是版本链"><a href="#什么是版本链" class="headerlink" title="什么是版本链"></a>什么是版本链</h4><p><strong>版本链是指 InnoDB 中同一条记录的多个历史版本</strong>，通过 <strong>DB_ROLL_PTR 字段</strong>将它们像链表一样串起来，用来<strong>支持 MVCC 的快照读</strong>。</p><p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20240415084347.png" alt="二哥的 Java 进阶之路：版本链"></p><p>当更新一行数据时，innoDB不会覆盖原有的数据，会<strong>记录上一次的数据版本到undo日志中</strong>，并创建一个新的数据版本，更新DB_TRX_ID和DB_ROLL_PTR，使他们存放当前的事务ID和上一次数据版本在undo日志中的指针。</p><p>这样，老版本的数据就不会丢失，可以通过版本链找到。</p><p>由于 undo 日志会记录每一次的 update，并且新插入的行数据会记录上一次数据版本在 undo 日志的指针，所以可以通过 DB_ROLL_PTR 这个指针找到上一条记录，这样就形成了一个版本链。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/mysql-765b3d83-14eb-4b56-8940-9d60bfaf1737.jpg" alt="三分恶面渣逆袭：版本链"></p><h4 id="什么是Read-View"><a href="#什么是Read-View" class="headerlink" title="什么是Read View"></a>什么是Read View</h4><p><strong>ReadView 是 InnoDB 为每个事务创建的一份“可见性视图”，用于判断在执行快照读时，哪些数据版本是当前这个事务可以看到的，哪些不能看到。</strong></p><p>当事务开始执行时，InnoDB 会为该事务创建一个 ReadView，这个 ReadView 会记录 4 个重要的信息：</p><ul><li>creator_trx_id：创建该 ReadView 的事务 ID。</li><li>m_ids：所有活跃事务的 ID 列表，<strong>活跃事务</strong>是指那些<strong>已经开始但尚未提交的事务</strong>。</li><li>min_trx_id：所有活跃事务中最小的事务 ID。它是 m_ids 数组中最小的事务 ID。</li><li>max_trx_id ：事务 ID 的最大值加一。换句话说，它是下一个将要生成的事务 ID。</li></ul><p>如何判断记录的某个版本是否可见？</p><p><img src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20240415094939.png" alt="二哥的 Java 进阶之路：ReadView判断规则"></p><p>①、如果某个数据版本的 DB_TRX_ID 小于 min_trx_id，则该数据版本在生成 ReadView 之前就已经提交，因此对当前事务是可见的。</p><p>②、如果 DB_TRX_ID 大于 max_trx_id，则表示创建该数据版本的事务在生成 ReadView 之后开始，因此对当前事务不可见。</p><p>③、如果 DB_TRX_ID 在 min_trx_id 和 max_trx_id 之间，需要判断 DB_TRX_ID 是否在 m_ids 列表中：</p><ul><li>不在，表示创建该数据版本的事务在生成 ReadView 之后已经提交，因此对当前事务也是可见的。</li><li>在，表示事务仍然活跃，或者在当前事务生成 ReadView 之后才开始，因此是不可见的。</li></ul><p>总之，readView规定了当前事务可见的范围，可见的只能是<strong>不在活跃事务范围内</strong>、且<strong>事务id不超过当前记录的未来事务id</strong>(即事务可见)<strong>的已经提交的事务</strong>。</p><h4 id="可重复读和读已提交在ReadView上的区别"><a href="#可重复读和读已提交在ReadView上的区别" class="headerlink" title="可重复读和读已提交在ReadView上的区别"></a>可重复读和读已提交在ReadView上的区别</h4><p>可重复读：在第一次读取数据时生成一个 ReadView，这个 ReadView 会一直保持到事务结束，这样可以保证在事务中多次读取同一行数据时，读取到的数据是一致的。</p><p>读已提交：每次读取数据前都生成一个 ReadView，这样就能保证每次读取的数据都是最新的。</p><h4 id="如果两个-AB-事务并发修改一个变量，那么-A-读到的值是什么，怎么分析"><a href="#如果两个-AB-事务并发修改一个变量，那么-A-读到的值是什么，怎么分析" class="headerlink" title="如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析"></a>如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析</h4><p>事务 A 在读取时是否能读到事务 B 的修改，<strong>取决于 A 是快照读还是当前读</strong>。如果是快照读，InnoDB 会使用 MVCC 的 ReadView 判断记录版本是否可见，若事务 B 尚未提交或在 A 的视图不可见，则 A 会读到旧值；如果是当前读，则需要加锁，若 B 已提交可直接读取，否则 A 会阻塞直到 B 结束。</p><p>知识点速过：UndoLog记录数据的历史版本（记录指针来连接），ReadView可以使快照读操作不阻塞。</p><p>到这里，豁然开朗了，原来mysql的事务隔离并不是完全参考遵循三级封锁协议的，它原来是用到了MVCC来减少频繁创建锁带来的性能损耗以及优化读操作的性能。</p><h3 id="6-什么是快照读和当前读"><a href="#6-什么是快照读和当前读" class="headerlink" title="6.什么是快照读和当前读"></a>6.什么是快照读和当前读</h3><ul><li><strong>快照读（Snapshot Read）</strong>：<ul><li>读取的是符合当前事务可见性规则的历史版本数据。</li><li>不加锁，适用于非阻塞读取。</li><li>适用于 <code>REPEATABLE READ</code> 和 <code>READ COMMITTED</code> 隔离级别下的普通查询。</li></ul></li><li><strong>当前读（Current Read）</strong>：<ul><li>读取的是数据的最新版本。</li><li>通常会加锁，适用于需要最新数据的场景。</li><li>适用于 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别下的 <code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... LOCK IN SHARE MODE</code> 查询。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务总结</title>
      <link href="/2025/04/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/"/>
      <url>/2025/04/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、服务调用"><a href="#一、服务调用" class="headerlink" title="一、服务调用"></a>一、服务调用</h1><p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为<strong>RPC</strong>，即远程过程调用。RPC的实现方式有很多，比如：</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li></ul><h2 id="1-RestTemplate"><a href="#1-RestTemplate" class="headerlink" title="1.RestTemplate"></a>1.RestTemplate</h2><p>Spring给我们提供了一个RestTemplate的API，可以方便的实现Http请求的发送。</p><p>使用RestTemplate的基本步骤如下</p><ul><li>注册RestTemplate到Spring容器</li><li>调用RestTemplate的API发送请求，常见方法有：<ul><li>getForObject：发送Get请求并返回指定类型对象</li><li>PostForObject：发送Post请求并返回指定类型对象</li><li>put：发送PUT请求</li><li>delete：发送Delete请求</li><li><strong>exchange</strong>：发送任意类型请求，返回ResponseEntity</li></ul></li></ul><p><img src="/../images/image-20250410102942741.png" alt="image-20250410102942741"></p><p>利用RestTemplate发送http请求与前端ajax发送请求非常相似，包含以下信息：</p><ul><li>1 请求路径</li><li>2 请求方式</li><li>3 请求体</li><li>4 返回值类型</li><li>5 请求参数</li></ul><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 2.查询商品</span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">        &quot;http://127.0.0.1:8081/items?ids=&#123;ids&#125;&quot;,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        null,</span><br><span class="line">        new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        Map.of(&quot;ids&quot;, CollUtils.join(itemIds, &quot;,&quot;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h4><ol><li><strong>第四个参数中为什么不能直接写 <code>List&lt;ItemDTO&gt;.class</code>？</strong></li></ol><p>在 Java 中，泛型类型在运行时会被擦除（即类型信息丢失）。这意味着 <code>List&lt;ItemDTO&gt;</code> 在运行时会被当作普通的 <code>List</code> 处理，而 <code>ItemDTO</code> 的类型信息会被丢弃。因此，<code>List&lt;ItemDTO&gt;.class</code> 是不合法的，因为 Java 无法在运行时识别 <code>List&lt;ItemDTO&gt;</code> 的具体类型。</p><ol start="2"><li><strong><code>ParameterizedTypeReference</code> 的作用</strong></li></ol><p><code>ParameterizedTypeReference</code> 是 Spring 提供的一个工具类，用于显式地指定泛型类型。它通过匿名内部类的方式保留了泛型类型信息，使得 Spring 的 <code>RestTemplate</code> 可以正确解析返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这行代码告诉 <code>RestTemplate</code>，返回值是一个 <code>List&lt;ItemDTO&gt;</code> 类型的对象。</p><ol start="3"><li><strong>如果直接使用 <code>List.class</code> 会发生什么？</strong></li></ol><p>如果你直接使用 <code>List.class</code>，代码可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;List&gt; response = restTemplate.exchange(</span><br><span class="line">    <span class="string">&quot;http://127.0.0.1:8081/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">    HttpMethod.GET,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    List.class,</span><br><span class="line">    Map.of(<span class="string">&quot;ids&quot;</span>, CollUtils.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这种情况下，<code>RestTemplate</code> 只知道返回值是一个 <code>List</code>，但不知道 <code>List</code> 中的元素类型是 <code>ItemDTO</code>。因此，<code>RestTemplate</code> 无法正确解析返回值为 <code>List&lt;ItemDTO&gt;</code>，可能会导致运行时错误。</p><ol start="4"><li><strong>为什么需要 <code>ParameterizedTypeReference</code>？</strong></li></ol><p><code>ParameterizedTypeReference</code> 的设计正是为了解决泛型擦除的问题。它允许你在运行时保留泛型类型信息，使得 <code>RestTemplate</code> 能够正确解析返回值。</p><h2 id="2-注册中心"><a href="#2-注册中心" class="headerlink" title="2.注册中心"></a>2.注册中心</h2><p>问题引入</p><p>假设当前微服务面对高并发的调用请求，压力大。这时我们需要部署多个服务实例。</p><p><img src="/../images/image-20250410103750346.png" alt="image-20250410103750346"></p><p>此时，每个<code>item-service</code>的实例其IP或端口不同，那么问题来了：</p><ul><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心。</p><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="/../images/image-20250410104201511.png" alt="image-20250410104201511"></p><p>流程如下：</p><ul><li>服务启动时服务提供者就会注册自己的服务信息(服务名、IP、端口)到注册中心(按服务名决定归属哪个服务)。</li><li>服务调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（一个服务可能有多实例部署）。</li><li>服务调用者会对实例列表<strong>负载均衡</strong>，挑选一个实例调用。</li><li>服务调用者挑选后向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，从而将其从其服务的实例列表中剔除</li><li>当服务有新的实例启动时，会发送注册服务的请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心的服务实例列表更新时，会主动通知微服务，更新本地服务列表</li></ul><p><strong>注意：</strong>微服务通常会维护一个本地缓存的服务列表，用于优化服务调用的性能（避免每次调用时都从注册中心获取服务列表）。当注册中心通知微服务服务列表变更时，微服务会根据收到的增量更新，及时刷新它们本地缓存的服务列表。这样，在下一次进行跨服务调用时，微服务可以确保使用的是最新的服务实例信息。</p><h3 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h3><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异。Nacos是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能。</p><h4 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h4><p>这里是基于docker部署nacos</p><p>1.将nacos的sql文件导入到docker的mysql容器中</p><p>2.在<code>nacos/custom.env</code>文件中，有一个MYSQL_SERVICE_HOST也就是mysql地址，需要修改为你自己的虚拟机IP地址</p><p>3.将<code>nacos</code>目录上传至虚拟机的<code>/root</code>目录。</p><p>4.进入root目录，然后执行下面的docker命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2</span><br></pre></td></tr></table></figure><p>启动完成后，访问下面地址：<a href="http://192.168.10.101:8848/nacos%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%B0%86%60192.168.10.101%60%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAIP%E5%9C%B0%E5%9D%80%E3%80%82">http://192.168.10.101:8848/nacos，注意将`192.168.10.101`替换为你自己的虚拟机IP地址。</a></p><p>首次访问会跳转到登录页，<strong>账号密码都是nacos</strong></p><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>接下来，我们把<code>item-service</code>注册到Nacos，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>重启</li></ul><p><strong>1.添加依赖</strong></p><p>在<code>item-service</code>的<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.配置Nacos</strong></p><p>在<code>item-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><p><strong>3.启动服务实例</strong></p><p>为了测试一个服务多个实例的情况，我们再配置一个<code>item-service</code>的部署实例：</p><p><img src="/../images/image-20250410120015322.png" alt="image-20250410120015322"></p><p>然后配置启动项，注意重命名并且配置新的端口，避免冲突：</p><p><img src="/../images/image-20250410120036519.png" alt="image-20250410120036519"></p><p>重启<code>item-service</code>的两个实例：</p><p>访问nacos控制台，可以发现服务注册成功：</p><p><img src="/../images/image-20250410202356900.png" alt="image-20250410202356900"></p><p>点击详情，可以查看到<code>item-service</code>服务的两个实例信息：</p><p><img src="/../images/image-20250410120125855.png" alt="image-20250410120125855"></p><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>发现并调用服务</li></ul><p><strong>1.引入依赖</strong></p><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>我们在<code>cart-service</code>中的<code>pom.xml</code>中添加下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><p>因此，等一会儿<code>cart-service</code>启动，同样会注册到Nacos</p><p><strong>2.配置Nacos地址</strong></p><p>在<code>cart-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><p><strong>3.发现并调用服务</strong></p><p>接下来，服务调用者<code>cart-service</code>就可以去订阅<code>item-service</code>服务了。不过item-service有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IP的hash</li><li>最近最少访问</li><li>…</li></ul><p>这里我们可以选择最简单的随机负载均衡。</p><p>另外，服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用：</p><p><img src="/../images/image-20250410121727177.png" alt="image-20250410121727177"></p><p>接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的IP和端口：</p><p>但现在不需要了，我们通过DiscoveryClient发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：</p><p><img src="/../images/image-20250410121817031.png" alt="image-20250410121817031"></p><h2 id="3-OpenFeign"><a href="#3-OpenFeign" class="headerlink" title="3.OpenFeign"></a>3.OpenFeign</h2><p><img src="/../images/image-20250410204717449.png" alt="image-20250410204717449"></p><p>虽然上面我们可以使用RestTemplate发起远程调用，但还是有些复杂了，可以用更简单的方式实现，那就是OpenFeign。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>以cart-service为例</p><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-给启动类添加-EnableFeignClients注解"><a href="#2-给启动类添加-EnableFeignClients注解" class="headerlink" title="2.给启动类添加@EnableFeignClients注解"></a>2.给启动类添加@EnableFeignClients注解</h4><p><img src="/../images/image-20250410203057493.png" alt="image-20250410203057493"></p><h4 id="3-新建一个ItemClient接口"><a href="#3-新建一个ItemClient接口" class="headerlink" title="3.新建一个ItemClient接口"></a>3.新建一个ItemClient接口</h4><p><img src="/../images/image-20250410203222224.png" alt="image-20250410203222224"></p><p>参考所需的item微服务下的api信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据id批量查询商品&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> itemService.queryItemByIds(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依照上面请求方式注解和请求参数，添加信息到ItemClient中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient(&quot;item-service&quot;)</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;/items&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p><strong>注意</strong>，这里@GetMapping(“&#x2F;items”)中的items是对应controller的RequestMapping中的参数，别忘了加上。</p><p><img src="/../images/image-20250410203800827.png" alt="image-20250410203800827"></p><p>还有，别忘了在启动类里添加需要的client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class, OrderClient.class&#125;, defaultConfiguration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><h4 id="4-使用OpenFeign"><a href="#4-使用OpenFeign" class="headerlink" title="4.使用OpenFeign"></a>4.使用OpenFeign</h4><p>在CartServiceImpl中注入ItemClient后直接调用对应的方法即可</p><p><img src="/../images/image-20250410210633955.png" alt="image-20250410210633955"></p><p>如上所示，大大减少了代码的复杂度。</p><p>feign替我们完成了服务拉取、负载均衡、发送http请求的所有工作，是不是看起来优雅多了。</p><p>而且，这里我们不再需要RestTemplate了，还省去了RestTemplate的注册。</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Feign底层发起http请求时，依赖于其他的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection: 默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>所以我们需要使用带有连接池的客户端来代替默认的HttpURLConnection。下面以OKHttp为例。</p><p>提问：这里的连接池是指什么？</p><p>连接池指的是一组预先创建的 HTTP 连接，这些连接可以被重复使用，而不是每次请求都创建一个新的连接。</p><p>在 Feign 中，不同的 HTTP 客户端实现对连接池的支持有所不同：</p><p>HttpURLConnection：</p><p>这是 Java 的默认 HTTP 客户端实现，不支持连接池。每次请求都会创建一个新的连接，请求完成后连接会被关闭。这种方式在高并发场景下性能较差。</p><p>Apache HttpClient：</p><p>这是一个功能强大的 HTTP 客户端库，支持连接池。通过配置连接池，可以复用连接，提高性能。</p><p>OKHttp：</p><p>这是另一个流行的 HTTP 客户端库，也支持连接池。OKHttp 的连接池实现高效且易于配置，适合在高并发场景下使用</p><h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><p>在<code>cart-service</code>的<code>pom.xml</code>中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-开启连接池"><a href="#2-开启连接池" class="headerlink" title="2.开启连接池"></a>2.开启连接池</h4><p>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#启用OKHttp连接池</span></span><br></pre></td></tr></table></figure><p>重启服务后，连接池就生效了</p><h3 id="公共module抽取"><a href="#公共module抽取" class="headerlink" title="公共module抽取"></a>公共module抽取</h3><p>问题引入：当前项目中除了购物车模块需要远程调用商品模块，下单模块也需要，此时，又需要在下单模块里创建ItemClient接口，这不是就相当于<strong>重复编码</strong>了吗。</p><p>避免重复编码的方法就是抽取，抽取一共有以下两种方法：</p><p>方法一：抽取到微服务之外的公共module</p><p>方法二：每个微服务自己抽取一个module(模块可以被其他服务引入)</p><p>两种方法的项目结构图如下所示</p><p><img src="/../images/image-20250411190709970.png" alt="image-20250411190709970"></p><p>方法1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p><p>方法2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><p>因为当前item-service已经创建好了（已经是服务启动类了），无法继续创建模块。所以这里我们采用方法一</p><p>针对方法2的思路理清：</p><p>方法2本质就是在每个微服务平级旁边再加两个模块，专门用于给其他模块调用的。</p><p>针对方法1的耦合度高理解：</p><p>方法1因为是一个公共模块，所以所有需要远程调用的服务都需要引入该依赖，导致这一个公共模块包含了很多针<strong>对于某一个调用者模块来说多余的dto类和client接口</strong>。</p><h4 id="1-创建模块，导入依赖"><a href="#1-创建模块，导入依赖" class="headerlink" title="1.创建模块，导入依赖"></a>1.创建模块，导入依赖</h4><p>这里我已经创建好了，注意以hmall为父工程</p><p><img src="/../images/image-20250411191431781.png" alt="image-20250411191431781"></p><p>创建好模块后导入如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--open feign--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- load balancer--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- swagger 注解依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，把cart-service中的ItemDTO和ItemClient复制到当前模块中</p><p><img src="/../images/image-20250411191826445.png" alt="image-20250411191826445"></p><p>现在，任何微服务要调用<code>item-service</code>中的接口，只需要引入<code>hm-api</code>模块依赖即可，无需自己编写Feign客户端了。此时，任何微服务都无需在自己包下面创建所需的其他服务的dto和client了。</p><h4 id="2-启动报错"><a href="#2-启动报错" class="headerlink" title="2.启动报错"></a>2.启动报错</h4><p>此时我们删除cart-service中的client和dto，并引入这个公共模块，会发现启动后报错了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ldy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250411192641481.png" alt="image-20250411192641481"></p><p>这里因为<code>ItemClient</code>现在定义到了<code>com.hmall.api.client</code>包下，而cart-service的启动类定义在<code>com.hmall.cart</code>包下，扫描不到<code>ItemClient</code>，所以报错了。</p><p>注意：@SpringBootApplication这个注解中包含了@ComponentScan, 这个注解会扫描当前包(com.hmall.cart)中的文件。</p><h4 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法"></a>3.解决方法</h4><p>解决方法有两种,都是配置启动类中的**@EnableFeignClients**注解参数：</p><p>1.在@EnableFeignClients中添加basePackages参数为client所在位置</p><p><img src="/../images/image-20250411192959123.png" alt="image-20250411192959123"></p><p>2.在@EnableFeignClients中添加clients参数为所需的client.class</p><p><img src="/../images/image-20250411193127752.png" alt="image-20250411193127752"></p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时（这里指的是springboot项目的日志级别，也就是说只有当前所在的包的日志级别为DEBUG时，feign才有可能输出日志），才会输出日志（feign的日志）。而且其日志级别有4级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>Openfegin默认的日志级别是None,所以我们看不到任何连接相关的日志信息</p><p>注意：一般也不开启feign的日志配置，只有在需要调试feign的时候才开启日志，因为日志输出的内容有很多，输出时会影响性能。</p><h4 id="1-定义日志级别"><a href="#1-定义日志级别" class="headerlink" title="1.定义日志级别"></a>1.定义日志级别</h4><p>在hm-api模块下新建一个配置类，定义Feign的日志级别：</p><p><img src="/../images/image-20250411194425248.png" alt="image-20250411194425248"></p><p>注意不要导错包了，是<code>feign.Logger</code>这个包。</p><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>尽管我们将Logger.Level.FULL这个日志级别引入了容器，但我们还需要配置这个日志级别才能成功输出日志。而配置方式有两种。</p><ul><li><strong>局部</strong>生效：在某个<code>FeignClient</code>中配置，只对当前<code>FeignClient</code>生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, configuration = FeignConfig.class.class)</span></span><br></pre></td></tr></table></figure><ul><li><strong>全局</strong>生效：在<code>@EnableFeignClients</code>（启动类上）中配置，针对所有<code>FeignClient</code>生效。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignConfig.class.class)</span></span><br></pre></td></tr></table></figure><p>日志格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; GET http://item-service/items?ids=100000006163 HTTP/1.1</span><br><span class="line">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; END HTTP (0-byte body)</span><br><span class="line">17:35:32:278 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- HTTP/1.1 200  (127ms)</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] connection: keep-alive</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] content-type: application/json</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] date: Fri, 26 May 2023 09:35:32 GMT</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] keep-alive: timeout=60</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] transfer-encoding: chunked</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] </span><br><span class="line">17:35:32:280 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] [&#123;&quot;id&quot;:100000006163,&quot;name&quot;:&quot;巴布豆(BOBDOG)柔薄悦动婴儿拉拉裤XXL码80片(15kg以上)&quot;,&quot;price&quot;:67100,&quot;stock&quot;:10000,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t23998/350/2363990466/222391/a6e9581d/5b7cba5bN0c18fb4f.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉拉裤&quot;,&quot;brand&quot;:&quot;巴布豆&quot;,&quot;spec&quot;:&quot;&#123;&#125;&quot;,&quot;sold&quot;:11,&quot;commentCount&quot;:33343434,&quot;isAD&quot;:false,&quot;status&quot;:2&#125;]</span><br><span class="line">17:35:32:281 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- END HTTP (369-byte body)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>nacos就是一个微服务注册中心，解决了<strong>路由写死</strong>问题。</p><p>而openFeign是一个依赖,利用到了nacos中注册的微服务,方便我们进行远程调用,此外也通过引入负载均衡器依赖实现负载均衡。</p><h1 id="二、网关"><a href="#二、网关" class="headerlink" title="二、网关"></a>二、网关</h1><h2 id="1-网关路由"><a href="#1-网关路由" class="headerlink" title="1.网关路由"></a>1.网关路由</h2><p>网关顾名思义，就是指<strong>网络的关口</strong>。数据在网络间传输时，从一个网络传输到另一个网络时，需要经过网关来进行安全校验，并做数据的路由和转发。</p><p><img src="/../images/image-20250413005456114.png" alt="image-20250413005456114"></p><p>所以，有了网关之后，前端的请求就不能直接访问相应的微服务，而是需要先请求网关。</p><ul><li>网关可以做安全控制，例如登录身份校验，校验通过才放行</li><li>通过身份认证后，会根据请求判断应该访问的是哪个微服务，并把请求转发过去。</li></ul><p><img src="/../images/image-20250413010110735.png" alt="image-20250413010110735"></p><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><p>这里以SpringCloudGateway为例。</p><h3 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h3><p>由于网关本身也是个独立的微服务，所以需要新创建一个模块实现功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><p>1.创建网关模块</p><p><img src="/../images/image-20250413010441595.png" alt="image-20250413010441595"></p><p>2.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.新建启动类</p><p><img src="/../images/image-20250413010713403.png" alt="image-20250413010713403"></p><p>4.配置网关路由</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><p>5.测试</p><p>启动网关微服务(8080端口)和item微服务(8081端口)，并访问如下地址</p><p><a href="http://localhost:8080/items/page?pageNo=1&pageSize=1">localhost:8080&#x2F;items&#x2F;page?pageNo&#x3D;1&amp;pageSize&#x3D;1</a></p><p><img src="/../images/image-20250413011111028.png" alt="image-20250413011111028"></p><p>可以看到，成功访问到了item微服务的接口。</p><p>地址转换规则如下</p><p><a href="http://localhost:8080/items/page?pageNo=1&pageSize=1">localhost:8080&#x2F;items&#x2F;page?pageNo&#x3D;1&amp;pageSize&#x3D;1</a> &#x3D;》 <a href="http://localhost:8081/items/page?pageNo=1&pageSize=1">localhost:8081&#x2F;items&#x2F;page?pageNo&#x3D;1&amp;pageSize&#x3D;1</a></p><p>可以看到，仅仅是端口号不同，访问的到的内容却是一致的。</p><p>主要是因为我们配置文件中的如下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">  <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br></pre></td></tr></table></figure><p>其中，id只是一个标识符，无实际意义。</p><h3 id="2-路由过滤"><a href="#2-路由过滤" class="headerlink" title="2.路由过滤"></a>2.路由过滤</h3><p>路由规则的定义语法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>我们可以查询对应的配置类是如何定义配置信息的</p><p><img src="/../images/image-20250413012112284.png" alt="image-20250413012112284"></p><p><img src="/../images/image-20250413012133585.png" alt="image-20250413012133585"></p><p><img src="/../images/image-20250413012242147.png" alt="image-20250413012242147"></p><p>其中，四个属性的详细意义如下</p><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>对于<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><h2 id="2-网关登录校验"><a href="#2-网关登录校验" class="headerlink" title="2.网关登录校验"></a>2.网关登录校验</h2><p>在单体架构项目里，对于每次请求，我们只需要进行一次用户信息校验，把用户信息存入ThreadLocal中即可实现所有服务在当前线程中均可访问用户信息。而在微服务架构下，微服务之间没有共享数据，意味着每个微服务都要进行登录校验。但假设当前微服务需要远程调用其他微服务，那么势必要将校验信息再次传递过去，类似：微服务1获取token -&gt; 微服务1校验通过，保存token -&gt; 远程调用，传递token -&gt;  微服务2校验通过，保存token -&gt; 远程调用….. 。这么看，还需要保存token,并传递，显然不优雅。</p><h3 id="1-鉴权思路分析"><a href="#1-鉴权思路分析" class="headerlink" title="1.鉴权思路分析"></a>1.鉴权思路分析</h3><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>此时，登录校验流程如图</p><p><img src="/../images/image-20250413014653831.png" alt="image-20250413014653831"></p><p>不过，这里存在几个问题：</p><ul><li>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</li><li>网关校验JWT之后，如何将用户信息传递给微服务？</li><li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li></ul><p>这些问题在下面内容会解决。</p><h3 id="2-网关过滤器"><a href="#2-网关过滤器" class="headerlink" title="2.网关过滤器"></a>2.网关过滤器</h3><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="/../images/image-20250413234231290.png" alt="image-20250413234231290"></p><p>如图所示：</p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。之前指的是在请求发送到微服务之前处理，而之后指的是对微服务响应的信息进行处理。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>如图中所示，最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前，这就符合我们的需求了！</p><p>那么，该如何实现一个网关过滤器呢？</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>. </li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置。</li></ul><h4 id="GatewayFilter路由过滤器"><a href="#GatewayFilter路由过滤器" class="headerlink" title="GatewayFilter路由过滤器"></a>GatewayFilter路由过滤器</h4><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code>.</p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p><p>使用的使用只需要在application.yaml中这样配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">          <span class="attr">filters:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span> <span class="comment"># 逗号之前是请求头的key，逗号之后是value</span></span><br></pre></td></tr></table></figure><p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># default-filters下的过滤器可以作用于所有路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br></pre></td></tr></table></figure><p>这里我们需要先提一下，filters使用的<code>AddRequestHeader=key, value</code>中，AddRequestHeader是AddRequestHeaderGatewayFilterFacotry去掉GateWayFilterFactory后缀的结果。使用其他过滤器也要去掉相同的后缀。</p><h4 id="自定义过滤器GatewayFilter"><a href="#自定义过滤器GatewayFilter" class="headerlink" title="自定义过滤器GatewayFilter"></a>自定义过滤器GatewayFilter</h4><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是继承<code>AbstractGatewayFilterFactory</code>。最简单的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">//获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">//处理信息略</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行了&quot;</span>);</span><br><span class="line">                <span class="comment">//放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！</p><p>然后在yaml配置中这样使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">                <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在yaml文件中使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h4><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;未登录，无法访问&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="comment">// return chain.filter(exchange);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-登录校验"><a href="#3-登录校验" class="headerlink" title="3.登录校验"></a>3.登录校验</h3><p>这里我们使用GlobalFiilter来实现登录校验</p><p>前提条件：</p><p>1.将配置类和工具类信息从hm-service中复制过来</p><p><img src="/../images/image-20250414003120862.png" alt="image-20250414003120862"></p><p><img src="/../images/image-20250414003147782.png" alt="image-20250414003147782"></p><p>2.复制密钥文件</p><p><img src="/../images/image-20250414003210845.png" alt="image-20250414003210845"></p><p>3.编写代码</p><p>登录校验过滤代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AuthProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtTool jwtTool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthProperties authProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取请求信息</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">//2.判断是否需要拦截</span></span><br><span class="line">        <span class="keyword">if</span>(isExclude(request.getPath().toString()))&#123;</span><br><span class="line">            <span class="comment">//不需要则直接放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.获取请求头的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; headers = request.getHeaders().get(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(headers != <span class="literal">null</span> &amp;&amp; !headers.isEmpty())&#123;</span><br><span class="line">            token = headers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.获取用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//校验token,错误会抛异常</span></span><br><span class="line">            userId = jwtTool.parseToken(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.保存用户id信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户id:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否在拦截路径之外</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExclude</span><span class="params">(String antPath)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String pathPattern : authProperties.getExcludePaths()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(antPathMatcher.match(pathPattern, antPath))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，</strong>别忘了加上注解<code>@EnableConfigurationProperties(AuthProperties.class)</code>启用相应配置文件类，以及注入相应的所需实例，为避免对每个实例使用@Autowried注入,可以使用@RequiredArgsConstructor注解，这样只需要定义全局常量即可。</p><h3 id="4-微服务获取用户信息"><a href="#4-微服务获取用户信息" class="headerlink" title="4.微服务获取用户信息"></a>4.微服务获取用户信息</h3><p>1.首先在网关的过滤器中，将用户信息存入请求头传递给下游微服务</p><p><img src="/../images/image-20250414231001233.png" alt="image-20250414231001233"></p><p>注意传递用户信息的api写法，mutate()方法可以对下游请求做更改，.request表示对请求做处理，利用builder可以对请求中各种信息做修改。</p><p>2.给每个微服务设置拦截器</p><p>拦截器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoIterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">//2.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(userInfo))&#123;</span><br><span class="line">            <span class="comment">//不为空串则保存到ThreadLocal里</span></span><br><span class="line">            UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户信息</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.拦截器配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoIterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为每个微服务都需要用户信息，且这里拦截器返回的都是true(<strong>网关已经帮我们对需要校验的路径校验好了</strong>，所以没必要再次校验了)，所以可以设置拦截器和其配置类在公共模块hm-common,供所有微服务注入。</p><p>不过，要注意，这个公共模块的配置类默认是扫描不到的。我只知道有两种方法可以设置。</p><p>法1.给微服务启动类设置组件扫描路径</p><p><img src="/../images/image-20250414231646335.png" alt="image-20250414231646335"></p><p>这里是以com.hmall为前缀的所有包都会被扫描，而hm-common这个公共模块正好也是com.hmall为前缀，所以导入这个依赖也会扫描相应的组件。</p><p>法2.在公共模块设置spring.factories</p><p>基于SpringBoot的自动装配原理，我们要将扫描路径添加到公共模块的<code>resources</code>目录下的<code>META-INF/spring.factories</code>文件中：</p><p><img src="/../images/image-20250414231846835.png" alt="image-20250414231846835"></p><p>文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.hmall.common.config.MyBatisConfig,\</span><br><span class="line">  com.hmall.common.config.JsonConfig,\</span><br><span class="line">  com.hmall.common.config.MvcConfig,\</span><br><span class="line">  com.hmall.common.config.MqConfig</span><br></pre></td></tr></table></figure><p>这样每个导入这个模块的微服务都会扫描这个模块下的组件。</p><h3 id="5-OpenFeign传递用户"><a href="#5-OpenFeign传递用户" class="headerlink" title="5.OpenFeign传递用户"></a>5.OpenFeign传递用户</h3><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p><p><img src="/../images/image-20250414232306472.png" alt="image-20250414232306472"></p><p>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁！</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p><p>由于<code>FeignClient</code>全部都是在<code>hm-api</code>模块，因此我们在<code>hm-api</code>模块的<code>com.hmall.api.config.DefaultFeignConfig</code>中编写这个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeafualtFeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate requestTemplate)</span> &#123;</span><br><span class="line">                <span class="comment">//1.获取用户信息</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">                <span class="comment">//2.判断用户信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(userId == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果为空则直接跳过</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.不为空，则设置到请求头中，传递给下游微服务</span></span><br><span class="line">                requestTemplate.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1.这里UserContext在common模块，记得引入依赖</p><p>2.这里创建配置类后，微服务默认是扫描不到这个配置类的，记得给每个需要OpenFign拦截器的启动类上添加配置类.class到注解属性中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = ItemClient.class, defaultConfiguration = DeafualtFeignConfig.class)</span></span><br></pre></td></tr></table></figure><p>3.此外，这里注册RequestInterceptor类型的bean能生效的原因：当你使用 Feign 客户端发起调用时，Feign 会创建一个 RequestTemplate 对象来准备请求。</p><p>在请求发送之前，Feign 会遍历所有已注册的 RequestInterceptor 拦截器，并依次调用它们的 apply(RequestTemplate template) 方法。</p><h1 id="三、配置管理"><a href="#三、配置管理" class="headerlink" title="三、配置管理"></a>三、配置管理</h1><p>到目前为止我们已经解决了微服务相关的几个问题：</p><ul><li>微服务远程调用</li><li>微服务注册、发现</li><li>微服务请求路由、负载均衡</li><li>微服务登录用户信息传递</li></ul><p>不过，现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而<strong>Nacos</strong>不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="/../images/image-20250414234305911.png" alt="image-20250414234305911"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，<strong>实现配置热更新</strong>。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h3 id="1-配置共享"><a href="#1-配置共享" class="headerlink" title="1.配置共享"></a>1.配置共享</h3><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><h4 id="添加共享配置"><a href="#添加共享配置" class="headerlink" title="添加共享配置"></a>添加共享配置</h4><p>至于具体怎么配置就不进行相关介绍了，具体可以去看相关文档<a href="https://b11et3un53m.feishu.cn/wiki/UMgpwmmQKisWBIkaABbcwAPonVf">day04-微服务02 - 飞书云文档</a></p><h4 id="拉取共享配置"><a href="#拉取共享配置" class="headerlink" title="拉取共享配置"></a>拉取共享配置</h4><p>这里要注意几个问题：</p><p>1.Nacos中的配置文件的读取是先于微服务配置文件<code>application.yaml</code>的。所以如果我们把nacos地址写在<code>application.yaml</code>文件中，那么这个微服务启动注册到nacos后也没法读取nacos中的相关配置了。</p><p>这里就需要使用一个名为<code>bootstrap.yaml</code>文件。这个配置文件的加载优先于nacos中的配置文件。所以需要把nacos相关配置信息写入这个文件中。</p><p><img src="/../images/image-20250415183255455.png" alt="image-20250415183255455"></p><p>具体步骤如下</p><p>（1）给微服务引入相关依赖</p><p>注意力，这里的nacos配置依赖和注册不是同一个依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）编写bootstrap.yaml配置文件</p><p><img src="/../images/image-20250415183333079.png" alt="image-20250415183333079"></p><p>如上所示，除了写nacos地址之外，还记得配置微服务名称和要读取的nacos中的配置文件</p><p>2.配置文件中的配置为了通用性，防止写死。在写值时可以使用<code>&#123;配置信息路径: 默认值&#125;</code>(例如<code>&#123;hm.db.user:root&#125;</code>)。写了这个之后，将来会读取微服务中的配置文件application.yaml中的信息，若存在则赋值，否则使用默认值。</p><h3 id="2-配置热更新"><a href="#2-配置热更新" class="headerlink" title="2.配置热更新"></a>2.配置热更新</h3><p>配置热更新就是为了防止某些参数写死，导致需要修改时需要重新打包部署。而是通过配置文件的更新，配置类会监听配置信息的变更，实时更新相关参数信息。</p><p>具体实习简单来说就是将参数信息配置到nacos中，其他的像是创建配置类、使用配置类都和正常使用没区别。</p><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>有很多的业务相关参数，将来可能会根据实际情况临时调整。例如购物车业务，购物车数量有一个上限，默认是10，对应代码如下：</p><p><img src="/../images/image-20250415184557786.png" alt="image-20250415184557786"></p><p>现在这里购物车是写死的固定值，我们应该将其配置在配置文件中，方便后期修改。</p><p>但现在的问题是，即便写在配置文件中，修改了配置还是需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到Nacos的配置热更新能力了，分为两步：</p><ul><li>在Nacos中添加配置</li><li>在微服务读取配置</li></ul><h4 id="在Nacos中添加配置"><a href="#在Nacos中添加配置" class="headerlink" title="在Nacos中添加配置"></a>在Nacos中添加配置</h4><h4 id="在微服务中读取配置"><a href="#在微服务中读取配置" class="headerlink" title="在微服务中读取配置"></a>在微服务中读取配置</h4><p>配置信息类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String maxCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250415185145800.png" alt="image-20250415185145800"></p><h3 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3.动态路由"></a>3.动态路由</h3><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，我们无法利用配置热更新来实现路由更新。</p><p>因此，我们必须<strong>监听Nacos的配置变更</strong>，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><h4 id="1-监听Nacos配置变更"><a href="#1-监听Nacos配置变更" class="headerlink" title="1.监听Nacos配置变更"></a>1.监听Nacos配置变更</h4><p>在Nacos官网中给出了手动监听Nacos配置变更的SDK：</p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span></span><br></pre></td></tr></table></figure><p>请求参数说明：</p><table><thead><tr><th align="left"><strong>参数名</strong></th><th align="left"><strong>参数类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">dataId</td><td align="left">string</td><td align="left">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节。</td></tr><tr><td align="left">group</td><td align="left">string</td><td align="left">配置分组，一般是默认的DEFAULT_GROUP。</td></tr><tr><td align="left">listener</td><td align="left">Listener</td><td align="left">监听器，配置变更进入监听器的回调函数。</td></tr></tbody></table><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里核心的步骤有2步：</p><ul><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ul><p>由于我们采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了：</p><p><img src="/../images/image-20250415213319784.png" alt="image-20250415213319784"></p><p>NacosConfigManager中是负责管理Nacos的ConfigService的，具体代码如下：</p><p><img src="/../images/image-20250415213403322.png" alt="image-20250415213403322"></p><p>因此，只要我们拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了。</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getConfigAndSignListener</span><span class="params">(</span></span><br><span class="line"><span class="params">    String dataId, // 配置文件id</span></span><br><span class="line"><span class="params">    String group, // 配置组，走默认</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeoutMs, // 读取配置的超时时间</span></span><br><span class="line"><span class="params">    Listener listener // 监听器</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> NacosException;</span><br></pre></td></tr></table></figure><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p><h4 id="2-更新路由"><a href="#2-更新路由" class="headerlink" title="2.更新路由"></a>2.更新路由</h4><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.gateway.route;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是RouteDefinition，之前我们见过，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上JSON配置就等同于：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>之所以使用Json格式存储路由是因为Json有现成的工具类可以转换成RouteDefinition这个类，而yaml格式文件则不好转换。</p><h4 id="3-实现动态路由"><a href="#3-实现动态路由" class="headerlink" title="3.实现动态路由"></a>3.实现动态路由</h4><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.编写bootstrap.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.101</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>3.创建动态路由类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存更新过的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1.注册监听器并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 2.首次启动时，更新一次配置</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);</span><br><span class="line">        <span class="comment">// 1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2.更新前先清空旧路由</span></span><br><span class="line">        <span class="comment">// 2.1.清除旧路由</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">// 2.2.判断是否有新的路由要更新</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;</span><br><span class="line">            <span class="comment">// 无新路由配置，直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.更新路由</span></span><br><span class="line">        routeDefinitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1.更新路由</span></span><br><span class="line">            writer.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">// 3.2.记录路由id，方便将来删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中引入的如下两个类，write用于保存路由信息，nacosConfigManager用于获取拉取配置并设置监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br></pre></td></tr></table></figure><h1 id="四、微服务保护"><a href="#四、微服务保护" class="headerlink" title="四、微服务保护"></a>四、微服务保护</h1><h2 id="问题引入-1"><a href="#问题引入-1" class="headerlink" title="问题引入"></a>问题引入</h2><h3 id="1-业务健壮性问题"><a href="#1-业务健壮性问题" class="headerlink" title="1.业务健壮性问题"></a>1.业务健壮性问题</h3><p>当微服务之间相互调用时，若某个调用的微服务发生故障，那么整体业务就失败了。但从业务角度来说，即使某些情况下失败，依然需要展示其余某些数据。</p><p>拿购物车举例，在获取购物车列表时，还会微服务远程调用获取商品最新的价格是，而就算获取最新商品价格失败，也不应该整个业务失败，毕竟我看的是购物车，不是最新价格。</p><h3 id="2-级联问题"><a href="#2-级联问题" class="headerlink" title="2.级联问题"></a>2.级联问题</h3><p>当前微服务并发较高，又需要远程调用其他微服务，而当被调用微服务阻塞时，会导致当前微服务也阻塞。这种因为某个接口占用资源过多，导致多个微服务的受到影响的情况就是级联问题。</p><p>依旧以购物车为例，查询购物车时，会查询当前购物车中所有商品的最新价格，当商品微服务响应时间过长时，购物车微服务也会受到影响，导致购物车Tomcat连接占用较多，所有接口的响应时间都会增加。</p><p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。</p><p><img src="/../images/image-20250415225307819.png" alt="image-20250415225307819"></p><p>这就叫<strong>级联失败</strong>问题，或者说<strong>雪崩</strong>问题</p><h2 id="服务保护方案"><a href="#服务保护方案" class="headerlink" title="服务保护方案"></a>服务保护方案</h2><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护。</p><p>以下是三种保护微服务的方法</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><h3 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h3><p>请求限流就是处理短时间大量请求打过来的问题。我们可以设个请求阈值在接口处，每秒最多可以处理多少请求，超过这个数的后面要么请求失败要么排队等待。</p><p><img src="/../images/image-20250415225901562.png" alt="image-20250415225901562"></p><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>给每个接口设置最大可以占用的线程数,以保证当前接口即使故障也不会占用当前服务的所有线程资源，以避免雪崩问题。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>服务熔断主要是处理业务健壮性问题，即当前微服务调用的其他微服务发生异常时，走相应的<strong>降级方案</strong>。</p><p><img src="/../images/image-20250416003526607.png" alt="image-20250416003526607"></p><p>所以，我们要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="1-安装和使用"><a href="#1-安装和使用" class="headerlink" title="1.安装和使用"></a>1.安装和使用</h3><p>Sentinel是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中。官方网站：</p><p><a href="https://sentinelguard.io/zh-cn/">https://sentinelguard.io/zh-cn/</a></p><p>Sentinel 的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</li></ul><p>为了方便监控微服务，我们先把Sentinel的控制台搭建出来。</p><p>1）下载jar包</p><p>下载地址：</p><p><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p><p>也可以直接使用黑马资料中提供的版本：</p><p><img src="/../images/image-20250416003758078.png" alt="image-20250416003758078"></p><p>2）运行</p><p>将jar包放在任意非中文、不包含特殊字符的目录下，重命名为<code>sentinel-dashboard.jar</code>：</p><p>打开终端输入如下命令即可启动成功</p><p><code>java &#39;-Dserver.port=8090&#39; &#39;-Dcsp.sentinel.dashboard.server=[localhost:8090](http://localhost:8090)&#39; -jar sentinel-dashboard.jar</code></p><p><img src="/../images/image-20250416004139210.png" alt="image-20250416004139210"></p><p>此时访问<code>localhost:8090</code>可看到sentinel的控制台</p><p>登录的账号密码默认都是sentinel</p><h3 id="2-微服务整合"><a href="#2-微服务整合" class="headerlink" title="2.微服务整合"></a>2.微服务整合</h3><p>(1)引入sentinel依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)配置控制台</p><p>在application.yml文件添加如下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br></pre></td></tr></table></figure><p>(3)访问<code>cart-service</code>的任意端点</p><p>重启<code>cart-service</code>，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息：</p><p><img src="/../images/image-20250416004756912.png" alt="image-20250416004756912"></p><p>点击簇点链路菜单，会看到下面的页面：</p><p><img src="/../images/image-20250416004905066.png" alt="image-20250416004905066"></p><p>所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被<code>Sentinel</code>监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）。</p><p>因此，我们看到<code>/carts</code>这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p><p>不过，需要注意的是，我们的SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是<code>/carts</code>路径：</p><p><img src="/../images/image-20250416005004505.png" alt="image-20250416005004505"></p><p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p><p>首先，在<code>cart-service</code>的<code>application.yml</code>中添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><p>然后，重启服务，通过页面访问购物车的相关接口，可以看到sentinel控制台的簇点链路发生了变化：</p><p><img src="/../images/image-20250416005226598.png" alt="image-20250416005226598"></p><p>即使路径相同，也会有请求方式前缀做区分。</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="请求限流-1"><a href="#请求限流-1" class="headerlink" title="请求限流"></a>请求限流</h3><p>在簇点链路页面点击<strong>流控</strong>即可做限流配置</p><p><img src="/../images/image-20250416005402826.png" alt="image-20250416005402826"></p><p>QPS：Queries Per Second是衡量信息检索系统（例如搜索引擎或数据库）在一秒钟内接收到的搜索流量的一种常见度量。该术语在任何请求-响应系统中都得到更广泛的使用，更正确地称为每秒请求数（RPS：Request Per Second）。</p><h3 id="线程隔离-1"><a href="#线程隔离-1" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p><p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源。这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。</p><h4 id="1-OpenFeign整合Sentinel"><a href="#1-OpenFeign整合Sentinel" class="headerlink" title="1.OpenFeign整合Sentinel"></a>1.OpenFeign整合Sentinel</h4><p>(1)修改cart-service模块的application.yml文件，开启Feign的sentinel功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><p>尽管开启了Sentinel功能，但我们还需要配置最大排队数量等参数，因为不是说超了当前QPS的部分就一定拒绝请求了，依然可以排队等待处理。</p><p>(2)配置一下cart-service模块的application.yml文件，修改tomcat连接：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">50</span> <span class="comment"># 允许的最大线程数</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">50</span> <span class="comment"># 最大排队等待数量</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">100</span> <span class="comment"># 允许的最大连接</span></span><br></pre></td></tr></table></figure><p>注意，默认情况下SpringBoot项目的tomcat最大线程数是200，允许的最大连接是8492，单机测试很难打满。 </p><p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源：</p><p><img src="/../images/image-20250416010616317.png" alt="image-20250416010616317"></p><h4 id="2-配置线程隔离"><a href="#2-配置线程隔离" class="headerlink" title="2.配置线程隔离"></a>2.配置线程隔离</h4><p>点击流控，选择并发线程数即可。</p><p><img src="/../images/image-20250416010648431.png" alt="image-20250416010648431"></p><p>假设当线程每秒可以处理2个请求，那么5个线程最多每秒可以处理10个请求，即10QPS。而超出的请求自然会被拒绝。</p><h3 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>对于上面的线程隔离还是存在几个问题。</p><p>第一，超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个<strong>降级处理</strong>逻辑。</p><p>第二，由于查询商品的延迟较高（模拟的500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</p><h4 id="1-编写降级逻辑"><a href="#1-编写降级逻辑" class="headerlink" title="1.编写降级逻辑"></a>1.编写降级逻辑</h4><p>触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。</p><p>给FeignClient编写失败后的降级逻辑有两种方式：</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p>这里以方式二为例：</p><p>（1）在hm-api模块新建一个包存放各个降级处理类</p><p><img src="/../images/image-20250416100536500.png" alt="image-20250416100536500"></p><p>如图所示，其实很简单，就是实现FallbackFactory&lt;&gt;这个类，泛型里填写要降级处理的Client接口。此时会让你实现create方法，在方法里直接return 相应的<strong>匿名内部类</strong>。</p><p>匿名内部类是什么？</p><p>匿名：没有名字的意思。内部类：写在其他类内部的类。匿名内部类的作用是简化代码。</p><p>原本我们需要创建子类或者实现类，去继承父类和实现接口，才能重写其中的方法。但是有时候我们这样做了，然而子类和实现类却只需要使用一次（定义了一个对象）。这个时候我们就可以使用匿名内部类，不用去写子类和实现类，起到简化代码的作用。<br>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="comment">//返回空集合</span></span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">//库存扣减失败就是失败了，需要事务回滚</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）将降级处理类注册为一个Bean</p><p><img src="/../images/image-20250416101626684.png" alt="image-20250416101626684"></p><p>（3）在Client接口的@FeignClient注解添加fallbackFactory属性,引入降级处理类</p><p><img src="/../images/image-20250416102007002.png" alt="image-20250416102007002"></p><h4 id="2-服务熔断"><a href="#2-服务熔断" class="headerlink" title="2.服务熔断"></a>2.服务熔断</h4><p>现在已经实现了降级逻辑，但有的时候某些接口可能频繁或者一直有问题，这个时候就没必要去访问这些微服务接口了，直接在发请求时就熔断，走降级逻辑，以减少不必要的请求时长。</p><p>这就需要我们使用Sentinel的断路器来设置熔断阈值。</p><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><p><img src="/../images/image-20250416102833959.png" alt="image-20250416102833959"></p><p>状态机包括三个状态：</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>同样，在簇点链路中点击熔断按钮</p><p><img src="/../images/image-20250416103725143.png" alt="image-20250416103725143"></p><p>图中所示是慢调用比例的熔断策略。对应的参数详解如下所示:</p><p>最大RT：响应时长超过最大RT的值就是慢调用。</p><p>熔断时长：熔断的持续时长</p><p>统计时长：多长时间统计一次</p><p>比例阈值：慢调用的比例</p><p>最小请求数：在统计时长内最少统计5个请求计算比例阈值来判断是否需要熔断</p><h1 id="五、分布式事务"><a href="#五、分布式事务" class="headerlink" title="五、分布式事务"></a>五、分布式事务</h1><p>分布式事务，顾名思义就是处理分布式情况下的事务问题。</p><p>以下单业务为例</p><p><img src="/../images/image-20250416104416162.png" alt="image-20250416104416162"></p><p>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</p><ul><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务</li></ul><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。我们必须保证整个全局事务同时成功或失败。</p><p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足ACID特性，但全局事务跨越多个服务、多个数据库，是否还能满足呢？</p><p><strong>ACID特性：</strong></p><p><strong>原子性（Atomicity）：</strong>事务是不可分割的最小操作单元，要么全部成功，要么全部失败，不会出现部分执行的情况</p><p><strong>一致性（Consistency）：</strong>事务执行前后，数据库从一个一致的状态转换到另一个一致的状态，不会出现数据违反完整性约束(例如银行扣钱不能扣成负数)的情况</p><p><strong>隔离性（Isolation）：</strong>多个事务并发执行时，每个事务都像是在独立的环境中运行，一个事务的执行不会被其他事务干扰。隔离有四个级别，最高级别时串行化（频繁的加锁）</p><p><strong>持久性（Durability）：</strong>事务一旦提交，其对数据库的改变就是永久性的，即使系统发生故障也不会丢失</p><h2 id="1-Seata"><a href="#1-Seata" class="headerlink" title="1.Seata"></a>1.Seata</h2><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在2019年开源的Seata了。</p><p><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：</p><p>就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。</p><p>Seata也不例外，在Seata的事务管理中有三个重要的角色：</p><ul><li><strong>TC</strong> <strong>(Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。 </li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。 </li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与TC交谈以<strong>注册分支事务和报告分支事务的状态</strong>，并驱动分支事务提交或回滚。</li></ul><p>seata架构图</p><p><img src="/../images/image-20250416112026023.png" alt="image-20250416112026023"></p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。</p><p>而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h3 id="（1）部署TC服务"><a href="#（1）部署TC服务" class="headerlink" title="（1）部署TC服务"></a>（1）部署TC服务</h3><p>1.准备seata数据库表并导入到数据库中</p><p><img src="/../images/image-20250416152012466.png" alt="image-20250416152012466"></p><p>执行该sql后的数据库结构</p><p><img src="/../images/image-20250416152051837.png" alt="image-20250416152051837"></p><p>2.将seata文件夹拷贝到虚拟机的&#x2F;root目录下</p><p><img src="/../images/image-20250416152239331.png" alt="image-20250416152239331"></p><p><img src="/../images/image-20250416152235697.png" alt="image-20250416152235697"></p><p>3.docker部署</p><p>在虚拟机&#x2F;root目录下执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --name seata \</span><br><span class="line">-p 8099:8099 \</span><br><span class="line">-p 7099:7099 \</span><br><span class="line">-e SEATA_IP=192.168.150.101 \</span><br><span class="line">-v ./seata:/seata-server/resources \</span><br><span class="line">--privileged=true \</span><br><span class="line">--network hm-net \</span><br><span class="line">-d \</span><br><span class="line">seataio/seata-server:1.5.2</span><br></pre></td></tr></table></figure><p>注意把SEATA_IP换成你的虚拟机ip以及加入和mysql、nacos同一个的网络中。</p><h3 id="（2）微服务集成Seata"><a href="#（2）微服务集成Seata" class="headerlink" title="（2）微服务集成Seata"></a>（2）微服务集成Seata</h3><p>1.引入相应依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为我们需要让seata相关配置可以热更新，所以除了seata依赖外，还需要引入nacos统一配置管理和bootstrap依赖。</p><p>共享的seata配置信息如下</p><p><img src="/../images/image-20250416153948770.png" alt="image-20250416153948770"></p><p>2.bootstrap.yml文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trade-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">cart-service.yaml</span> <span class="comment"># cart参数配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-seata.yaml</span> <span class="comment"># seata配置</span></span><br></pre></td></tr></table></figure><p>3.给每个引入seata的微服务所连接的数据库创建undo_log表</p><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。</p><p><img src="/../images/image-20250416155701064.png" alt="image-20250416155701064"></p><p>如此，我们的分布式事务实现所需的所有环境都以及配好了。</p><h3 id="（3）测试"><a href="#（3）测试" class="headerlink" title="（3）测试"></a>（3）测试</h3><p>使用分布式事务需要使用<code>@GlobalTransactional</code>注解</p><p><code>@GlobalTransactional</code>注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。</p><p>所以我们只需要在方法起始入口将<code>@Transactional</code>注解修改为<code>@GlobalTransactional</code>即可。</p><p><img src="/../images/image-20250416175056045.png" alt="image-20250416175056045"></p><p>我们重启<code>trade-service</code>、<code>item-service</code>、<code>cart-service</code>三个服务。再次测试，发现分布式事务的问题解决了！</p><h2 id="2-分布式事务的解决方案"><a href="#2-分布式事务的解决方案" class="headerlink" title="2.分布式事务的解决方案"></a>2.分布式事务的解决方案</h2><p>Seata可以解决分布式事务问题主要是因为它支持四种分布式事务解决方案。</p><ul><li><strong>XA</strong></li><li><strong>TCC</strong></li><li><strong>AT</strong></li><li><strong>SAGA</strong></li></ul><p>这里介绍XA模式和AT模式</p><h3 id="1-XA模式"><a href="#1-XA模式" class="headerlink" title="1.XA模式"></a>1.XA模式</h3><p><code>XA</code> 规范 是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><h4 id="1-两阶段提交"><a href="#1-两阶段提交" class="headerlink" title="(1)两阶段提交"></a>(1)两阶段提交</h4><p>A是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p><p>正常情况下：</p><p><img src="/../images/image-20250416180420469.png" alt="image-20250416180420469"></p><p>异常情况下：</p><p><img src="/../images/image-20250416180450436.png" alt="image-20250416180450436"></p><p>一阶段：</p><ul><li>事务协调者(TC)通知每个事务参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，<strong>此时事务不提交</strong>，<strong>继续持有数据库锁</strong></li></ul><p>二阶段：</p><ul><li>事务协调者(TC)基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段<strong>任意一个参与者失败</strong>，则通知所有事务参与者<strong>回滚事务</strong></li></ul><h4 id="2-Seata的XA模型"><a href="#2-Seata的XA模型" class="headerlink" title="(2)Seata的XA模型"></a>(2)Seata的XA模型</h4><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="/../images/image-20250416182627127.png" alt="image-20250416182627127"></p><p>如图所示，可知</p><p><code>RM</code>一阶段的工作：</p><ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol><p><code>TC</code>二阶段的工作：</p><ol><li><code>TC</code>检测各分支事务执行状态<ol><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol></li></ol><p><code>RM</code>二阶段的工作：</p><ul><li>接收<code>TC</code>指令，提交或回滚事务</li></ul><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>XA模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码入侵</li></ul><p>XA模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h4 id="4-实现步骤"><a href="#4-实现步骤" class="headerlink" title="(4)实现步骤"></a>(4)实现步骤</h4><p>要将Seata的默认模式(AT)改为XA模式可以在配置文件中指定要使用的模式。</p><p><img src="/../images/image-20250416183654161.png" alt="image-20250416183654161"></p><h3 id="2-AT模式"><a href="#2-AT模式" class="headerlink" title="2.AT模式"></a>2.AT模式</h3><p><code>AT</code>模式同样是分阶段提交的事务模型，不过缺弥补了<code>XA</code>模型中资源锁定周期过长的缺陷。</p><h4 id="1-Seata的AT模型"><a href="#1-Seata的AT模型" class="headerlink" title="(1)Seata的AT模型"></a>(1)Seata的AT模型</h4><p>基本流程图：</p><p><img src="/../images/image-20250416183855259.png" alt="image-20250416183855259"></p><p>阶段一<code>RM</code>的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时<code>RM</code>的工作：</p><ul><li><strong>删除undo-log即可</strong></li></ul><p>阶段二回滚时<code>RM</code>的工作：</p><ul><li><strong>根据undo-log恢复数据到更新前</strong></li></ul><h4 id="2-流程梳理"><a href="#2-流程梳理" class="headerlink" title="(2)流程梳理"></a>(2)流程梳理</h4><p>我们用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在有一个数据库表，记录用户余额：</p><table><thead><tr><th align="left"><strong>id</strong></th><th align="left"><strong>money</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>AT模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><ol><li><code>TM</code>发起并注册全局事务到<code>TC</code></li><li><code>TM</code>调用分支事务</li><li>分支事务准备执行业务SQL</li><li><code>RM</code>拦截业务SQL，根据where条件查询原始数据，形成快照。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;money&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><code>RM</code>执行业务SQL，提交本地事务，释放数据库锁。此时 money &#x3D; 90</li><li><code>RM</code>报告本地事务状态给<code>TC</code></li></ol><p><strong>二阶段</strong>：</p><ol><li><code>TM</code>通知<code>TC</code>事务结束</li><li><code>TC</code>检查分支事务状态<ol><li>如果都成功，则立即删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（{“id”: 1, “money”: 100}），将快照恢复到数据库。此时数据库再次恢复为100</li></ol></li></ol><p>流程图：</p><p><img src="/../images/image-20250416184528983.png" alt="image-20250416184528983"></p><h3 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a>AT与XA的区别</h3><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好(一阶段过后其他线程也可以进入一阶段)。因此企业90%的分布式事务都可以用AT模式来解决。</p><h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><h4 id="AT模式是否会出现脏写问题"><a href="#AT模式是否会出现脏写问题" class="headerlink" title="AT模式是否会出现脏写问题"></a>AT模式是否会出现脏写问题</h4><p><strong>脏写问题</strong>：指的是事务1对某个数据项进行了修改，但尚未提交（即事务1的修改处于未完成状态）。此时，事务2读取了事务1修改后的数据，并基于这个数据进行了进一步的修改。如果事务1最终回滚，那么事务1的修改会被撤销，但事务2已经基于事务1的中间状态进行了修改，这会导致数据库中出现不一致的状态。</p><p>脏写问题的关键在于事务1的未提交修改被事务2依赖，而事务1的回滚会导致数据不一致。</p><p><strong>例子</strong></p><p>假设有一个账户余额表，初始余额为100元。</p><ul><li><strong>事务1</strong>：将余额从100元修改为150元（未提交）。</li><li><strong>事务2</strong>：读取了150元的余额，并将其修改为200元（提交）。</li><li><strong>事务1</strong>：回滚，余额恢复为100元。</li></ul><p>此时，事务2的修改（200元）是基于事务1的中间状态（150元），而事务1回滚后，余额又变成了100元。这就导致了数据不一致，因为事务2的修改没有考虑到事务1的回滚操作。</p><p>答：不会，如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。此时，如果 tx2 仍在等待该数据的 全局锁，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的全局锁等锁超时，放弃全局锁并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。因为整个过程全局锁在tx1结束前一直是被 tx1持有的，所以不会发生脏写的问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评项目总结</title>
      <link href="/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h1><p>八股介绍：之后再补吧。。。。。词穷了</p><p>这个项目主要是基于redis相关内容进行展开的，主要实现了用户登录、抢票、点赞、评论、关注等类似社交软件的功能。</p><h1 id="二、短信登录"><a href="#二、短信登录" class="headerlink" title="二、短信登录"></a>二、短信登录</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>短信登录逻辑是用户填入手机号和短信验证码来校验用户信息。此外，该登录功能还包含了注册，即未注册过的手机号进行登录时，将会默认注册为一个新用户。</p><h2 id="2-验证码的获取"><a href="#2-验证码的获取" class="headerlink" title="2.验证码的获取"></a>2.验证码的获取</h2><h3 id="验证码缓存"><a href="#验证码缓存" class="headerlink" title="验证码缓存"></a>验证码缓存</h3><p>用户发起获取短信验证码请求时，后端会先随机生成一个6位数验证码，以<code>login:phone:填入的手机号</code>为key，将验证码存入redis中。随后调用短信相关的api，给对应的手机号发送验证码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;非法手机号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将验证码存入redis，以手机号码为key, 过期时间600秒</span></span><br><span class="line">    redisTemplate.opsForValue().set(RedisConstant.LOGIN_PHONE_KEY + phone, code, <span class="number">600</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送验证码成功&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-登录校验"><a href="#3-登录校验" class="headerlink" title="3.登录校验"></a>3.登录校验</h2><h3 id="用户信息缓存"><a href="#用户信息缓存" class="headerlink" title="用户信息缓存"></a>用户信息缓存</h3><p>用户校验成功后，后端会利用UUID随机生成一个token值，并以<code>login:user:token值</code>为key，保存用户的相关消息到redis中。前端接收返回的token值并带入请求头中，以便访问其他页面时校验用户身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.根据手机号查询redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> redisTemplate.opsForValue().get(RedisConstant.LOGIN_PHONE_KEY + phone);</span><br><span class="line">    <span class="comment">//2.校验验证码</span></span><br><span class="line">    <span class="keyword">if</span>(code == <span class="literal">null</span> || !code.equals(loginForm.getCode()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span>  <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.保存信息到redis</span></span><br><span class="line">    <span class="comment">//4.1随机生成token,做为访问redis的key，同时返回前端存储该token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstant.LOGIN_USER_KEY + token;</span><br><span class="line">    <span class="comment">//4.2将UserDTO对象转换为Map存储</span></span><br><span class="line"></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">    BeanUtils.copyProperties(user, userDTO);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">//设置过期时间</span></span><br><span class="line">    redisTemplate.expire(tokenKey, RedisConstant.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-登录拦截"><a href="#4-登录拦截" class="headerlink" title="4.登录拦截"></a>4.登录拦截</h2><p>拦截器配置类如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//token刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(</span><br><span class="line">                <span class="string">&quot;/**&quot;</span></span><br><span class="line">        ).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（1）token刷新拦截器"><a href="#（1）token刷新拦截器" class="headerlink" title="（1）token刷新拦截器"></a>（1）token刷新拦截器</h3><p>该拦截器目的是刷新用户token的有效期，并不具有拦截功能，真正实现拦截功能的是登录拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.从请求头的authorization中获取token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="comment">//2.根据key 获取用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">    <span class="keyword">if</span>(entries.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若用户信息存在，则添加到threadlocal</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(entries, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">    UserHolder.saveUser(userDTO);</span><br><span class="line">    <span class="comment">//4.刷新用户token</span></span><br><span class="line">    stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）登录拦截器"><a href="#（2）登录拦截器" class="headerlink" title="（2）登录拦截器"></a>（2）登录拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h3><h4 id="为什么需要有两个拦截器"><a href="#为什么需要有两个拦截器" class="headerlink" title="为什么需要有两个拦截器"></a>为什么需要有两个拦截器</h4><p>**答:**因为不是每个页面都会拦截，例如首页，非登录用户也可以进行访问。若token刷新功能设置在登录拦截器中，那么用户访问非登录拦截页面时，token也就无法刷新，所以只有一个拦截器的话，token刷新是存在问题的。</p><p><strong>解决方法：</strong>设置一个全放行的全局拦截器，并把登录拦截器的功能移植到这个全局拦截器中，若存在token，则会刷新token,并将用户信息存入<strong>ThreadLocal</strong>中。在访问登录拦截器所拦截的页面时，登录拦截器只需要判断<strong>ThreadLocal</strong>中是否存在用户信息即可。这种情况下，token刷新拦截器的优先级高于登录拦截器。</p><h1 id="三、商户查询缓存"><a href="#三、商户查询缓存" class="headerlink" title="三、商户查询缓存"></a>三、商户查询缓存</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><p>缓存穿透指的是客户端请求在缓存和数据库中都不存在的数据，导致请求直接打到数据库。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="（1）缓存空对象"><a href="#（1）缓存空对象" class="headerlink" title="（1）缓存空对象"></a>（1）缓存空对象</h4><ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致（空对象存在时间内，新增了该id对应的商户信息）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用读缓存方法 -- 解决缓存穿透</span></span><br><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若redis中存在则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(str, type);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.若redis中没有，则访问数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3.1数据库中不存在，空值写入redis，防止缓存穿透</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, expireTime, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2.若数据库中存在，则存入redis中, 缓存时间为30分钟</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), expireTime, unit);</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点详解</p><p><strong>1.方法泛型</strong></p><p>方法泛型的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ReturnType <span class="title function_">methodName</span><span class="params">(T param1, T param2, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，泛型T类型根据方法参数而定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">((String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line"><span class="comment">//方法体  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ID</code>类型</strong>：在调用<code>queryPassThrough</code>方法时，第二个参数的类型决定了<code>ID</code>的具体类型。</li><li><strong><code>R</code>类型</strong>：在调用<code>queryPassThrough</code>方法时，第三个参数<code>Class&lt;R&gt;</code>的类型决定了<code>R</code>的具体类型。</li></ul><p>上述方法中使用了泛型<code>&lt;ID, R&gt;</code>，其中<code>ID</code>表示传入的ID类型，<code>R</code>表示返回结果的类型。这使得方法可以处理不同类型的ID和返回值，增强了代码的通用性。</p><p>简单示例:将从Redis获取对象并进行类型转换的代码进行了封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; R <span class="title function_">getBean</span><span class="params">(String key, Class&lt;R&gt; type)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JSONUtil.toBean(s, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用封装方法</span></span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> Cache.getBean(key, Shop.class);</span><br><span class="line"><span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用封装方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="keyword">if</span>(StrUtil.isEmpty(s))&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(s, Shop.class);</span><br></pre></td></tr></table></figure><p><strong>2.函数式接口</strong></p><p><code>Function&lt;ID, R&gt;</code> 是一个函数式接口，定义了一个方法 <code>apply</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(ID id)</span>;</span><br></pre></td></tr></table></figure><p>这个方法接收一个类型为 <code>ID</code> 的参数，并返回一个类型为 <code>R</code> 的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, <span class="number">1200L</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>上述代码的this::getById是一个方法引用，用作apply方法的实现。</p><p><strong>3.方法引用</strong></p><p>方法引用是 Java 8 引入的一种特性，它允许你直接引用已有的方法或构造函数，而无需显式地定义一个 Lambda 表达式。方法引用可以看作是 Lambda 表达式的语法糖，它使得代码更加简洁、易读，并且能够直接利用已有的方法逻辑。</p><p><strong>方法引用与 Lambda 表达式的区别</strong></p><ul><li><p><strong>Lambda 表达式</strong>：是一种匿名函数，可以定义新的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; absFunction = x -&gt; Math.abs(x);</span><br></pre></td></tr></table></figure></li><li><p><strong>方法引用</strong>：直接引用已有的方法，避免重复定义逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; absFunction = Math::abs;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong></p><p><code>Function&lt;S, T&gt;</code> 这种函数式接口可以使用方法引用，但方法引用必须满足以下条件：</p><ul><li>方法的参数类型必须与 <code>S</code> 匹配。</li><li>方法的返回类型必须与 <code>T</code> 匹配。</li></ul><p>只有当方法的签名的参数与 <code>Function&lt;S, T&gt;</code> 的 <code>apply</code> 方法的签名参数一致时，才能使用方法引用。</p><p>方法的签名（Method Signature）指的是方法的名称和参数列表。</p><h4 id="（2）布隆过滤器"><a href="#（2）布隆过滤器" class="headerlink" title="（2）布隆过滤器"></a>（2）布隆过滤器</h4><p><strong>介绍：</strong>详解见<a href="https://blog.csdn.net/qq_41125219/article/details/119982158">布隆(Bloom Filter)过滤器——全面讲解，建议收藏-CSDN博客</a></p><p>布隆过滤器它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是<strong>一个大型位数组（二进制数组）+多个无偏hash函数。</strong></p><p>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</p><p>如下就是一个简单的布隆过滤器示意图，其中k1、k2代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。其实就是看当前元素的经多个hash函数计算的不同索引在二进制数组当中是否都为1，都是1就通过。</p><p><img src="/../images/image-20250424151328839.png" alt="image-20250424151328839"></p><ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能（若存在则肯定存在，若不存在有可能认为存在）</li></ul></li></ul><p>实现代码如下</p><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--布隆过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在ShopServiceImpl中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布隆过滤器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Long&gt; bloomFilter;</span><br><span class="line"><span class="comment">//布隆过滤器初始化方法</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBlooFilter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.从数据库中加载所有的店铺</span></span><br><span class="line">    List&lt;Long&gt; shopIds = shopMapper.getAllShopIds();</span><br><span class="line">    <span class="comment">//2.创建布隆过滤器</span></span><br><span class="line">    bloomFilter = BloomFilter.create(</span><br><span class="line">            Funnels.longFunnel(),  <span class="comment">//使用Long类型</span></span><br><span class="line">            shopIds.size() * <span class="number">2</span>,  <span class="comment">//期望插入的元素数量，这里乘以2是为了给新增店铺id留空</span></span><br><span class="line">            <span class="number">0.01</span> <span class="comment">//误判率</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//3.将店铺的id添加到布隆过滤器</span></span><br><span class="line">    <span class="keyword">for</span> (Long shopId : shopIds) &#123;</span><br><span class="line">        bloomFilter.put(shopId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.修改查询店铺代码</p><p>注意：因为布隆过滤器不能百分百阻拦不存在的数据，所以cacheClient的queryPassThrough方法没动。若侥幸通过布隆过滤器检测，会使用缓存空值的办法来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//使用布隆过滤器先判断店铺是否存在</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(bloomFilter.mightContain(id))&#123;</span><br><span class="line">        <span class="comment">//存在则先查缓存再查数据库</span></span><br><span class="line">        shop = cacheClient.queryPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, <span class="number">1200L</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;布隆过滤器检测到店铺id不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺id真不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.修改新增店铺代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveShop</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.save(shop);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">shopId</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="comment">//添加新店铺id到布隆过滤器中</span></span><br><span class="line">    bloomFilter.put(shopId);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shopId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><p>缓存雪崩指的是在同一时间段内大量的缓存key同时失效或者redis服务突然宕机，导致大量请求直接打到数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的key添加随机的TTL</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加<strong>降级限流</strong>策略（<strong>限流</strong>：缓存未命中时，数据库的访问量也不会超过<strong>业务</strong>限流量，<strong>降级</strong>：缓存未命中时，返回默认值）</li><li>给业务添加多级缓存</li></ul><h3 id="解决方案实现待补充"><a href="#解决方案实现待补充" class="headerlink" title="解决方案实现待补充"></a>解决方案实现待补充</h3><h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><p>缓存击穿指的是一个被高并发访问并且缓存重建业务较耗时的key突然失效了，导致大量请求直接打到数据库上。</p><p><img src="/../images/1653328022622-17433473940211.png" alt="1653328022622"></p><p>逻辑描述：假设线程1查询缓存未命中的情况下，本该是查询数据库并重建缓存数据就好了，之后的线程就都可以命中缓存了。但在高并发情况下，可能会有多个线程2、3、4，虽然在线程1之后查询缓存，但他们在线程1重建缓存之前就已经查询完缓存了，此时缓存是未命中的，导致这些线程都会执行和线程1一样的逻辑，去查询数据库，导致数据库访问压力过大。</p><p>常见的解决方案有两种：</p><ul><li><strong>互斥锁</strong></li><li><strong>逻辑过期</strong></li></ul><h3 id="（1）互斥锁"><a href="#（1）互斥锁" class="headerlink" title="（1）互斥锁"></a>（1）互斥锁</h3><p>因为锁具有互斥性，所以我们可以设置一个互斥锁用于访问相应的数据库资源，只有拿到了锁的线程可以对数据库进行访问。这样可以使对同一资源的访问从并行变成了串行，从而减轻数据库压力。但这种方式的问题就是，其他没拿到锁的线程如何处理，是继续等待呢，还是直接返回呢？</p><p>继续等待的情况下，其他线程会等待锁的释放，当拿到了锁后，需要先访问缓存，判断拿到该锁之前，是否已经有线程访问过数据库并重建了缓存。如果有，则不需要再次访问数据库了，直接从缓存中拿即可。</p><p><img src="/../images/1653328288627.png" alt="1653328288627"></p><h4 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h4><p>那么问题来了，既然选择了互斥锁方案，那么这个互斥锁是谁提供的呢？</p><p>那当然是<strong>redis</strong>来提供了！！！</p><p>因为redis是单线程的，所以不必担心锁的获取会有线程安全问题。给每个商户信息设置一个对应的互斥锁key即可。只有成功设置key-value的线程才算拿到了互斥锁。</p><p>获取互斥锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取互斥锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="comment">//尝试设置redis内容,若设置成功则表明获取到了锁，若失败，则说明已经有人拿到了这个锁</span></span><br><span class="line">    <span class="comment">//设置过期时间是怕获取到锁的线程发生问题时独占锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放互斥锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，互斥锁也应当设置过期时间，以防某线程拿到锁却挂了，导致锁没释放成功的情况。当然了，不能排除这个线程后面又复活的情况，所以又引申出一个新的问题，原线程继续执行下去，但此时锁已经到期释放且被另一个线程获取了。原线程就有可能会把另一个线程获取到的锁给提前释放！！！这个问题到后面会解决，这里先埋个关子，我也是才意识到原来这里就已经出现这个问题了。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>商户信息访问的互斥锁解决方案如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存击穿--互斥锁方法</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.1先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//1.2判断是否str非空（非null和非空字符串）</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">        shop = JSONUtil.toBean(str, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.3若str是空字符串，则说明这个缓存是用于缓存穿透的，直接返回null即可</span></span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//2.若redis中没有，则访问数据库</span></span><br><span class="line">        <span class="comment">//3.获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">            <span class="comment">//休眠50ms,递归获取数据，直至命中缓存或者得到锁</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4拿到互斥锁时需要二次判断缓存中是否已经添加</span></span><br><span class="line">        <span class="comment">// 因为可能在拿到锁时，上一个拿到锁的已经将数据存到redis中了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">            <span class="comment">//4.1若此时缓存中已经存在了，则直接返回，不需要再查数据库了</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2 若缓存中仍然不存在，则查询数据库</span></span><br><span class="line">        shop = <span class="built_in">this</span>.getById(id);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//空值写入redis，防止缓存穿透,注意要设置过期时间</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//5.释放互斥锁</span></span><br><span class="line">        releaseLock(LOCK_SHOP_KEY + id);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：获取锁之后的<strong>缓存二次判断</strong>。</p><h3 id="（2）逻辑过期"><a href="#（2）逻辑过期" class="headerlink" title="（2）逻辑过期"></a>（2）逻辑过期</h3><p>我们之所以会出现缓存击穿这个问题的是因为缓存中的key过期失效了，才会导致请求打到数据库上。那么如果我们给缓存设置一个逻辑过期时间在缓存的数据中，缓存本身并不设置过期时间，那么当其他线程访问该数据时就一定会命中缓存。</p><p>我们所需要做的，就是在线程获取到缓存时加上个逻辑过期的判断语句即可。若过期了，就<strong>试着获取互斥锁</strong>，若获取互斥锁成功，则<strong>开启一个独立线程去重建缓存</strong>。但是，无论是否获取到互斥锁，当前线程都则<strong>无需等待</strong>，直接<strong>返回旧数据</strong>。</p><p>这个方案优点是异步构建缓存，响应速度快。缺点就是会造成<strong>脏读</strong>。</p><p>此外，对于逻辑过期也要获取互斥锁这个现象，让我感觉逻辑过期本质上就是对互斥锁方案本身的改进吧。</p><p><img src="/../images/1653328663897.png" alt="1653328663897"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>逻辑过期通用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 逻辑过期策略的通用类 -- 解决缓存击穿</span></span><br><span class="line"><span class="comment">* 对象存入data,逻辑过期时间存入expireTime</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑过期主方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*缓存击穿--逻辑过期主方法*/</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若未命中，则直接返回null, 因为逻辑过期场景下，redis中的数据是提前写好的，没有就不需要查数据库了</span></span><br><span class="line">    <span class="keyword">if</span>(!StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若redis命中，则判断是否逻辑过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//因为redisObject是一个通用类，所以data类型是Object,这种情况下需要先强转为JSONObject,再使用JSONUtil.toBean()</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="comment">//4.1未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.2已过期，需缓存重建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.1获取互斥锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY+id);</span><br><span class="line">    <span class="comment">//5.2判断是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//5.3成功</span></span><br><span class="line">        <span class="comment">//5.4二次判断redis当中此时是否已经更新过过期时间了</span></span><br><span class="line">        shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        redisData = JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        expireTime = JSONUtil.toBean(shopJson, RedisData.class).getExpireTime();</span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            data = (JSONObject)redisData.getData();</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.5开启独立线程，实现缓存重建</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5.6若未更新，则重建缓存</span></span><br><span class="line">            saveShop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">            <span class="comment">//5.7释放锁</span></span><br><span class="line">            releaseLock(LOCK_SHOP_KEY+id);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.7返回过期的店铺信息</span></span><br><span class="line">    <span class="keyword">return</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：释放锁需要交给异步线程来释放。</p><p>异步重建缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池，供逻辑过期方法使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">/*逻辑过期信息存入redis方法*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, <span class="type">long</span> expireseconds)</span>&#123;</span><br><span class="line">    <span class="comment">//1.查询商品数据</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//2.存入redisData</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireseconds));</span><br><span class="line">    <span class="comment">//3.写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提问-1"><a href="#提问-1" class="headerlink" title="提问"></a>提问</h4><p>1.为什么这里会把redisData.getData()强制类型转换为JSONObject,再利用JSONUtil把类型转化为Shop，而不是直接强制类型转换为Shop?</p><p>答：因为JSONObject可扩展性更强，功能强大，虽然代码中并未体现，但它可以使用get方法获取属性中的值，也可以使用getString判断是否存在某属性，这对类型不确定的情况下还是很有帮助的。具体参考<a href="https://blog.csdn.net/NiNg_1_234/article/details/144069674">Java中的JSONObject详解_java jsonobject-CSDN博客</a></p><p>2.开启独立线程是怎么实现的？</p><p>答：利用的是Executors获取线程池的方式开启独立线程。目前这个线程池是静态变量，在整个应用生命周期内保持存在（注意：静态变量的生命周期与类的加载和卸载相关，而不是由 Spring 容器管理），避免了在任务执行过程中动态创建线程。但由于这个线程池并非spring容器管理，所以无法动态调整线程池大小。改进方法就是可以设置一个线程池Bean交给Spring容器管理，可以在配置文件中设置线程的最大线程数量等参数配置。</p><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><p><strong>互斥锁方案</strong>：由于互斥性，所以数据一致性可以保证，且只需要在原代码上加把锁，没有复杂的逻辑，实现简单。问题就是可能会陷入死锁（当前代码只有一把锁，所以没有体现），而且数据访问是串行执行的，线程需要等待，性能肯定有影响。</p><p><strong>逻辑过期方案</strong>：有一个额外线程去重建缓存，线程不需要等待，性能好。但在重构缓存之前，其他线程都只能返回旧数据。此外，实现较为复杂、且需要占用额外的内存来存放逻辑过期时间。</p><p><img src="/../images/1653357522914.png" alt="1653357522914"></p><h2 id="RedisTemplate工具类"><a href="#RedisTemplate工具类" class="headerlink" title="RedisTemplate工具类"></a>RedisTemplate工具类</h2><p>基于上面的缓存穿透和缓存击穿实现方法，我们可以封装成一个通用的工具类。</p><p>这里我们把RedisTemplate工具类的相关方法写入CacheClient类中。</p><h3 id="1-通用写缓存方法"><a href="#1-通用写缓存方法" class="headerlink" title="1.通用写缓存方法"></a>1.通用写缓存方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, value, expireTime, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通用读缓存方法–解决缓存穿透"><a href="#2-通用读缓存方法–解决缓存穿透" class="headerlink" title="2.通用读缓存方法–解决缓存穿透"></a>2.通用读缓存方法–解决缓存穿透</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用读缓存方法 -- 解决缓存穿透</span></span><br><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若redis中存在则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(str, type);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.若redis中没有，则访问数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3.1数据库中不存在，空值写入redis，防止缓存穿透</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, expireTime, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2.若数据库中存在，则存入redis中, 缓存时间为30分钟</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), expireTime, unit);</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通用获取对象–解决缓存击穿–基于逻辑过期"><a href="#3-通用获取对象–解决缓存击穿–基于逻辑过期" class="headerlink" title="3.通用获取对象–解决缓存击穿–基于逻辑过期"></a>3.通用获取对象–解决缓存击穿–基于逻辑过期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用获取对象 -- 解决缓存击穿 -- 逻辑过期</span></span><br><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryWithLogicExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, String lockPrefix, Long prolongTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">strJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若未命中，则直接返回null, 因为逻辑过期场景下，redis中的数据是提前写好的，没有就不需要查数据库了</span></span><br><span class="line">    <span class="keyword">if</span>(!StrUtil.isNotBlank(strJson))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若redis命中，则判断是否逻辑过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//因为redisObject是一个通用类，所以data类型是Object,这种情况下需要先强转为JSONObject,再使用JSONUtil.toBean()</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="comment">//4.1未过期，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.2已过期，需缓存重建</span></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.1获取互斥锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> tryLock(lockPrefix+id);</span><br><span class="line">    <span class="comment">//5.2判断是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//5.3成功</span></span><br><span class="line">        <span class="comment">//5.4二次判断redis当中此时是否已经更新过过期时间了</span></span><br><span class="line">        strJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        redisData = JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">        expireTime = redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            data = (JSONObject)redisData.getData();</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.5开启独立线程，实现缓存重建</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5.6查询数据库</span></span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">            setWithExpire(key, r, prolongTime, unit);</span><br><span class="line">            <span class="comment">//5.7释放锁</span></span><br><span class="line">            releaseLock(lockPrefix+id);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.7返回过期的店铺信息</span></span><br><span class="line">    <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通用写入缓存方法 – 逻辑过期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用写入缓存方法 -- 逻辑过期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithExpire</span><span class="params">(String key, Object value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个逻辑过期对象通用类</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(expireTime)));</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、优惠券秒杀"><a href="#四、优惠券秒杀" class="headerlink" title="四、优惠券秒杀"></a>四、优惠券秒杀</h1><p>这个优惠券秒杀功能主要核心点:</p><p>1.全局唯一id的生成</p><p>2.乐观锁 – 一人一单</p><p>3.悲观锁 – </p><p>4.分布式锁</p><p>5.lua脚本</p><p>6.Redission</p><p>7.异步秒杀优化</p><p>8.基于redis实现的消息队列</p><p>8.Rabbitmq实现的消息队列</p><h2 id="1-全局唯一id"><a href="#1-全局唯一id" class="headerlink" title="1.全局唯一id"></a>1.全局唯一id</h2><p>当用户抢购时，就会生成订单并保存到订单表中，如果我们使用数据库自增id的话，就会存在id的规律性太明显的问题。</p><p>场景1：如果我们的id具有太明显的规则，那么用户或者说商业竞争者就很容易猜测出我们的一些敏感信息，比如一天总共卖出了多少单，这很明显不合适。</p><p>场景2：mysql的单表容量不宜超过500w,当我们数据量过大时，我们需要进行拆库拆表，但拆库拆表后，我们就需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p><img src="/../images/1653363100502.png" alt="1653363100502"></p><p>同时，为了保证id的安全性，所以我们不能全靠redis的id自增来生成ID,可以用拼接其他信息。例如时间戳。</p><p><img src="/../images/1653363172079.png" alt="1653363172079"></p><p>ID的组成部分</p><p>Long类型：占用8个字节，是64位的整数类型。</p><p>id组成：</p><ul><li>符号位：1位，永远为0</li><li>时间戳：31位，以秒为单位，从起始点算起可以用69年</li><li>序列号：32位，秒内计数器，支持每秒最多2^32个id</li></ul><p>时间戳占用Long类型的第2为到第32位：先设置一个起始时间戳，代表起始点，然后我们可以用当前的时间戳-起始时间戳得到的数来填充Long类型的32位。经计算，2^32可以供我们用69年。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//开始时间戳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//2025年3月8号做为起始时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1741464196</span>;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">dateSeconds</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> dateSeconds - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2.生成序列号</span></span><br><span class="line">        <span class="comment">//2.1获取当前时间，精确到天，做为当天自增长key的一部分</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2自增长</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;incr:&quot;</span> + keyPrefix + date);</span><br><span class="line">        <span class="comment">//3.拼接并返回， 时间戳（每秒都不一样）在前32位，自增长id在后32位，这样子可以支持每秒产生最多2^32次个不同的id</span></span><br><span class="line">        <span class="comment">//当然，因为没有做redis的id超限判断，所以这一天最多只能产生2^32次个id，我们也可以自己加上超额判断</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(id.equals(4294967295L))&#123;</span></span><br><span class="line"><span class="comment">            stringRedisTemplate.opsForValue().set(&quot;incr:&quot;+keyPrefix+date, &quot;0&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:这里的 <code>timestamp &lt;&lt; COUNT_BIT | id</code>，这里代表的是将时间戳左移32位并低32位由id填充，因为<code>|</code>运算符用来或运算，即有1填1，全0则0。当id &lt; 2^32时，id只会在低32位存在1，不影响时间戳的加入。</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法其实和自定义的全局唯一id类似！！！</p><p>雪花算法也是占用64位（1位符号位、41位时间戳，以毫秒为单位、10位机器id和12位序列号）。这相当于每台机器每毫秒可以产生4096个id。</p><p>至于机器id分配，则可以通过服务配置来实现，让程序在整个运行期间保持不变。</p><p>由于时钟误差或网络延迟等原因，可能会出现时钟回拨的情况。为了处理这种情况，雪花算法通常使用一个缓存机制来存储最近生成的时间戳。如果当前时间戳小于缓存中的时间戳，则拒绝生成ID并等待一段时间再试。这样可以避免由于时钟回拨导致的ID冲突问题。</p><h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2.乐观锁"></a>2.乐观锁</h2><p>乐观锁和悲观锁是用于解决<strong>超卖</strong>问题的</p><p><img src="/../images/1653368562591.png" alt="1653368562591"></p><p>先讲乐观锁：</p><p>乐观锁的基本思路就是给数据增加一个版本号字段，每次对数据进行修改时，会先获取原数据的版本号，然后在修改时，带上这个版本号<strong>判断当前版本号是否和之前获取的版本号一致</strong>，若一致的话，则对数据进行修改，并对版本号加1。若不一致，则说明在对数据修改之前，已经被其他线程改动过了，则放弃修改。</p><p>乐观锁的核心代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.试着获取秒杀券</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line"><span class="comment">//7.若true,则表示扣减库存成功</span></span><br><span class="line"><span class="keyword">if</span>(b)&#123;</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="string">&quot;抢票成功，订单号:&quot;</span>+voucherOrder.getId());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;抱歉，优惠券已抢光&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们并没有设置版本号来对数据一致性进行判断，而是用更简单的方式（<strong>判断库存是否大于0</strong>），因为我们是秒杀抢票功能，如果我们设置版本号或者直接库存来保证数据的一致性，那么会导致在有充足票的情况下，要是多个人同时抢票得到的初始版本号或者库存相同，那么肯定只有一个人能抢票成功。这是不允许的。</p><h2 id="3-悲观锁"><a href="#3-悲观锁" class="headerlink" title="3.悲观锁"></a>3.悲观锁</h2><p><strong>问题引入：</strong></p><p>假设一个场景，未抢票的用户几乎同时发起了2次抢票请求，在乐观锁的代码为准，这可能会导致，一个用户同时抢到2张票的情况。为什么呢？因为，即使原代码有判断一人一单的操作，但没有确保判断一人一单操作和扣减库存操作之间的原子性，这就会导致，多个线程都执行完判断一人一单的操作后第一个线程才开始扣减库存，导致一个人可能抢到多张票。究其原因，还是锁的粒度太小导致的。乐观锁只在最后修改数据时起判断作用。</p><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等。</p><p>尽管对于多个不同用户发起抢票的情况下，悲观锁不如乐观锁，试想下，如果给操作数据加个锁，那么即便在库存充足的情况下，多个用户发起的抢票也只能串行执行，严重影响效率。</p><p>但悲观锁可以解决乐观锁无法解决的<strong>同一个用户的多次频繁请求,即一人一单问题</strong>。因为悲观锁是对同一个用户的多次请求加锁。所以，这个业务中，悲观锁的实现是在乐观锁的基础上进行的！！！两者没有优劣之分，都很重要。</p><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给用户id加锁，intern是指锁的对象是常量池中的字符串</span></span><br><span class="line"><span class="comment">//因为每次toString创建的都是新对象，加锁没有用，所以需要intern()方法</span></span><br><span class="line"><span class="comment">//同时，锁需要在事务提交之后才能释放，保证线程安全</span></span><br><span class="line"><span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了锁的正常释放和保证事务可以回滚，需要单独提取个方法，并给方法加上<code>@Transactional</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId, Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1获取订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order:&quot;</span>);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    <span class="comment">//6.2用户id</span></span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    <span class="comment">//6.3代金券id</span></span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h3><p>1.<strong>synchronized</strong></p><p>synchronized 块是 阻塞获取锁 的。当一个线程尝试进入一个 synchronized 块时，如果锁已经被其他线程持有，该线程会被阻塞（即进入等待状态），直到锁被释放。一旦锁被释放，等待的线程会竞争锁，获得锁的线程可以继续执行同步块中的代码。</p><p>2.<strong>intern</strong>()方法</p><p>intern() 方法是 Java 中 String 类的一个方法，用于将字符串对象放入字符串常量池中，并返回该字符串的引用。如果常量池中已经存在相同内容的字符串，则直接返回该字符串的引用；否则，将该字符串添加到常量池中，并返回其引用。</p><h3 id="提问-2"><a href="#提问-2" class="headerlink" title="提问"></a>提问</h3><p>1.为什么要在锁中使用代理对象执行创建订单的逻辑？</p><p>答：<code>@Transactional</code> 注解需要通过<strong>代理对象</strong>来生效。直接调用 this.createVoucherOrder(voucherId, userId) 不会触发 Spring 的事务管理，因为 this 指向的是当前对象实例，而不是代理对象。</p><p>2.为什么要创建订单逻辑代码提取出来改成一个方法呢?</p><p>答：防止锁提前释放</p><p>首先我们看看下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//校验操作省略</span></span><br><span class="line"><span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你发现了什么？@Transaction这个注解是加在整个方法上面的对吧。但问题是，并不是说事务提交了锁才会释放!!!锁可能会在事务提交前提前释放，这是完全可能的，毕竟锁并不知道事务是否成功提交了。所以，我们才会选择在锁块中调用有@Transaction的方法来解决锁提前释放的问题。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>目前这个悲观锁只能使用于单个服务，如果部署了多个服务（tomcat），即集群的话，每个tomcat都有一个属于自己的jvm,所以多个tomcat之间无法共用同一把锁。</p><p><img src="/../images/1653374044740.png" alt="1653374044740"></p><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4.分布式锁"></a>4.分布式锁</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p><strong>可见性</strong>：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p><strong>互斥</strong>：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p><strong>高可用</strong>：程序不易崩溃，时时刻刻都保证较高的可用性</p><p><strong>高性能</strong>：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p><strong>安全性</strong>：安全也是程序中必不可少的一环</p><p>常见的分布式锁有三种</p><ol><li>mysql</li><li>redis</li><li>zookeeper</li></ol><p>这里先使用redis来实现。至于mysql，基本不会考虑，zookeeper等学了之后再用</p><h3 id="Redis分布式锁的核心思路"><a href="#Redis分布式锁的核心思路" class="headerlink" title="Redis分布式锁的核心思路"></a>Redis分布式锁的核心思路</h3><p>实现分布式锁需要满足以下两个条件</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul><p>利用redis的setNx方法，实现思路如下。</p><p><img src="/../images/1653382830810.png" alt="1653382830810"></p></li></ul><p>首先，为了方便，我们可以创建一个锁的通用类<strong>SimpleRedisLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> &#123;</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//uuid用于区分进程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">keyPrefix</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="comment">//这里把脚本当作定值预先加载了，避免每次获取锁都要重新读取脚本内容而浪费时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long expireSecond)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线程id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(keyPrefix + name, uuid+id, expireSecond, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//防止b是null时拆箱出错</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(keyPrefix);</span><br><span class="line">        <span class="keyword">if</span>(val.equals(uuid + Thread.currentThread().toString()))&#123;</span><br><span class="line">            stringRedisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在抢票中使用自定义分布式锁的代码部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悲观锁解决方案</span></span><br><span class="line"><span class="comment">//给用户id加锁</span></span><br><span class="line"><span class="comment">//分布式锁解决悲观锁的分布式问题</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span>+voucherId+<span class="string">&quot;:&quot;</span>+userId;</span><br><span class="line"><span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(stringRedisTemplate, lockKey);</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">1000L</span>))&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//乐观锁解决方案</span></span><br><span class="line">        <span class="comment">//6.试着获取秒杀券</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="comment">//7.若true,则表示扣减库存成功</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            voucherOrder.setUserId(userId);</span><br><span class="line">            voucherOrder.setVoucherId(voucherId);</span><br><span class="line">            <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(<span class="string">&quot;抢票成功，订单号:&quot;</span>+voucherOrder.getId());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;抱歉，优惠券已抢光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(e.toString());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;请勿频繁点击抢票&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，现在我们知道了抢票过程中锁的流程创建是一步步递进的，乐观锁–&gt;悲观锁–&gt;分布式锁。思路也是循序渐进的。</p><h3 id="提问-3"><a href="#提问-3" class="headerlink" title="提问"></a>提问</h3><p><strong>1.uuid的作用是什么</strong></p><p>答：uuid是为了区分不同服务之间的标识。从代码中，我们可以看到，uuid是一个静态变量，也就是服务在初始化时就已经定下了，而uuid可以保证每次生成的内容不一致，所以，每个服务启动时都会有一个不同uuid值。这样可以方便区分锁究竟是哪个服务拿到的。</p><p><strong>2.获取当前线程的threadId有什么用</strong></p><p>答：用于区分同一个服务下，究竟是哪个线程拿到了锁。</p><p><strong>3.uuid和threadId存入redis中有什么用</strong></p><p>答：为了保证锁的安全释放。假设一个场景，锁被1号服务的1号线程获取到了，但在执行业务过程中发生了阻塞，导致长时间未完成，此时锁的过期时间又到了，导致锁被提前释放。这时，2号服务的1号线程过来拿到了锁，执行业务流程。但执行过程中，1号服务的1号线程业务执行完毕，准备执行释放锁的操作。这会导致2号服务的1号线程的锁被提前释放。为了避免这种问题的发生，我们需要区分不同进程和不同线程，在释放锁的时候先判断目前锁究竟是不是自己的，是则释放锁，不是则不进行释放。所以，我们需要引入uuid+线程id来保证锁的安全释放。</p><p>图片详解</p><p><img src="/../images/1653385920025.png" alt="1653385920025"></p><h2 id="5-Lua脚本"><a href="#5-Lua脚本" class="headerlink" title="5.Lua脚本"></a>5.Lua脚本</h2><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%E3%80%82%E6%B3%A8%E6%84%8F%EF%BC%9Alua%E8%84%9A%E6%9C%AC%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%85%B7%E6%9C%89%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E5%8F%AA%E6%98%AF%E7%94%A8%E5%9C%A8redis%E6%97%B6%EF%BC%8Credis%E8%B5%8B%E4%BA%88%E5%AE%83%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。注意：lua脚本本身不具有原子性，只是用在redis时，redis赋予它实现原子性。</a></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>redis提供的调用函数基本语法如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其他参数&#x27;</span>, ....)</span><br></pre></td></tr></table></figure><p>例如，我们要执行set name ldy,则脚本这么写</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;ldy&#x27;</span>)</span><br></pre></td></tr></table></figure><p>例如我们要先执行完set name ldh,再执行get name,则脚本如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行set name ldh</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;ldh&#x27;</span>)</span><br><span class="line"># 再执行get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure><p>其中<code>local</code>用于声明变量值。</p><p>写好脚本后，需要使用redis命令来调用脚本，调用脚本的常见命令如下:</p><p><img src="/../images/image-20250404184421196.png" alt="image-20250404184421196"></p><p>在redis中也可以直接写lua脚本语句进行执行</p><p><img src="/../images/image-20250404184518534.png" alt="image-20250404184518534"></p><p>上述语句没有需要从外部获取的key值，所以脚本内容后面跟个0。</p><p>其中的语法规则是 <code>Eval &quot;脚本内容&quot; 脚本需要的key类型的参数个数 参数值</code>，其中参数值的规则是这样子的，首先参数个数为n, 则后面跟的n个参数都是KEYS数组的参数值，从第n+1个参数起则是ARGV数组的参数值。</p><p><img src="/../images/image-20250404185803664.png" alt="image-20250404185803664"></p><p>要是脚本中的key和value不想写死，可以做为参数传递。key类型的参数需要放入KEYS数组，其他参数则需要放入ARGV数组中，在脚本中可以从KEYS和ARGV数组中获取这些参数。</p><p>注意：数组的索引是从1开始的</p><p>例如下图所示</p><p><img src="/../images/image-20250404190732159.png" alt="image-20250404190732159"></p><p>我们再来看看，在lua脚本中怎么写语句合适。如下所示，我们用自定义变量名来接收数组中的值，然后用自定义的变量名来做为参数。方便我们更好的理解代码。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> val1 = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val2 = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> val3 = ARGV[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> res redis.call(<span class="string">&#x27;LPUSH&#x27;</span>, key, val1, val2, val3)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>把上述语句写在一行里，然后执行也是可以成功的。注意：lpush命令返回列表中的元素个数。</p><p><img src="/../images/image-20250404191438460.png" alt="image-20250404191438460"></p><p>ok,lua脚本的基本使用就这些了。可以开始优化分布式锁了。</p><h3 id="分布式锁的优化"><a href="#分布式锁的优化" class="headerlink" title="分布式锁的优化"></a>分布式锁的优化</h3><p>首先回顾下释放锁的业务逻辑</p><p>1.获取线程标识（uuid+线程id）</p><p>2.判断锁中存放的线程标识是否和当前的一致</p><p>3.如果一致，则释放锁（删除）</p><p>4.如果不一致，则什么都不做</p><p>用lua脚本实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val1 = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val2 = redis.call(<span class="string">&#x27;get&#x27;</span>, key) <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(val1 == val2) <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"># 简化后是这样子的</span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>使用java代码调用lua脚本来改造分布式锁</strong></p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图所示</p><p><img src="/../images/image-20250404200842686.png" alt="image-20250404200842686"></p><p>使用lua脚本释放锁代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态脚本常量，提前加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT; </span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//设置脚本路径</span></span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    <span class="comment">//设置返回值类型</span></span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                                Collections.singletonList(keyPrefix + name),</span><br><span class="line">                                uuid + Thread.currentThread().getId()</span><br><span class="line">                               );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码详解</strong></p><ul><li>**<code>DefaultRedisScript&lt;Long&gt;</code>**：这是变量的类型，表示这是一个<code>DefaultRedisScript</code>对象，泛型<code>&lt;Long&gt;</code>表示该脚本的执行结果类型为<code>Long</code>。</li><li><strong>static静态代码块</strong>用于用于初始化类的静态变量。</li><li><strong>ClassPathResource</strong>是Spring框架提供的一个类，用于表示类路径下的资源文件。</li><li><strong>Collections.singletonList</strong>用于设置单值的列表</li></ul><h2 id="6-Redisson"><a href="#6-Redisson" class="headerlink" title="6.Redisson"></a>6.Redisson</h2><p>首先，我们基于setnx实现的自定义分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>什么是Redisson</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h3 id="分布式锁-Redisson快速入门"><a href="#分布式锁-Redisson快速入门" class="headerlink" title="分布式锁-Redisson快速入门"></a>分布式锁-Redisson快速入门</h3><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端，其中RedissonClien就是我们实现分布式锁的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用Redisson自带的分布式锁实现抢票逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悲观锁解决方案</span></span><br><span class="line"><span class="comment">//给用户id加锁</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span>+voucherId+<span class="string">&quot;:&quot;</span>+userId;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//乐观锁解决方案</span></span><br><span class="line">        <span class="comment">//6.试着获取秒杀券</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="comment">//7.若true,则表示扣减库存成功</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            voucherOrder.setUserId(userId);</span><br><span class="line">            voucherOrder.setVoucherId(voucherId);</span><br><span class="line">            <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(<span class="string">&quot;抢票成功，订单号:&quot;</span>+voucherOrder.getId());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;抱歉，优惠券已抢光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(e.toString());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;请勿频繁点击抢票&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，和我们之前自定义分布式锁SimpleRedisLock的逻辑完全一致，我们自定义的分布式锁就相当于一个低配版的Redisson。</p><h3 id="重入问题"><a href="#重入问题" class="headerlink" title="重入问题"></a>重入问题</h3><p>首先，我们执行如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;mylock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拿到锁了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有拿到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去查redis，可以看见，创建的锁是Hash类型。其中value是当前锁的重入次数，第1次是00110001，第2次是00110010，至于为什么0011开头，我也不清楚哈哈。field应该是线程标识符</p><p><img src="/../images/image-20250404202916900.png" alt="image-20250404202916900"></p><p>重入机制测试代码，如下,可以自己打断点调试下，查看value的变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:1&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;方法1获取锁成功&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.info(<span class="string">&quot;方法1释放锁成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:1&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;方法2获取锁成功&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.info(<span class="string">&quot;方法2释放锁成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>tryLock中有重载方法可以传入重试时间</p><p><img src="/../images/image-20250404210813586.png" alt="image-20250404210813586"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span>+voucherId+<span class="string">&quot;:&quot;</span>+userId;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"></span><br><span class="line">lock.tryLock(<span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>晚点再解读</p><h3 id="锁重试和看门狗机制"><a href="#锁重试和看门狗机制" class="headerlink" title="锁重试和看门狗机制"></a>锁重试和看门狗机制</h3><p>锁重试机制顾名思义就是可以对锁的获取进行不断的重试，这里暂不赘述。重要的是看门狗机制。</p><p>先回顾下，我们之前自定义的锁的释放是怎么样的，就分两种情况，1是过期自动释放，2是业务完成，手动释放。显然过期自动释放是有问题的，因为很可能过期自动释放后，原线程其实并未挂掉，只是因为某些原因执行时间较长，我们不能让没有挂掉的线程的锁提前给释放，所以需要不断的给过期时间进行延长。这就是看门狗机制。</p><p>那你可能会问了，那过期时间有什么用啊，既然都不断延长了？</p><p>答：就是为了让线程挂掉时可以释放掉锁，因为线程挂掉了，那么肯定不可能继续执行下去了，这个时候也就不会进行自动延迟过期时间了。</p><p>总之，看门狗机制就是为了确保线程在存活期间不会因锁的过期而失去锁的持有权，同时在线程挂掉时能够及时释放锁，避免死锁或资源泄露。</p><p>源码部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure><h3 id="MutiLock原理"><a href="#MutiLock原理" class="headerlink" title="MutiLock原理"></a>MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。这就导致一种情况，明明获取到了锁，结果这突然锁没了，其他线程还能获取这把锁。</p><p>为了解决这个问题，我们获取这把锁时就不用主从关系获取锁了，而是把加锁逻辑写入到每个节点中，只有所有节点都加锁成功时，才算成功加锁。只要有一个节点拿不到锁，就不算加锁成功。保证了加锁的可靠性。</p><p>Redisson这块实在不好总结，毕竟源码也是一知半解，后面有时间再补吧。</p><h2 id="7、异步优化"><a href="#7、异步优化" class="headerlink" title="7、异步优化"></a>7、异步优化</h2><p>先回顾下我们之前抢秒杀券的流程</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、校验是否是一人一单</p><p>4、扣减库存</p><p>5、创建订单</p><p>以上5步，都是直操作数据库，还是串行执行，执行速度有待提升。</p><p>执行速度提升有2种方法</p><p>1.利用redis进行数据校验</p><p>2.开启异步线程执行创建订单的操作</p><p>以上2种方法相结合可以有效提升运行速度，对于异步线程，我们可以使用阻塞队列来实现，让一个线程专门去对数据库执行扣减库存和创建订单的操作，不必担心线程池消耗殆尽的问题。</p><p><img src="/../images/1653561657295.png" alt="1653561657295"></p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要到redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><h3 id="1-Redis完成秒杀资格判断"><a href="#1-Redis完成秒杀资格判断" class="headerlink" title="1.Redis完成秒杀资格判断"></a>1.Redis完成秒杀资格判断</h3><p>需求：</p><ul><li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li><li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ul><p>VoucherServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整lua表达式</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-基于阻塞队列实现秒杀优化"><a href="#2-基于阻塞队列实现秒杀优化" class="headerlink" title="2.基于阻塞队列实现秒杀优化"></a>2.基于阻塞队列实现秒杀优化</h3><p>实现代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">EXECUTOR_SERVICE</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; script;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;();</span><br><span class="line">    script.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lus&quot;</span>));</span><br><span class="line">    script.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">SeckillVoucherHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SeckillVoucherHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不断循环去查看阻塞队列中是否存在订单信息</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//1.从阻塞队列获取订单信息</span></span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                <span class="comment">//2.创建订单</span></span><br><span class="line">                createVoucherOrder(order);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                log.error(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">        <span class="comment">//2.获取优惠券id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">        <span class="comment">//3.获取锁</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:seckill:&quot;</span> + voucherId + <span class="string">&quot;:&quot;</span> + userId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">//4.拿到锁</span></span><br><span class="line">            <span class="keyword">if</span>(b)&#123;</span><br><span class="line">                <span class="comment">//获取代理对象</span></span><br><span class="line">                proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">                <span class="comment">//创建订单</span></span><br><span class="line">                proxy.createVoucherOrder(order);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.没拿到锁</span></span><br><span class="line">            log.error(<span class="string">&quot;限一人一单&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="comment">// 5.1.查询订单</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, order.getVoucherId()).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, order.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">// 扣减失败</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    save(order);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//1.查询秒杀券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="keyword">if</span>(seckillVoucher == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀券不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断秒杀活动是否开始</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="keyword">if</span>(beginTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动暂未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="keyword">if</span>(endTime.isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(script, Collections.emptyList(), voucherId, userId);</span><br><span class="line">    <span class="keyword">if</span>(execute == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;lua脚本执行异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!execute.equals(<span class="number">0L</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足&quot;</span>) : Result.fail(<span class="string">&quot;限一人一单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成订单号</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order:&quot;</span>);</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    <span class="comment">//将订单信息存入到阻塞队列中</span></span><br><span class="line">    orderTasks.add(order);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h4><p>1.如下代码作用是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">SeckillVoucherHandler</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：因为类初始化之后，随时都可能要处理阻塞队列，所以在类实例初始化完成时，就开始执行<code>new SeckillVoucherHandler()</code>的run方法，处理阻塞队列。</p><h2 id="8-基于redis的消息队列"><a href="#8-基于redis的消息队列" class="headerlink" title="8.基于redis的消息队列"></a>8.基于redis的消息队列</h2><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>在redis中，一共有三种数据类型可以实现消息队列。</p><p><img src="/../images/image-20250314175932374.png" alt="image-20250314175932374"></p><h3 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a><strong>基于List结构模拟消息队列</strong></h3><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="/../images/1653575176451.png" alt="1653575176451"></p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li><strong>无法避免消息丢失</strong></li><li><strong>只支持单消费者</strong></li></ul><h3 id="基于PubSub结构模拟消息队列"><a href="#基于PubSub结构模拟消息队列" class="headerlink" title="基于PubSub结构模拟消息队列"></a><strong>基于PubSub结构模拟消息队列</strong></h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="/../images/1653575506373.png" alt="1653575506373"></p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="基于Stream实现消息队列"><a href="#基于Stream实现消息队列" class="headerlink" title="基于Stream实现消息队列"></a>基于Stream实现消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="/../images/1653577301737.png" alt="1653577301737"></p><p>例如：</p><p><img src="/../images/1653577349691.png" alt="1653577349691"></p><p>读取消息的方式之一：XREAD</p><p><img src="/../images/1653577445413.png" alt="1653577445413"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="/../images/1653577643629.png" alt="1653577643629"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="/../images/1653577659166.png" alt="1653577659166"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><p><img src="/../images/1653577689129.png" alt="1653577689129"></p><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="/../images/1653577801668.png" alt="1653577801668"></p><p>创建消费者组：<br><img src="/../images/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p><strong>从消费者组读取消息：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>对于起始消息ID,分两类情况，1.未消费 2.已消费未确认</p><p><strong>“&gt;”：从下一个未消费的消息开始</strong></p><p><strong>“0”：从第一个已消费未确认开始</strong></p><p><strong>“其他id”：从该id的后面开始获取已消费未确认的消息</strong><img src="/../images/image-20250406143645095.png" alt="image-20250406143645095"></p><p><strong>确认消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XACK key group id [id ...]</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250406142947663.png" alt="image-20250406142947663"></p><h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li><p>创建一个Stream类型的消息队列，名为stream.orders</p></li><li><p>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</p><p>或者</p><p>修改seckillVoucher，在执行完lua脚本，认定有抢购资格后，向stream.orders中添加消息，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line"><span class="comment">//3.3 发送消息到stream.order队列中</span></span><br><span class="line">stringRedisTemplate.opsForStream().add(MapRecord.create(<span class="string">&quot;stream.order&quot;</span>, map));</span><br></pre></td></tr></table></figure></li><li><p>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</p></li></ul><p>实现整体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHanler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHanler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//循环获取消息队列中的信息</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.获取消息队列中的订单信息  XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.order &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                        StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">//2.判断消息是否获取成功</span></span><br><span class="line">                <span class="keyword">if</span>(list == <span class="literal">null</span> || list.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//3.没有消息，进入下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.解析订单消息</span></span><br><span class="line">                <span class="comment">//这里的MapRecord中的第一个String是消息id,后面的Object和Object组合起来是一个map,存放键值对</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; entries =</span><br><span class="line">                        list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; map = entries.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//4.获取成功，则下单</span></span><br><span class="line">                handleVoucherOrder(order);</span><br><span class="line">                <span class="comment">//5.ACK确认消息</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>, <span class="string">&quot;g1&quot;</span>,  entries.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//若消息处理发生异常，则需要处理PendingList中的消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取PendingList中的消息</span></span><br><span class="line">            List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//2.判断消息是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span>(list == <span class="literal">null</span> || list.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//3.没有消息，说明消息已经全部确认完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.解析订单消息</span></span><br><span class="line">            <span class="comment">//这里的MapRecord中的第一个String是消息id,后面的Object和Object组合起来是一个map,存放键值对</span></span><br><span class="line">            MapRecord&lt;String, Object, Object&gt; entries =</span><br><span class="line">                    list.get(<span class="number">0</span>);</span><br><span class="line">            Map&lt;Object, Object&gt; map = entries.getValue();</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4.获取成功，则下单</span></span><br><span class="line">            handleVoucherOrder(order);</span><br><span class="line">            <span class="comment">//5.ACK确认消息</span></span><br><span class="line">            stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;stream.order&quot;</span>, <span class="string">&quot;g1&quot;</span>,  entries.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;处理PendingList中发生异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户、优惠券id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//2.获取锁对象</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//3.获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="comment">//4.判断锁是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        <span class="comment">//获取锁失败，输出日志</span></span><br><span class="line">        log.error(<span class="string">&quot;发送异常，没获取到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        proxy.createVoucherOrder(order);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户已经下过单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">         .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">         .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">     <span class="comment">//库存不足</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            userId.toString(),</span><br><span class="line">            voucherId.toString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(execute != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1不为0返回异常信息</span></span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足!&quot;</span>) : Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.创建订单,异步下单</span></span><br><span class="line">    <span class="comment">//3.1 获取订单id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(SECKILL_ORDER_KEY);</span><br><span class="line">    <span class="comment">//3.2将用户id, 优惠券id和 订单id存入stream中</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line">    <span class="comment">//3.3 发送消息到stream.order队列中</span></span><br><span class="line">    stringRedisTemplate.opsForStream().add(MapRecord.create(<span class="string">&quot;stream.order&quot;</span>, map));</span><br><span class="line">    <span class="comment">//3.4返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码详解-1"><a href="#代码详解-1" class="headerlink" title="代码详解"></a>代码详解</h4><p>因为是基于redis的Stream实现消息队列，所以涉及到的api比较多，下面简单解释下api.</p><p><strong>1.消费组消息获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                       Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                       StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                       StreamOffset.create(<span class="string">&quot;stream.order&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">               );</span><br></pre></td></tr></table></figure><p>上述代码翻译成redis语句是</p><p><code>XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.order &gt;</code></p><p>意思是从g1消费者组中获取一条未读取到的消息给消费者c1，若stream中有未读取的消息，则获取最早未读取的消息，若stream中没有消息，则阻塞2s。若2s内还未获取到新消息则结束。语句执行完的结果是读取到的消息。这里测试了下，如果有2个消费者c1和c2，c1读取到消息后，c2无法读取c1读取过的消息，即一条消息只能被一个消费者读取，这里就是单纯为了加快消费速度，将<strong>一个消费组交由多个消费者共同处理</strong>。不能把之前学习过的rabbitmq的广播机制代入到这里。</p><p>注意：代码中没有创建消费组这一代码的实现，因为这个消费组我们已经在redis中提前创建好了。</p><p><img src="/../images/image-20250406140243528.png" alt="image-20250406140243528"></p><p><strong>2.自动类型转换</strong></p><p>订单数据存入到消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line"><span class="comment">//3.3 发送消息到stream.order队列中</span></span><br><span class="line">stringRedisTemplate.opsForStream().add(MapRecord.create(<span class="string">&quot;stream.order&quot;</span>, map));</span><br></pre></td></tr></table></figure><p>从消息队列获取订单数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MapRecord&lt;String, Object, Object&gt; entries = list.get(<span class="number">0</span>);</span><br><span class="line">Map&lt;Object, Object&gt; map = entries.getValue();</span><br><span class="line"><span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可以看到，我们存入消息队列中的数据是Map&lt;String, String&gt;,最后从消息队列中读取出来的map类型是Map&lt;Object,Object&gt;，最后经由<strong>BeanUtil.fillBeanWithMap()</strong>,根据字段名称自动赋值和类型转换。</p><p>拿userId举例，实现了Long –&gt; String –&gt; Obejct –&gt; Long的类型转换，很厉害吧。</p><p>至于<code>BeanUtil.fillBeanWithMap(map, new VoucherOrder(), true)</code>这句代码中的true，则是为了忽略错误。</p><p>即当从 map 填充数据到目标对象（这里是 VoucherOrder）时，如果遇到某些字段无法匹配或转换失败的情况，ignoreError() 会告诉工具类忽略这些错误，继续完成其他字段的填充，而不是抛出异常中断整个过程。</p><p><strong>3.handlePendingList方法的作用</strong></p><p>pending-list中存的是获取已消费但未确认的消息。当我们从消息队列中获取到消息，并消费完消息时，需要根据消息id及时确认该消息已经被处理完成，否则改消息依然会存在于pending-list中等待确认。这种情况是为了防止获取到消息后，在消息处理时发生意外而导致的消息丢失问题。至于消息可能被重复消费（指的是消息处理完，但是在确认消息时发生意外）问题，那就看最终的消息处理有没有校验机制了，在这里，订单在创建时依然会进行一人一单和库存校验，所以不用担心消息被重复消费的问题。</p><p>因为redis的消息队列实用性不如专门的消息队列，所以点到为止。</p><h2 id="9-基于RabbitMq的消息队列"><a href="#9-基于RabbitMq的消息队列" class="headerlink" title="9.基于RabbitMq的消息队列"></a>9.基于RabbitMq的消息队列</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h3><p>添加内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">  host: 192.168.10.129 # 你的虚拟机IP</span><br><span class="line">  port: 5672 # 端口</span><br><span class="line">  virtual-host: ldy-mq # 虚拟主机</span><br><span class="line">  username: ldy # 用户名</span><br><span class="line">  password: 20050718 # 密码</span><br><span class="line">  listener:</span><br><span class="line">    simple:</span><br><span class="line">      prefetch: 1 #每个消费者每次只能获取一个消息，处理完才能获取下一条消息</span><br></pre></td></tr></table></figure><h3 id="3-新增消息监听类"><a href="#3-新增消息监听类" class="headerlink" title="3.新增消息监听类"></a>3.新增消息监听类</h3><p><img src="/../images/image-20250424152238039.png" alt="image-20250424152238039"></p><p>代码如下，其中第二个消息监听器是跟订单超时相关的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IVoucherOrderService voucherOrderService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; CANCEL_ORDER_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        CANCEL_ORDER_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        CANCEL_ORDER_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;cancelOrder.lua&quot;</span>));</span><br><span class="line">        CANCEL_ORDER_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;seckill.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;voucher.seckill.exchange&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;seckill&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerSeckillVoucherOrder</span><span class="params">(Map&lt;String, String&gt; map)</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取消息&quot;</span>+map);</span><br><span class="line">        <span class="comment">//map对象转换为order对象</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//4.获取成功，则下单</span></span><br><span class="line">        voucherOrderService.handleVoucherOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(&quot;voucher.order.overtime.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;voucher.order.dead.exchange&quot;, type = &quot;direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;overTime&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerOverTimeOrder</span><span class="params">(VoucherOrder order)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//如果订单未支付，则删除订单并删除相关库存和购票记录</span></span><br><span class="line">        <span class="keyword">if</span>(order.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> order.getId();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">            LambdaUpdateWrapper&lt;VoucherOrder&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>();</span><br><span class="line">            wrapper.eq(VoucherOrder::getId, orderId).set(VoucherOrder::getStatus, <span class="number">4</span>);</span><br><span class="line">            voucherOrderService.update(wrapper);</span><br><span class="line">            log.info(<span class="string">&quot;订单超时，已取消，订单id:&quot;</span>+orderId);</span><br><span class="line">            <span class="comment">//1.先恢复数据库库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                    .setSql(<span class="string">&quot;stock = stock + 1&quot;</span>)</span><br><span class="line">                    .update();</span><br><span class="line">            <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;数据库库存恢复异常，订单id:&quot;</span>+orderId);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;数据库库存恢复异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.恢复redis中的库存和购票记录，使用lua脚本保证原子性</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                        CANCEL_ORDER_SCRIPT,</span><br><span class="line">                        Collections.emptyList(),</span><br><span class="line">                        userId.toString(),</span><br><span class="line">                        voucherId.toString()</span><br><span class="line">                );</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;redis库存恢复异常，订单id:&quot;</span>+orderId);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;redis恢复库存异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-修改VoucherOrderServiceImpl"><a href="#4-修改VoucherOrderServiceImpl" class="headerlink" title="4.修改VoucherOrderServiceImpl"></a>4.修改VoucherOrderServiceImpl</h3><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, userId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;id&quot;</span>, orderId.toString());</span><br><span class="line">    map.put(<span class="string">&quot;voucherId&quot;</span>, voucherId.toString());</span><br><span class="line">    <span class="comment">//        //3.3 发送消息到stream.order队列中</span></span><br><span class="line">    <span class="comment">//        stringRedisTemplate.opsForStream().add(MapRecord.create(&quot;stream.order&quot;, map));</span></span><br><span class="line">    <span class="comment">//利用rabbitmq发送消息队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;voucher.seckill.exchange&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;seckill&quot;</span>, map);</span><br><span class="line">    <span class="comment">//3.4返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-新增订单超时自动删除功能"><a href="#5-新增订单超时自动删除功能" class="headerlink" title="5.新增订单超时自动删除功能"></a>5.新增订单超时自动删除功能</h3><p><strong>注意：</strong>因为黑马点评项目没有做支付功能模块的内容，所以有些业务点我们要考虑。</p><p>1.用户<strong>订单取消</strong>后<strong>还可以下单、库存要增加</strong>。</p><p>2.一人一单的查询逻辑要外加<strong>订单的状态判断</strong>。订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款</p><p>利用rabbitMq的延迟消息功能实现订单超时自动删除</p><p>（1）先安装DelayExchange插件</p><p>我是docker部署的rabbitmq，所以docker安装插件方法如下</p><p>插件下载地址：</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p><p>查看rabbitmq插件目录对应的数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250424153144268.png" alt="image-20250424153144268"></p><p>把插件安装到Mountpoint属性指向的目录里</p><p>然后执行以下命令启用插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>（2）修改createVoucherOrder创建订单的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).notIn(<span class="string">&quot;status&quot;</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户已经下过单&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    order.setStatus(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">    <span class="comment">//发送超时消息至死信交换机</span></span><br><span class="line">    System.out.println(<span class="string">&quot;准备发送超时消息&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(</span><br><span class="line">        RabbitMqConstant.VOUCHER_ORDER_DEAD_EXCHANGE,</span><br><span class="line">        RabbitMqConstant.DEAD_VOUCHER_ORDER_KEY,</span><br><span class="line">        order,</span><br><span class="line">        message -&gt; &#123;</span><br><span class="line">            <span class="comment">//为方便测试10秒即超时</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250424153500512.png" alt="image-20250424153500512"></p><p>监听器的代码看第3点。</p><h1 id="五、达人探店"><a href="#五、达人探店" class="headerlink" title="五、达人探店"></a>五、达人探店</h1><h2 id="1-发布探店笔记"><a href="#1-发布探店笔记" class="headerlink" title="1.发布探店笔记"></a>1.发布探店笔记</h2><p>关于发布探店笔记，这里主要是存储相应的探店图片。</p><p>图片上传接口如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原始文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 生成新文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">createNewFileName</span><span class="params">(String originalFilename)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取后缀</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> StrUtil.subAfter(originalFilename, <span class="string">&quot;.&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 生成目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> name.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> hash &amp; <span class="number">0xF</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> (hash &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">    <span class="comment">// 判断目录是否存在</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;&quot;</span>, d1, d2));</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">        dir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成文件名</span></span><br><span class="line">    <span class="keyword">return</span> StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;/&#123;&#125;.&#123;&#125;&quot;</span>, d1, d2, name, suffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码详解-2"><a href="#代码详解-2" class="headerlink" title="代码详解"></a>代码详解</h3><p>1.获取文件后缀suffix</p><p><code>String suffix = StrUtil.subAfter(originalFilename, &quot;.&quot;, true);</code>这段代码是获取文件的后缀名，例如test.jpg，获取到的就是jpg后缀。</p><p>2.uuid,d1和d2的作用</p><p>首先根据UUID生成一个随机字符串并做为最后的文件名称，再获取这个随机字符串的hash值，根据这个hash值，先取低4位，再右移4位再取低4位。作用就是d1是文件第一层的编号（0-15），d2是文件第二层的编号（0-15）。所以d1和d2就是获取一个随机存放图片的路径。而uuid和suffix结合就是最后存储的文件名称。最后获取的到的文件名不仅包含了文件名，还包含了一部分存储文件路径。</p><p>3.transferTo方法作用</p><p>transferTo方法会将 MultipartFile 对象中的文件内容写入到目标文件路径中。</p><p>如果目标路径的目录不存在，<code>transferTo</code> 方法不会自动创建目录，因此在调用 <code>transferTo</code> 之前，需要确保目标目录已经存在（如在 <code>createNewFileName</code> 方法中已经创建了目录）。</p><h2 id="2-查看探店笔记"><a href="#2-查看探店笔记" class="headerlink" title="2.查看探店笔记"></a>2.查看探店笔记</h2><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">    <span class="keyword">if</span>(blog == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取博客对应的作者信息</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">    <span class="comment">// 查询已被点赞</span></span><br><span class="line">    isBlogLiked(blog);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，除了经过数据库查询外，还进行了作者信息查询和点赞信息查询</p><p>所以Blog这个实体类中还有额外的参数设置,如下所示，icon、name、和isLike不是数据库对应表中的字段，所以加上了<code>@TableFiled(exist = false)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否点赞过了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isLike;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-点赞功能-ZSet"><a href="#3-点赞功能-ZSet" class="headerlink" title="3.点赞功能-ZSet"></a>3.点赞功能-ZSet</h2><p>对于点赞功能的实现，我们需要保证，每篇笔记每个人只能点一次赞，再点赞只能取消，一个人不能刷赞。这个功能基于数据库来实现的话，还需要存储额外的一张表来对于用户id和笔记id。比较浪费时间，空间也比较浪费。所以我们基于redis中的zset这个数据类型来存储每篇笔记的点赞用户。</p><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查看用户是否点赞过该篇博客</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//若用户未登录，则无法点赞</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户未登录，无法点赞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKE_KEY + id;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    <span class="comment">//2.若没点赞过，则点赞数加一</span></span><br><span class="line">    <span class="keyword">if</span>(score == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="built_in">this</span>.update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span>(success)&#123;</span><br><span class="line">            <span class="comment">//2.1.保存用户到set集合</span></span><br><span class="line">            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3.若已点赞，则数据库点赞数减一</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="built_in">this</span>.update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span>(success)&#123;</span><br><span class="line">            <span class="comment">//3.1.把用户从redis的Set集合移出</span></span><br><span class="line">            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先在redis中校验当前用户是否已经点赞过，若已点赞，则先在数据库中点赞数减一，再把用户从redis集合中移出。未点赞同理。</p><h2 id="4-点赞排行榜"><a href="#4-点赞排行榜" class="headerlink" title="4.点赞排行榜"></a>4.点赞排行榜</h2><p>上面点赞功能的实现为什么使用zset而不使用set，主要是因为为了实现点赞排行榜这个功能。</p><p>首先，先明确这个点赞排行榜的功能指的是最近点赞的用户，即越新的赞，排行越靠前。而zset中，我们存储的是点赞的当前时间戳，所以需要使用rever</p><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询近期点赞的top5用户</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKE_KEY + id;</span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().reverseRange(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//2.解析其中的用户id</span></span><br><span class="line">    <span class="keyword">if</span>(top5 == <span class="literal">null</span> || top5.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//若top5为空，表明没有人点赞。则直接返回空集合</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//3.根据用户id查询用户,并赋值信息到userDto，避免重要数据泄露</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>,ids);</span><br><span class="line">    List&lt;User&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>,ids).last(<span class="string">&quot;order by Field(id,&quot;</span> + str+ <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    List&lt;UserDTO&gt; userDtos = users.stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDtos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提问-4"><a href="#提问-4" class="headerlink" title="提问"></a>提问</h3><p>1.Set集合不是无序吗，为什么能保证最后ids是有序的？</p><p>答：因为使用了Stream的方式。虽然 <code>Set</code> 是无序的，但在迭代时，<code>Stream</code> 会按照提取的顺序处理这些值。</p><ul><li><code>reverseRange</code> 方法返回的 <code>Set&lt;String&gt;</code> 的内容是按照 Redis 中有序集合的倒序排列提取的。</li><li>使用 <code>Stream</code> 和 <code>collect</code> 方法将 <code>Set&lt;String&gt;</code> 转换为 <code>List&lt;Long&gt;</code> 时，会保留 <code>Set</code> 的迭代顺序。</li><li>因此，<code>ids</code> 的顺序会和 Redis 中的有序集合的倒序一致。</li></ul><p>2.为什么sql语句查询最后要使用<code>order by Field(id,&quot; + str+ &quot;)&quot;</code></p><p>答：为了让最后获取到的字段按照ids的顺序排列，保证获取到的用户信息严格按照点赞顺序排列。</p><p><code>ORDER BY FIELD()</code> 是一种特殊的排序方式，用于根据指定的值列表对结果进行排序。它允许你定义一个自定义的排序顺序，而不是按照默认的升序或降序排序。</p><p><code>ORDER BY FIELD()</code> 的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> FIELD(column_name, value1, value2, value3, ...)</span><br></pre></td></tr></table></figure><ul><li><code>column_name</code>：需要排序的列名。</li><li><code>value1, value2, value3, ...</code>：定义的排序顺序。这些值是列中可能存在的值，它们将按照指定的顺序进行排序。</li><li>如果查询到的字段的value并没有在order by field()的value中，则默认排到最后。它们之间的排序顺序是按照默认的升序或降序。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在上面代码中，很好的使用了stream流的方式处理数据，先是Set转为List,然后是User转为UserDTO避免不必要字段泄露。</p><h1 id="六、好友关注"><a href="#六、好友关注" class="headerlink" title="六、好友关注"></a>六、好友关注</h1><h2 id="1-关注功能"><a href="#1-关注功能" class="headerlink" title="1.关注功能"></a>1.关注功能</h2><p>好友关注功能一共有三个接口，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">IFollowService followService;</span><br><span class="line"><span class="comment">//关注好友</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isfollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@PathVariable(&quot;isfollow&quot;)</span> Boolean isfollow)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(id, isfollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.isFollow(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询共同好友</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.followCommons(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的实现方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long id, Boolean isfollow)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取登录用户的id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follow:&quot;</span>+userId;</span><br><span class="line">    <span class="comment">//2.判断是取关还是关注</span></span><br><span class="line">    <span class="keyword">if</span>(isfollow)&#123;</span><br><span class="line">        <span class="comment">//3.1关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setFollowUserId(id);</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        <span class="comment">//3.2添加关注信息到redis</span></span><br><span class="line">        stringRedisTemplate.opsForSet().add(key, id.toString());</span><br><span class="line">        save(follow);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//4.1取关</span></span><br><span class="line">        remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, id));</span><br><span class="line">        <span class="comment">//4.2从redis中移除信息</span></span><br><span class="line">        stringRedisTemplate.opsForSet().remove(key, id.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2.查询是否关注</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;follow_user_id&quot;</span>, id).eq(<span class="string">&quot;user_id&quot;</span>, userId).count();</span><br><span class="line">    <span class="comment">//3.判断返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follow:&quot;</span>+userId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;follow:&quot;</span>+id;</span><br><span class="line">    <span class="comment">//2.获取双方的关注set交集</span></span><br><span class="line">    Set&lt;String&gt; commons = stringRedisTemplate.opsForSet().intersect(key, key1);</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(commons))&#123;</span><br><span class="line">        <span class="comment">//若无交集，则返回空集合</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; list = commons.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//4.获取用户</span></span><br><span class="line">    List&lt;UserDTO&gt; userDtos = userService.listByIds(list).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDtos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，添加关注和查看共同关注功能利用了redis的set集合。用户的关注消息存储到set集合中可以方便获取共同好友以及获取动态推送的粉丝信息，避免读取数据库花费较多时间。</p><h2 id="2-好友动态推送-Feed流"><a href="#2-好友动态推送-Feed流" class="headerlink" title="2.好友动态推送-Feed流"></a>2.好友动态推送-Feed流</h2><p>首先介绍下什么是Feed流</p><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="/../images/1653808641260.png" alt="1653808641260"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="/../images/1653808993693.png" alt="1653808993693"></p><p>Feed流的实现有两种模式：</p><p>Feed流产品有两种常见模式：<br><strong>Timeline</strong>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p><strong>智能排序</strong>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><p>，因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序。</p><p>简单来说就是把消息写到自己的发件箱，粉丝都从这个发件箱里拉信息。</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="/../images/1653809450816.png" alt="1653809450816"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>简单来说就是把消息写到粉丝的收件箱，粉丝读他们自己的收件箱即可。</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="/../images/1653809875208.png" alt="1653809875208"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="/../images/1653812346852.png" alt="1653812346852"></p><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="/../images/1653813047671.png" alt="1653813047671"></p><p>Feed流的滚动分页</p><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="/../images/1653813462834.png" alt="1653813462834"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-获取推送信息"><a href="#3-获取推送信息" class="headerlink" title="3.获取推送信息"></a>3.获取推送信息</h2><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p><img src="/../images/1653819821591.png" alt="1653819821591"></p><p>一、定义出来具体的返回值实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogController</p><p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码详解-3"><a href="#代码详解-3" class="headerlink" title="代码详解"></a>代码详解</h3><h4 id="1-下面这段代码在做什么"><a href="#1-下面这段代码在做什么" class="headerlink" title="1.下面这段代码在做什么"></a>1.下面这段代码在做什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>答：这段代码用于获取<strong>最小时间戳minTime</strong>，并且获取<strong>偏移量os</strong>。最小时间戳作为下一次查询的最大时间戳，offset是下一次查询时跳过的元素个数（默认为一，因为最大时间戳是上一次遍历的最小时间戳，所以查询时起码要跳过这1条）。设置偏移量是为了<strong>防止多条动态发布的时间戳一样</strong>的情况下，记录已经获取了的相同最小时间戳的动态的条数。在接着往下查询时会跳过偏移量数量的动态。这段代码是for循环，所以从前往后遍历，所以需要在time不等于minTime的情况下更新minTime并重置os,因为越后面时间戳越小。</p><h4 id="2-reverseRangeByScoreWithScores-方法"><a href="#2-reverseRangeByScoreWithScores-方法" class="headerlink" title="2.reverseRangeByScoreWithScores 方法"></a>2.reverseRangeByScoreWithScores 方法</h4><p>reverseRangeByScoreWithScores 方法用于从 Redis 的有序集合（ZSet）中，按照分数范围从高到低获取元素及其分数。<br>参数说明：</p><ul><li>key: 指定操作的 ZSet 键。</li><li>min 和 max: 分别表示分数范围的下限和上限（这里是 0 和 max）。</li><li>offset: 表示跳过的元素个数，即从符合条件的元素中跳过前面的 offset 个元素。</li><li>count: 表示最多返回的元素个数（这里是 3）。</li></ul><h1 id="七、附近商户"><a href="#七、附近商户" class="headerlink" title="七、附近商户"></a>七、附近商户</h1><h2 id="1-GEO数据结构的基本用法"><a href="#1-GEO数据结构的基本用法" class="headerlink" title="1.GEO数据结构的基本用法"></a>1.GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li><p>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</p><p><code>geoadd geo:1 10 10 dongyang 10.1 10.1 yiwu</code></p></li><li><p>GEODIST：计算指定的两个点之间的距离并返回</p><p><code>geodist geo:1 dongyang yiwu km</code></p><p><img src="/../images/image-20250408202246048.png" alt="image-20250408202246048"></p></li><li><p>GEOHASH：将指定member的坐标转为hash字符串形式并返回</p><p><code>geohash geo:1 dongyang</code></p><p><img src="/../images/image-20250408202434818.png" alt="image-20250408202434818"></p></li><li><p>GEOPOS：返回指定member的坐标</p><p><img src="/../images/image-20250408202457694.png" alt="image-20250408202457694"></p></li><li><p>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</p></li><li><p>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</p><p><img src="/../images/image-20250408204702412.png" alt="image-20250408204702412"></p></li><li><p>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</p></li></ul><p>注意：<strong>GEO数据结构本质就是ZSet数据结构</strong></p><p><img src="/../images/image-20250408201915030.png" alt="image-20250408201915030"></p><h2 id="2、-导入店铺数据到GEO"><a href="#2、-导入店铺数据到GEO" class="headerlink" title="2、 导入店铺数据到GEO"></a>2、 导入店铺数据到GEO</h2><p>具体场景说明：</p><p><img src="/../images/1653822036941.png" alt="1653822036941"></p><p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p><p><img src="/../images/1653822021827.png" alt="1653822021827"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><p>代码</p><p>HmDianPingApplicationTests</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">//方法1，每得到一个地理信息就添加到redis</span></span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            <span class="comment">//方法2，先存到集合里，最后再一次性添加到redis中</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法2,一次性添加</span></span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码详解-4"><a href="#代码详解-4" class="headerlink" title="代码详解"></a>代码详解</h3><h4 id="1-stream流分组"><a href="#1-stream流分组" class="headerlink" title="1.stream流分组"></a>1.stream流分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, List&lt;Shop&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br></pre></td></tr></table></figure><p>熟悉stream流的分组方法。</p><h4 id="2-Geo相关api"><a href="#2-Geo相关api" class="headerlink" title="2.Geo相关api"></a>2.Geo相关api</h4><p>看代码注释。</p><h2 id="3-附近商户-实现附近商户功能"><a href="#3-附近商户-实现附近商户功能" class="headerlink" title="3 附近商户-实现附近商户功能"></a>3 附近商户-实现附近商户功能</h2><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><p>第一步：导入pom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.1</span><span class="number">.6</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步：</p><p>ShopController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShopServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key, </span><br><span class="line">                        GeoReference.fromCoordinate(x, y), <span class="comment">//以（x, y）为坐标点</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>), <span class="comment">//搜素范围，5000米</span></span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)<span class="comment">// limit表示返回的结果数量，includeDistance表示返回结果包含与中心点距离</span></span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="代码详解-5"><a href="#代码详解-5" class="headerlink" title="代码详解"></a>代码详解</h3><p><strong>1.geoSearch方法看代码注释</strong></p><p>new Distance(5000), 默认单位为米。若指定，则可以<code>new Distance(50000, Metrics.KILOMETERS)</code>，代表50000公里。所以，<strong>多用ctrl+p查看有什么重载方法</strong>。</p><p><strong>2.stream流的过滤</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">content.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">    ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">    distanceMap.put(shopIdStr, result.getDistance());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.根据id查询shop</span></span><br><span class="line"><span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">List&lt;Shop&gt; shopList = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD( id, &quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"><span class="keyword">for</span> (Shop shop : shopList) &#123;</span><br><span class="line">    shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">    System.out.println(shop.getDistance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是分页查询，虽然查了end个，但最后还是得跳过前面的from个数量。</p><p>同时，为了按位置顺序排列，使用forEach遍历时，要按序存储id到ids列表为sql查询作排序，此外，为了记录距离，还需要设置一个distanceMap存储对应id的离中心点的距离,方便最后查找出结果后再添加上距离。</p><h1 id="八、用户签到"><a href="#八、用户签到" class="headerlink" title="八、用户签到"></a>八、用户签到</h1><p>用户</p><h2 id="1-BitMap数据结构"><a href="#1-BitMap数据结构" class="headerlink" title="1.BitMap数据结构"></a>1.BitMap数据结构</h2><ul><li><p>SETBIT：向指定位置（offset）存入一个0或1</p><p><code>setbit sign:202504:1 0 1</code></p></li><li><p>GETBIT ：获取指定位置（offset）的bit值</p><p><code>getbit sign:202504:1 0</code></p></li><li><p>BITCOUNT ：统计BitMap中值为1的bit位的数量</p><p><code>bitcount sign:202504:1 0 4</code>   闭包统计，即[0-4]</p></li><li><p>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</p><p>bitfield的命令选项有些多</p><p>1.get选项，假设当前bit存储内容为10001000</p><p><code>bitfield sign:202504:1 get u8 0</code>，获取偏移量0开始的8位无符号整数。得136</p><p><code>bitfield sign:202504:1 get u8 4</code>，获取偏移量4开始的8位无符号整数，末尾自动补零。得128</p><p><img src="/../images/image-20250409004301279.png" alt="image-20250409004301279"></p><p>2.set,选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置位于偏移量0的8位无符号整数为10,即 00001010</span><br><span class="line">BITFIELD mykey SET u8 0 10</span><br></pre></td></tr></table></figure></li><li><p>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</p><p><img src="/../images/image-20250409004911234.png" alt="image-20250409004911234"></p></li><li><p>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</p></li><li><p>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</p></li></ul><p>注意:BitMap本质上是String</p><h2 id="2-实现签到功能"><a href="#2-实现签到功能" class="headerlink" title="2.实现签到功能"></a>2.实现签到功能</h2><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="/../images/1653833970361.png" alt="1653833970361"></p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以年月为key进行存储,因为dayOfMonth是从1开始的，所以需要减一从0索引开始存储。</p><h2 id="3-签到统计"><a href="#3-签到统计" class="headerlink" title="3. 签到统计"></a>3. 签到统计</h2><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="/../images/1653834455899.png" alt="1653834455899"></p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><p><img src="/../images/1653835784444.png" alt="1653835784444"></p><p>代码</p><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码详解-6"><a href="#代码详解-6" class="headerlink" title="代码详解"></a>代码详解</h3><ol><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">           key,</span><br><span class="line">           BitFieldSubCommands.create()</span><br><span class="line">                   .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>其中的<code>BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)</code>用于设置读取方式为无符号的当前天数，偏移量为0。得到的是10进制的整数，从list中取第一个即可。</p><p>2.统计连续签到。</p><p>利用十进制转二进制的比较进行。每次都进行最低位&amp;1比较，为1则结果加1并将该数往右移一位。若为0则停止统计。</p><h1 id="九、UV统计"><a href="#九、UV统计" class="headerlink" title="九、UV统计"></a>九、UV统计</h1><p>使用HyperLogLog数据结构进行访问量统计</p><h2 id="1-HyperLogLog数据结构"><a href="#1-HyperLogLog数据结构" class="headerlink" title="1.HyperLogLog数据结构"></a>1.HyperLogLog数据结构</h2><p>先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="/../images/1653837988985.png" alt="1653837988985"></p><p>1.pfadd</p><p><code>pfadd myuv 1</code>   <code>pfadd myuv2 3</code></p><p>2.pfcount</p><p><code>pfcount myuv</code>  结果：1</p><p>3.pfmerge</p><p><code>pfmerge myuv myuv2</code></p><p><code>pfcount myuv</code>  结果：2</p><p>注意，HyperLogLog底层是String类型</p><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><p><img src="/../images/1653838053608.png" alt="1653838053608"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>至此，黑马点评的复习结束了。总算是复习完成了，现在是2025&#x2F;4&#x2F;9 1:08。比预想的晚了2天才结束，从关注开始就比较快速的过一遍了，不过也算够了吧，但也还是把关键代码都再写了一遍，也算是仓促吧，后面开始复习微服务了，还要背八股&#x2F;(ㄒoㄒ)&#x2F;~~。加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="/2025/03/25/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/25/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="和"><a href="#和" class="headerlink" title="&amp;&amp;和||"></a>&amp;&amp;和||</h3><p>&amp;&amp;:从前往后执行，有一个失败则不继续执行</p><p>||:从前往后执行，有一个成功则不继续执行</p><p>例子：<code>ping www.hdu.com -c 10 -w 10 &amp;&amp; echo success || echo failure</code></p><p>-c：发送数据包的次数</p><p>-w：总体超时时间，整个ping的最大运行时长</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p> <code>&gt;</code>:将标准输出以覆盖原文件的方式写入</p><p><code>&gt;&gt;</code>:将标准输出追加方式写入</p><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p><code>&lt;</code>：用于将文件的内容作为输入传递给命令。</p><p><img src="/../images/image-20250401191948972.png" alt="image-20250401191948972"></p><p><code>&lt;&lt;</code>:用于将多行文本（自己输入的）作为输入传递给命令，适合在脚本中嵌入多行文本。</p><p>用法和<code>&lt;</code>有区别，这个后面跟的是分隔符–用于多行输入时终止输入的标志。例如<code>cat &lt;&lt; EOF</code></p><p>下图所示的stop是终止输入的标志。</p><p><img src="/../images/image-20250401191925870.png" alt="image-20250401191925870"></p><p><code>&lt;&lt;&lt;</code>:用于单行字符串的输入</p><h3 id="带-的重定向"><a href="#带-的重定向" class="headerlink" title="带&amp;的重定向"></a>带&amp;的重定向</h3><p>前置知识点：<strong>文件描述符</strong></p><p>0标准输入stdin按键</p><p>1标准输出stdout屏幕</p><p>2标准错误输出stderr屏幕</p><p><code>&amp;&gt;</code>:将标准输出和错误输出重定向到文件中。</p><p>类似于部署jar包时的<code>&gt; my.log 2&gt;&amp;1</code>,但这个更灵活！！！可以指定重定向到哪里。</p><p><code>jdk -jar steel.jar &gt; my.log 2&gt;&amp;1</code></p><p><code>&gt;&amp;n</code>:</p><p><a href="https://www.linuxcool.com/lsrsccdxzqkk">linux输入输出重定向之前，看看什么是linux的文件描述符 – Linux命令大全(手册)</a></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="挑战一"><a href="#挑战一" class="headerlink" title="挑战一"></a>挑战一</h3><p>1.创建多级目录</p><p><img src="/../images/image-20250325184118204.png" alt="image-20250325184118204"></p><p>2.通配符</p><p>（1）cp</p><p>（2）mv</p><p>3.touch</p><p>4.rm</p><p>5.ls</p><p>tip:</p><p><code>cd</code> 或者 <code>cd ~</code>回到家目录</p><p><code>cd -</code> 回到上次操作所在目录</p><p><code>grep ^$ 文件路径</code>  查询空行，正则表达式：^行首，$行尾</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis最佳实践</title>
      <link href="/2025/03/22/Redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/03/22/Redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-键值设计"><a href="#1-键值设计" class="headerlink" title="1.键值设计"></a>1.键值设计</h2><h4 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h4><p>key的最佳实践约定</p><p>1.遵循基本格式：**[业务名称]:[数据名]:[id]**</p><p><img src="/../images/image-20250322180037311.png" alt="image-20250322180037311"></p><p>2.长度不超过44字节</p><p>3.不包含特殊字符</p><p>优点</p><ol><li>可读性强</li><li>避免key冲突</li><li>方便管理</li><li>更节省内存：key是string类型，底层编码包含int,embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。raw模式下，内存空间不是连续的，而是会采用指针形式指向其他空间。</li></ol><h4 id="拒绝BigKey"><a href="#拒绝BigKey" class="headerlink" title="拒绝BigKey"></a>拒绝BigKey</h4><p>什么是BigKey</p><ol><li>key本身的数据量过大，比如一个key的值就占了5MB。</li><li>key中的成员数过多，比如一个ZSET类型的key,它的成员数量为10000个。</li><li>key中成员的数据量过大，比如一个Hash类型的key,它的成员数量虽然只有1000个，但这些value的总大小为100MB。</li></ol><p>推荐值：</p><ul><li>单个key的value小于10kb</li><li>对于集合类型的key，建议元素数量小于1000</li></ul><p><img src="/../images/image-20250323222905155.png" alt="image-20250323222905155"></p><h4 id="选择合理的数据结构"><a href="#选择合理的数据结构" class="headerlink" title="选择合理的数据结构"></a>选择合理的数据结构</h4><p><img src="/../images/image-20250323223329263.png" alt="image-20250323223329263"></p><h2 id="2-批处理优化"><a href="#2-批处理优化" class="headerlink" title="2.批处理优化"></a>2.批处理优化</h2><h4 id="单个命令的执行流程"><a href="#单个命令的执行流程" class="headerlink" title="单个命令的执行流程"></a>单个命令的执行流程</h4><p>一次命令响应时间&#x3D;一次往返的网络传输所耗的时间 + 1次redis执行命令耗时</p><p><img src="/../images/image-20250323225424880.png" alt="image-20250323225424880"></p><p>问题：一次命令响应时间耗费时长主要由<strong>网络传输耗时</strong>造成。这样导致N次命令的响应时间&#x3D;N次往返的网络传输耗时+N次redis执行命令耗时。</p><p><img src="/../images/image-20250323225704228.png" alt="image-20250323225704228"></p><p>如果我们在处理某个业务流程时，需要多次循环往redis中存取数据时，会相当耗时，所以我们可以视情况而优化流程。比如使用MSET和Pipeline，来一次性通过网络发送全部的数据，而不是一次一次的发送。这就是批处理。</p><h4 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h4><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据。例如</p><ul><li>mset</li><li>hmset</li></ul><p>代码演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:不要在一次批处理中传输太多命令，否则单次命令占用的带宽太多，会导致网络阻塞</p><h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理时，建议使用Pipeline功能。</p><p>代码演示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>注意：Mxxx方法执行时间比Pipeline要快。因为Mxxx方法是redis原生的命令，是有原子性的，而Pipeline则是非原子性执行命令的，所以执行所有的命令期间可能会插入其他请求发送过来的命令，导致耗时慢些，不过问题不大。</p><h4 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h4><p>集群处理暂时先不总结了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>批处理方案</p><ol><li>原生的M操作</li><li>Pipeline批处理</li></ol><p>注意事项</p><ol><li>批处理时不建议一次携带太多命令</li><li>Pipeline的多个命令之间不具备原子性</li></ol><h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><h4 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评笔记</title>
      <link href="/2025/03/07/Redis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/07/Redis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缓存机制"><a href="#1-缓存机制" class="headerlink" title="1.缓存机制"></a>1.缓存机制</h2><p>数据一致性：先修改数据库再删除redis缓存。先删缓再删数据发生线程安全的问题更大，因为数据库修改数据耗时长，可能删了缓存后在数据库信息修改还没好之前，又读取了该信息并缓存了。</p><h2 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h2><p>客户端访问数据库中不存在的数据，缓存永远不生效，可能会被恶意攻击数据库导致瘫痪。<br>方法1.缓存空对象  2.布隆过滤</p><h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h2><p>指的是同一时间段内，redis中大量的缓存的key同时失效或者redis服务器宕机了，导致有大量请求到达数据库，带来巨大压力<br>解决方法：1.给TTL添加随机值 2.利用redis集群 3.给缓存业务添加降级限流策略（微服务内容）4.添加多级缓存</p><h2 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4.缓存击穿"></a>4.缓存击穿</h2><p>指的是某一个被高并发访问并且该缓存重建业务较复杂的key突然失效了，导致大量请求到达数据库，带来巨大冲击。<br>解决方法：1.添加互斥锁到redis中 2.逻辑过期</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h5 id="通用的redis缓存工具"><a href="#通用的redis缓存工具" class="headerlink" title="通用的redis缓存工具"></a><strong>通用的redis缓存工具</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 缓存工具类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//通用写入缓存方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, expireTime, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通用写入缓存方法 -- 逻辑过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithExpire</span><span class="params">(String key, Object value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个逻辑过期对象通用类</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(expireTime)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用读缓存方法 -- 解决缓存穿透</span></span><br><span class="line">    <span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">//1.先查redis缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.若redis中存在则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(str, type);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.若redis中没有，则访问数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.1数据库中不存在，空值写入redis，防止缓存穿透</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, expireTime, unit);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2.若数据库中存在，则存入redis中, 缓存时间为30分钟</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), expireTime, unit);</span><br><span class="line">        <span class="comment">//4.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用获取对象 -- 解决缓存击穿 -- 逻辑过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryWithLogicExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, String lockPrefix, Long prolongTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">//1.先查redis缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">strJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.若未命中，则直接返回null, 因为逻辑过期场景下，redis中的数据是提前写好的，没有就不需要查数据库了</span></span><br><span class="line">        <span class="keyword">if</span>(!StrUtil.isNotBlank(strJson))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.若redis命中，则判断是否逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//因为redisObject是一个通用类，所以data类型是Object,这种情况下需要先强转为JSONObject,再使用JSONUtil.toBean()</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="comment">//4.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="comment">//4.1未过期，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2已过期，需缓存重建</span></span><br><span class="line">        <span class="comment">//5.缓存重建</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> tryLock(lockPrefix+id);</span><br><span class="line">        <span class="comment">//5.2判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">            <span class="comment">//5.3成功</span></span><br><span class="line">            <span class="comment">//5.4二次判断redis当中此时是否已经更新过过期时间了</span></span><br><span class="line">            strJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            redisData = JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">            expireTime = redisData.getExpireTime();</span><br><span class="line">            <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">                data = (JSONObject)redisData.getData();</span><br><span class="line">                <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.5开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(()-&gt;</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.6查询数据库</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">                setWithExpire(key, r, prolongTime, unit);</span><br><span class="line">                <span class="comment">//5.7释放锁</span></span><br><span class="line">                releaseLock(lockPrefix+id);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.7返回过期的店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取互斥锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//尝试设置redis内容,若设置成功则表明获取到了锁，若失败，则说明已经有人拿到了这个锁</span></span><br><span class="line">        <span class="comment">//设置过期时间是怕获取到锁的线程发生问题时独占锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放互斥锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的通用方法写的太神了，很好的利用到了泛型和消费者机制，把原本写在serviceImpl里的方法直接提取出来了，以shop模块的查询功能为例，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//解决缓存穿透方案</span></span><br><span class="line">    <span class="comment">//Result result = queryByIdByPassThrough();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决缓存击穿方案--互斥锁，包含了解决缓存穿透</span></span><br><span class="line">    <span class="comment">//Shop shop = queryWithMutex(id);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决缓存击穿方案2--逻辑过期</span></span><br><span class="line">    <span class="comment">//Shop shop = queryWithLogicExpire(id);</span></span><br><span class="line"><span class="comment">//将以上方法提炼到通用方法，使用通用方法结果如下</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithLogicExpire(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, LOCK_SHOP_KEY, <span class="number">20L</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺id不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 查看方法参数的快捷键是<strong>ctrl+P</strong>,我现在才知道啊。。。。。</p><h5 id="全局唯一id方法"><a href="#全局唯一id方法" class="headerlink" title="全局唯一id方法"></a><strong>全局唯一id方法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//开始时间戳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//2025年3月8号做为起始时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1741464196</span>;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">dateSeconds</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> dateSeconds - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2.生成序列号</span></span><br><span class="line">        <span class="comment">//2.1获取当前时间，精确到天，做为当天自增长key的一部分</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2自增长</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;incr:&quot;</span> + keyPrefix + date);</span><br><span class="line">        <span class="comment">//3.拼接并返回， 时间戳（每秒都不一样）在前32位，自增长id在后32位，这样子可以支持每秒产生最多2^32次个不同的id,当然，这一天最多只能产生2^32次个id</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优惠券秒杀机制"><a href="#优惠券秒杀机制" class="headerlink" title="优惠券秒杀机制"></a><strong>优惠券秒杀机制</strong></h5><p>这里很好的用到了锁和事务的内容</p><p>1.乐观锁，即每次访问数据库时再次校验数据库内容是否发生变更，在尚庭公寓项目里是利用了version字段来实现，而这里因为是对优惠券的库存操作，每次库存减一对应版本号加一，所以可用让库存充当版本号的作用，即每次更新库存时，都加上之前获取到的库存值判断。</p><p>但又因为这样子并发情况又会出问题。假设两个线程一开始获取的库存数都是100，线程一先修改列库存，变成99，此时线程二取修改，发现库存不对，就失败，导致明明有库存，但获取失败的情况。</p><p>所以判断条件改为了stock &gt; 0。</p><p>2.悲观锁，解决一人一单问题，一人一单用的是查询操作，所以无法使用乐观锁。锁的对象是常量池中的字符串，而不能是每次访问都会new的对象（这样子的话，锁完全没用）</p><p>3.事务失效需要交给代理，所以需要获取代理对象来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询秒杀券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="keyword">if</span>(voucher == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀券不存在!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断秒杀券是否开始</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断秒杀券是否结束</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//给用户id加锁，intern是指锁的对象是常量池中的字符串</span></span><br><span class="line">    <span class="comment">//因为每次toString创建的都是新对象，加锁没有用，所以需要intern()方法</span></span><br><span class="line">    <span class="comment">//同时，锁需要在事务提交之后才能释放，保证线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">//因为事务生效实际上是由代理对象执行的，所以this.createVoucherOrder实际上并不会开启线程，所以需要获取事务的原始对象的代理对象</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span>  <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId, Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1获取订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order:&quot;</span>);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    <span class="comment">//6.2用户id</span></span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    <span class="comment">//6.3代金券id</span></span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5.分布式锁"></a>5.分布式锁</h2><p>上面的锁只能锁单个服务器，当面临多个集群部署时，没办法锁住全部的服务器，所以需要使用分布式锁来解决。</p><p>而redis恰好可以实现分布式锁（当多个集群公用一个redis时）。</p><p>下面是自定义分布式锁工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//uuid用于区分进程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">keyPrefix</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long expireSecond)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线程id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(keyPrefix + name, uuid+id, expireSecond, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//防止b是null时拆箱出错</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取redis锁中的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(keyPrefix + name);</span><br><span class="line">        <span class="comment">//判断锁中的uuid+线程id是否与当前线程一致   uuid用于标识不同进程， 线程id用于标识同一进程下的不同id.因为不同进程的线程id可能相同</span></span><br><span class="line">        <span class="comment">//比较是为了防止当前线程阻塞且锁过期时，第二个线程获取锁后，当前线程又复活了，防止当前线程删除第二个线程的锁。</span></span><br><span class="line">        <span class="keyword">if</span>(val.equals(uuid + Thread.currentThread().toString()))&#123;</span><br><span class="line">            stringRedisTemplate.delete(keyPrefix + name);</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而上面代码依然会有线程安全的问题，因为<strong>unlock（）</strong>方法获取redis锁中的值和释放锁是两步操作，极端情况下，可能获取到锁中的值是当前线程的，但在删除锁时遭遇阻塞，可能期间就已经过期，并且还被其他线程获取到锁了，当该线程最终继续执行删除时，可能就把别的线程的锁给释放了。这就是<strong>原子性</strong>问题了。</p><h2 id="6-Lua脚本"><a href="#6-Lua脚本" class="headerlink" title="6.Lua脚本"></a>6.Lua脚本</h2><p>使用lua语言写脚本可以保证原子性（上面查询redis中的锁和释放锁不是一起进行的，仍然会有线程安全问题，应该保证查询和释放一起进行），Lua本身不具备原子性，而是因为redis执行命令是单线程的，会<strong>把lua脚本做为一个命令执行</strong></p><p>1.<strong>无参脚本</strong></p><p>可以在redis中直接写</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval <span class="string">&quot;return redis.call(&#x27;命令/例如get&#x27;, &#x27;name&#x27; ,&#x27;ldy&#x27;)&quot;</span><span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数解释</p><p>eval: redis中执行lua脚本的命令</p><p>return: 返回结果</p><p>redis.call(‘命令’， ‘key值’， ‘value值’) 参数个数 （参数…)</p><p>2.<strong>有参脚本</strong></p><p>这里KEYSP和ARGV数组（必须大写）用于接收后面的参数</p><p><strong>注意</strong>， 索引是从1开始的</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; eval <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> <span class="number">1</span> name hei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;hei&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编写释放锁脚本"><a href="#编写释放锁脚本" class="headerlink" title="编写释放锁脚本"></a>编写释放锁脚本</h3><p>无参，写死了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;lock:order:5&quot;</span></span><br><span class="line"><span class="comment">-- 当前线程标识</span></span><br><span class="line"><span class="keyword">local</span> threadid = <span class="string">&quot;faefjeapff-33&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 获取锁中的线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, key)</span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(id == threadid) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>传参，通过外部传参给KEYS和ARGV</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取锁中的线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(id == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更简写的方式</span></span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="java调用lua脚本"><a href="#java调用lua脚本" class="headerlink" title="java调用lua脚本"></a>java调用lua脚本</h3><p>1.下载插件<strong>EmmyLua</strong></p><p><img src="/../images/image-20250312161100974.png" alt="image-20250312161100974"></p><p>2.编写lua脚本</p><p><img src="/../images/image-20250312161135922.png" alt="image-20250312161135922"></p><p><img src="/../images/image-20250312161229537.png" alt="image-20250312161229537"></p><p>3.调用lua脚本</p><p><strong>tip</strong>, ctrl + h 查看类的继承&#x2F;实现关系，可以看到，我这里按了ctrl+h后，显示了RedisScript类的继承类，直接使用实现类。</p><p><img src="/../images/image-20250312161713668.png" alt="image-20250312161713668"></p><p>执行lua脚本由<strong>RedisTemplate</strong>的<strong>execute</strong>方法实现</p><p>实战代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> &#123;</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//uuid用于区分进程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">keyPrefix</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"><span class="comment">//这里把脚本当作定值预先加载了，避免每次获取锁都要重新读取脚本内容而浪费时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">//new ClassPathResource()即获取resource目录下的文件信息</span></span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long expireSecond)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线程id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(keyPrefix + name, uuid+id, expireSecond, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//防止b是null时拆箱出错</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*使用lua脚本</span></span><br><span class="line"><span class="comment">        Collections用于把一个对象转化为一个集合， 因为这里要求keys是一个集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(keyPrefix + name),</span><br><span class="line">                uuid + Thread.currentThread().getId()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-秒杀优化"><a href="#7-秒杀优化" class="headerlink" title="7.秒杀优化"></a>7.秒杀优化</h2><p>之前的秒杀机制大部分操作都直接会用到数据库，在性能方面比较差。</p><p><img src="/../images/image-20250313202012520.png" alt="image-20250313202012520"></p><p>优化思路：</p><ol><li>新增秒杀券的同时，将优惠券信息保存到Redis中。</li><li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功。</li><li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列。</li><li>开启线程任务，不断从阻塞队列中获取数据，实现异步下单。</li></ol><p>1.基于redis进行库存和一人一单校验</p><p><img src="/../images/image-20250313202241375.png" alt="image-20250313202241375"></p><p>库存：秒杀优惠券在新增时就将库存加入redis中。</p><p>一人一单：使用set类型存储对应优惠券订单的用户。使用<strong>sismember</strong>命令判断用户id是否已存在于set集合中。</p><p>编写lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--获取用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--获取优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 获取库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&quot;seckill:stock:&quot;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 获取订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&quot;seckill:order:&quot;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.判断库存呢是否充足</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 库存不足返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.判断是否已经下单</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 已下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.将当前userId存入优惠券set集合</span></span><br><span class="line">redis.call(<span class="string">&quot;sadd&quot;</span>, orderKey, userId)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>重写seckillVoucher方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            UserHolder.getUser().getId().toString(),</span><br><span class="line">            voucherId.toString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(execute != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1不为0返回异常信息</span></span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足!&quot;</span>) : Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.创建订单,异步下单</span></span><br><span class="line">    <span class="comment">//3.1 获取订单id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(SECKILL_ORDER_KEY);</span><br><span class="line">    <span class="comment">//3.2将用户id, 优惠券id和 订单id存入阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用消息队列异步创建订单</p><p>使用java自带的阻塞队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;VoucherOrder&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在类初始化完成后就开启子线程实时获取阻塞队列中的元素</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">VoucherHanler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherHanler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取订单，阻塞队列没有元素则会一直阻塞等待</span></span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">            <span class="comment">//2.创建订单</span></span><br><span class="line">            handleVoucherOrder(order);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户、优惠券id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//2.获取锁对象</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//3.获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="comment">//4.判断锁是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        <span class="comment">//获取锁失败，输出日志</span></span><br><span class="line">        log.error(<span class="string">&quot;发送异常，没获取到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        proxy.createVoucherOrder(order);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理对象才能开启事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户已经下过单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子线程不能创建代理对象，所以该由主线程创建并赋值给全局代理对象供子线程使用</span></span><br><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        userId.toString(),</span><br><span class="line">        voucherId.toString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(execute != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1不为0返回异常信息</span></span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足!&quot;</span>) : Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.创建订单,异步下单</span></span><br><span class="line">    <span class="comment">//3.1 获取订单id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(SECKILL_ORDER_KEY);</span><br><span class="line">    <span class="comment">//3.2将用户id, 优惠券id和 订单id存入阻塞队列</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    blockingQueue.add(order);</span><br><span class="line">    <span class="comment">//3.3返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-消息队列"><a href="#8-消息队列" class="headerlink" title="8.消息队列"></a>8.消息队列</h2><h3 id="Redis实现消息队列"><a href="#Redis实现消息队列" class="headerlink" title="Redis实现消息队列"></a>Redis实现消息队列</h3><p><img src="/../images/image-20250314175932374.png" alt="image-20250314175932374"></p><h4 id="1-基于List实现"><a href="#1-基于List实现" class="headerlink" title="1.基于List实现"></a>1.基于List实现</h4><h4 id="2-基于PubSub实现"><a href="#2-基于PubSub实现" class="headerlink" title="2.基于PubSub实现"></a>2.基于PubSub实现</h4><h4 id="3-基于stream实现"><a href="#3-基于stream实现" class="headerlink" title="3.基于stream实现"></a>3.基于stream实现</h4><p><strong>单消费者</strong></p><p>XADD </p><p>XREAD</p><p><strong>消费者组</strong></p><h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMq</title>
      <link href="/2025/02/26/RabbitMq/"/>
      <url>/2025/02/26/RabbitMq/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMq消息队列"><a href="#RabbitMq消息队列" class="headerlink" title="RabbitMq消息队列"></a>RabbitMq消息队列</h1><p>总结参考黑马教程<a href="https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc">day06-MQ基础 - 飞书云文档</a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：</p><p><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><h3 id="使用背景："><a href="#使用背景：" class="headerlink" title="使用背景："></a>使用背景：</h3><h4 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h4><p>在微服务项目中，我们使用的OpenFeign都是<strong>同步调用</strong>，可以理解为阻塞，只有当前任务执行完毕才能往下执行，同步调用存在以下问题：</p><p><strong>第一</strong>，<strong>拓展性差</strong></p><p>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？</p><p>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？</p><p><img src="/../images/image-20250226170410101.png" alt="image-20250226170410101"></p><p>由此可见，服务会越来越臃肿。</p><p><strong>第二</strong>，<strong>性能下降</strong></p><p>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和。</p><p><img src="/../images/image-20250226170342094.png" alt="image-20250226170342094"></p><p><strong>第三，级联失败</strong></p><p>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</p><p>这其实就是同步调用的<strong>级联失败</strong>问题。</p><p>比方说一个订单支付业务，用户支付成功后还会获得积分，但积分服务出现了问题，导致整个事务回滚，用户的钱又退回去了，这怎么行呢，毕竟拿来的钱哪有还回去的道理。因此，不能因为个别业务问题而导致整个事务的回滚。</p><h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>至于如何解决上述问题，这就用到了消息队列的异步调用了。</p><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者(Publisher)：投递消息的人，就是原来的调用方</li><li>消息Broker(Exchange、Queue)：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者(Consumer)：接收和处理消息的人，就是原来的服务提供方</li></ul><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p><img src="/../images/image-20250226171254619.png" alt="image-20250226171254619"></p><p>这样，发送消息的人和接收消息的人就完全解耦了。发送消息的人只需要发消息，至于接收者怎么接收、是否接收成功都与发送者无关了。</p><p>通过消息队列，可以改变服务的架构，如下支付业务所示</p><p><img src="/../images/image-20250226171542545.png" alt="image-20250226171542545"></p><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>并且不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，<strong>解除了耦合</strong>，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li><strong>耦合度更低</strong></li><li><strong>性能更好</strong></li><li><strong>业务拓展性强</strong></li><li><strong>故障隔离，避免级联失败</strong></li></ul><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h2><h3 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1.基础用法"></a>1.基础用法</h3><p> 1.<strong>安装</strong></p><p>基于Docker来安装RabbitMQ，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \  </span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \   </span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hm-net\</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>安装完成后，我们访问 <a href="http://192.168.10.101:15672（注意根据自己的虚拟机访问ip调整）即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。">http://192.168.10.101:15672（注意根据自己的虚拟机访问ip调整）即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</a></p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p>RabbitMq的基本架构如图所示。</p><p><img src="/../images/image-20250226172318386.png" alt="image-20250226172318386"></p><p>其中包含几个概念：</p><ul><li>**<code>publisher</code>**：生产者，也就是发送消息的一方</li><li>**<code>consumer</code>**：消费者，也就是消费消息的一方</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>RabbitMQ管理控制台看黑马教程<a href="https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc">day06-MQ基础 - 飞书云文档</a></p><p>交换机exchange根据routekey路由消息到指定的队列queue。</p><p><img src="/../images/direct.png" alt="direct"></p><h3 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h3><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。</p><p>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：<strong>SpringAMQP</strong>。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：</p><p><a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系 (在配置类中使用@Bean声明或者在监听器注解@RabbitListener中声明)</li><li>基于注解的监听器模式，异步接收消息  (使用@RabbitListerner注解)</li><li>封装了RabbitTemplate工具，用于发送消息 (使用时直接注入即可)</li></ul><p>队列、交换机、绑定关系的声明方法有两种，如下所示</p><p>1.基于配置类，以Direct交换机为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;direct.queue&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueToDirect1</span><span class="params">(DirectExchange directExchange, Queue directQueue )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.基于监听器注解@RabbitListener的bindings属性</p><p><img src="/../images/image-20250226173122373.png" alt="image-20250226173122373"></p><h2 id="3-WorkQueue（工作队列）"><a href="#3-WorkQueue（工作队列）" class="headerlink" title="3.WorkQueue（工作队列）"></a>3.WorkQueue（工作队列）</h2><p>简单来说就是多个消费者绑定到一个队列，共同消费队列里的消息。</p><ul><li><strong>默认情况下</strong>，消息是<strong>轮询（Round-Robin）</strong>分配给各个消费者的。也就是说，消息会依次分配给每个消费者，而不是提前平均分配。每个消费者依次从队列中获取消息进行处理。</li><li><strong>能者多劳</strong>：在某些情况下，你可能希望消费者根据自己的处理能力来消费消息，而不是简单地轮询分配。这时可以通过配置来实现“能者多劳”的效果。在 RabbitMQ 中，可以通过设置 <code>prefetch</code> 参数来控制每个消费者一次最多可以获取多少条消息。如果某个消费者处理速度较快，它可以更快地处理完当前的消息并获取新的消息，从而实现“能者多劳”的效果。配置消息如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>总结</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="4-交换机"><a href="#4-交换机" class="headerlink" title="4.交换机"></a>4.交换机</h2><p>交换机的作用：</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列中</li></ul><p><strong>注意</strong>，交换机不能存储消息，若路由失败，则消息丢失</p><h4 id="1-Fanout交换机"><a href="#1-Fanout交换机" class="headerlink" title="1.Fanout交换机"></a>1.Fanout交换机</h4><p>作用：<strong>广播</strong>，将消息路由给所有与该交换机绑定的队列中。</p><p><img src="/../images/fanout.png" alt="fanout"></p><h4 id="2-Direct交换机"><a href="#2-Direct交换机" class="headerlink" title="2.Direct交换机"></a>2.Direct交换机</h4><p>作用：<strong>定向</strong>，根据消息的RoutingKey判断路由给哪个（些）队列。</p><p>消息发送时需指定<strong>routingkey（路由key）</strong>。direct交换机会将信息路由到具有相同的路由key的队列中。一个队列可以设置多个路由key，每个队列路由key可以相同，若相同则接收时都会接收到消息。</p><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li><p>Fanout交换机将消息路由给每一个与之绑定的队列</p></li><li><p>Direct交换机根据RoutingKey判断路由给哪个队列</p></li><li><p>如果多个队列具有相同的RoutingKey,则效果和Fanout类似</p><p><img src="/../images/direct-17405632704672.png" alt="direct"></p></li></ul><h4 id="3-Topic交换机"><a href="#3-Topic交换机" class="headerlink" title="3.Topic交换机"></a>3.Topic交换机</h4><p>作用:<strong>加强版定向</strong>，可以让队列在绑定routingkey时使用通配符。</p><p>通配符规则：</p><ul><li><code>#</code>：匹配0个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p><ul><li><code>china.news </code>代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>那么：</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Direct交换机是路由完全匹配规则，Topic交换机则是模式匹配（支持通配符）</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="消息队列高级篇"><a href="#消息队列高级篇" class="headerlink" title="消息队列高级篇"></a>消息队列高级篇</h2><h3 id="1-发送者可靠性"><a href="#1-发送者可靠性" class="headerlink" title="1.发送者可靠性"></a>1.发送者可靠性</h3><p>1.生产者重试机制</p><p>2生产者确认机制</p><h3 id="2-MQ的可靠性"><a href="#2-MQ的可靠性" class="headerlink" title="2.MQ的可靠性"></a>2.MQ的可靠性</h3><p>1.数据持久化</p><p>2.Lazy-Queue惰性队列</p><h3 id="3-消费者可靠性"><a href="#3-消费者可靠性" class="headerlink" title="3.消费者可靠性"></a>3.消费者可靠性</h3><p>1.消费者确认机制</p><p>2.失败重试机制</p><p>3.失败处理策略</p><p>消息处理失败后重新投递到处理消息失败的交换机当中，专门处理</p><p>4.业务幂等</p><p>解决消息重复处理问题</p><h3 id="3-延迟消息"><a href="#3-延迟消息" class="headerlink" title="3.延迟消息"></a>3.延迟消息</h3><h4 id="1-死信交换机和延迟消息"><a href="#1-死信交换机和延迟消息" class="headerlink" title="1.死信交换机和延迟消息"></a>1.死信交换机和延迟消息</h4><p>1.死信交换机</p><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>通过给队列添加<code>dead-letter-exchange</code>属性指定的交换机就是死信交换机。当该队列的消息成为死信后，即会把消息投递到这个指定的交换机当中。死信交换机配置如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;dlx.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;normal.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxqueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;dlx.queue&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;normal.queue&quot;</span>).deadLetterExchange(<span class="string">&quot;dlx.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">dlxBinding</span><span class="params">(Queue dlxqueue, DirectExchange dlxExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxqueue).to(dlxExchange).with(<span class="string">&quot;dlx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">normalBinding</span><span class="params">(Queue normalQueue, DirectExchange normalExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(<span class="string">&quot;dlx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250226185117798.png" alt="image-20250226185117798"></p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><p>2.延迟消息</p><p>延迟消息是在publisher发送消息到交换机时给消息设置有效期expiration。则当正常队列里的消息没有被消费且过期时，会投递到死信交换机当中。使用场景比如订单限时支付，订单创建时就把消息（附带上过期时间）投递给正常交换机，同时不给正常队列设置消费者，到达过期时间则会投递到死信交换机，交给删除订单的listener处理。</p><h4 id="2-DelayExchange插件"><a href="#2-DelayExchange插件" class="headerlink" title="2.DelayExchange插件"></a>2.DelayExchange插件</h4><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。</p><p>官方文档说明：</p><p><a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p><p>插件下载地址：</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-06-19T09:22:59+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/mq-plugins/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mq-plugins&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。若不是，则根据自己定义的挂载目录上传。</p><p>接下来进入插件目录后执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>1.声明延迟交换机</p><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.发送延迟消息</p><p>发送消息时，必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rabbitmq 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习</title>
      <link href="/2025/02/14/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/02/14/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>内容参考黑马文档<a href="https://b11et3un53m.feishu.cn/wiki/MWQIw4Zvhil0I5ktPHwcoqZdnec">day02-Docker - 飞书云文档</a></p><h2 id="镜像定义"><a href="#镜像定义" class="headerlink" title="镜像定义"></a>镜像定义</h2><p>什么是镜像：将应用所需的函数库、依赖、配置等与应用一起打包得到的就是镜像。</p><p>简单来说类似于网上下的学习版游戏压缩包。</p><p>以下是镜像查询命令显示的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server01 tar]# docker images</span><br><span class="line">REPOSITORY                     TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.1ms.run/library/nginx   latest    97662d24417b   7 days ago    192MB</span><br><span class="line">docker.1ms.run/library/mysql   latest    c013d3763e14   3 weeks ago   797MB</span><br></pre></td></tr></table></figure><p>参数解释：</p><ol><li><strong><code>REPOSITORY</code>（仓库）</strong>：<ul><li>镜像的仓库名称，类似于软件包的来源。</li><li>例如：<ul><li><code>docker.1ms.run/library/nginx</code>：表示从<code>docker.1ms.run</code>镜像源拉取的<code>nginx</code>镜像。</li><li><code>nginx</code>：如果直接写<code>nginx</code>，则默认从Docker Hub官方仓库(可以修改镜像源)拉取。</li></ul></li><li>仓库名称可以包含镜像源的地址（如<code>docker.1ms.run/library</code>），也可以是简单的镜像名（如<code>nginx</code>）。</li></ul></li><li><strong><code>TAG</code>（标签）</strong>：<ul><li>镜像的版本标识符。</li><li>例如：<ul><li><code>latest</code>：表示最新版本。</li><li><code>5.7</code>、<code>8.0</code>：表示特定版本的镜像。</li></ul></li><li>如果不指定标签，默认为<code>latest</code>。</li></ul></li><li><strong><code>IMAGE ID</code>（镜像ID）</strong>：<ul><li>镜像的唯一标识符，是一个64位的哈希值。</li><li>每个镜像都有一个唯一的<code>IMAGE ID</code>，即使仓库和标签相同，<code>IMAGE ID</code>也可能不同，因为不同镜像源分层结构或配置可能不同。</li><li>示例：<code>97662d24417b</code>。</li></ul></li><li><strong><code>CREATED</code>（创建时间）</strong>：<ul><li>镜像的创建时间，表示该镜像从源仓库拉取或构建的时间。</li><li>示例：<code>7 days ago</code>表示镜像创建于7天前。</li></ul></li><li><strong><code>SIZE</code>（大小）</strong>：<ul><li>镜像的大小，表示镜像占用的磁盘空间。</li><li>示例：<code>192MB</code>表示<code>nginx</code>镜像大小为192MB，<code>797MB</code>表示<code>mysql</code>镜像大小为797MB。</li></ul></li></ol><h2 id="容器定义"><a href="#容器定义" class="headerlink" title="容器定义"></a>容器定义</h2><p>Docker会在运行镜像时创建一个隔离环境，称为容器（container）。</p><p>容器类似于学习版游戏解压后的文件，可以通过这个文件来进行运行游戏（实现所需功能），可以解压多个，每个解压后的文件互不干扰。</p><p>使用<code>docker run</code>命令即可创建容器，具体参数及解释在下面的常用命令里面。</p><p><strong>特点</strong>：</p><ul><li><strong>可运行</strong>：容器是镜像的运行实例，可以启动、停止、重启、删除等。</li><li><strong>隔离性</strong>：容器之间相互隔离，互不影响，即使多个容器运行在同一台宿主机上。</li><li><strong>临时性</strong>：容器的生命周期是临时的，删除容器后，其运行状态和数据会被清除（除非配置了数据卷）。</li><li><strong>轻量级</strong>：容器共享宿主机的内核，启动速度非常快（通常在秒级）。</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1-镜像操作"><a href="#1-镜像操作" class="headerlink" title="1. 镜像操作"></a>1. <strong>镜像操作</strong></h3><p><code>docker images</code> </p><p>查看本地已有的镜像，image翻译过来是镜像</p><p><code>docker pull</code></p><p>拉取镜像到本地，例如<code>docker pull mysql:8.0</code>,不带<code>:版本号</code>则拉取最新版本。若镜像源有问题，可以手动设置镜像源，例如<code>docker pull docker.1ms.run/library/mysql</code>，其中的docker.1ms.run就是目前可用的国内镜像源，也可以把镜像源修改到仓库，这样子docker pull优先访问设置的镜像源。</p><p><code>docker push</code></p><p>将本地镜像推送到镜像仓库</p><p><code>docker save</code></p><p>将镜像导出为一个tar文件，例如<code>docker save -o nginx.tar nginx:latest</code>。</p><p><code>docker load</code></p><p>加载导出的tar文件为镜像，例如<code>docker load -i nginx.tar</code></p><p><code>docker rmi</code></p><p>删除本地镜像，例如<code>docker rmi mysql:latest</code></p><h3 id="2-容器操作"><a href="#2-容器操作" class="headerlink" title="2.容器操作"></a>2.容器操作</h3><p><code>docker run</code> </p><p><strong>创建并运行</strong>容器，若容器不存在则会自动从镜像仓库pull到本地来，但因为自动是从官方地址pull，会很慢甚至出问题，所以需要换源，网上搜最新镜像源即可，我之前换了还是报错是因为cv下来的文件内容的数组最后多了一个逗号。。。。。</p><p>例如快速安装mysql</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以将<strong>宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ``=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><p><code>docker start</code> 启动本地容器，注意区分<code>docker run</code>，<code>docker run</code>每次执行都会创建一个新的容器。</p><p>启动已停止的容器</p><p><code>docker stop</code></p><p>停止正在运行的容器</p><p><code>docker ps</code></p><p>查看正在运行的容器。加上<code>-a</code>参数可以查看所有容器</p><p><code>docker logs</code></p><p>查看容器的运行日志</p><p><code>docker exec</code></p><p>进入正在运行的容器，例如<code>docker exec -it [container] bash</code>。这条命令会进入到容器的命令行，类似又一个linux系统，可以看到相关的文件。</p><h3 id="3-其他操作"><a href="#3-其他操作" class="headerlink" title="3.其他操作"></a>3.其他操作</h3><ul><li>**<code>docker inspect</code>**：查看容器或镜像的详细信息。</li><li>**<code>docker rm</code>**：删除容器。</li><li>**<code>docker restart</code>**：重新启动容器。</li></ul><p><strong>注意</strong>：具体需要什么参数可以使用 –help进行查阅，例如 <code>docker save --help</code> 可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 解释： [OPTIONS]表示可选项，可选项使用规则如下方解释；IMAGE [IMAGE...] 表示一个或多个镜像名称</span><br><span class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...] </span><br><span class="line"></span><br><span class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line"></span><br><span class="line">Aliases: //命令的别名</span><br><span class="line">  docker image save, docker save</span><br><span class="line"></span><br><span class="line">Options: // 可选项</span><br><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span><br><span class="line">//这段话表示指定tar文件存放路径，&#x27;-o&#x27;是‘--output’的缩写，string代表文件路径，使用规则是&#x27;-o 文件地址/文件名.tar&#x27;  </span><br><span class="line">//如果保存到当前目录，可以直接写文件名，如 -o my-image.tar。</span><br><span class="line">//如果保存到其他路径，可以写完整路径，如 -o /path/to/my-image.tar。</span><br></pre></td></tr></table></figure><h3 id="4-命令别名设置"><a href="#4-命令别名设置" class="headerlink" title="4.命令别名设置"></a>4.命令别名设置</h3><p>在路径为<code>/root/.bashrc</code>的文件里面可以设置命令的别名，方便在命令行调用常用命令。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27; //设置容器进程以规定格式查看的快捷命令，这里规定的格式比默认的格式更加清爽</span><br><span class="line">alias dis=&#x27;docker images&#x27; //查看所有镜像</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。大家思考几个问题：</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul><h3 id="1-什么是数据卷"><a href="#1-什么是数据卷" class="headerlink" title="1.什么是数据卷"></a>1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机</strong>目录之间映射的桥梁。</p><p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。</p><p>以挂载本地目录为例</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%8D%B7-%E5%AE%BF%E4%B8%BB%E4%B8%8E%E5%AE%B9%E5%99%A8.drawio.png" alt="数据卷-宿主与容器.drawio"></p><p>如上图所示，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机自定义的本地的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。</p><p>此时，我们操作宿主机的<code>/root/nginx/nginx.conf</code>就是在操作容器内的<code>/etc/nginx/nginx.conf</code>目录。</p><h3 id="2-数据卷的常见命令"><a href="#2-数据卷的常见命令" class="headerlink" title="2.数据卷的常见命令"></a>2.数据卷的常见命令</h3><table><thead><tr><th>docker volume create</th><th>创建数据卷</th></tr></thead><tbody><tr><td>docker volume ls</td><td>查看所有数据卷</td></tr><tr><td>docker volume rm</td><td>删除指定数据卷</td></tr><tr><td>docker volume inspect</td><td>查看某个数据卷的详情</td></tr><tr><td>docker volume prune</td><td>清除数据卷</td></tr></tbody></table><p>注意docker volume ls只能查到<code>/var/lib/docker/volumes</code>目录下的数据卷。</p><h3 id="3-如何挂载数据卷"><a href="#3-如何挂载数据卷" class="headerlink" title="3.如何挂载数据卷"></a>3.如何挂载数据卷</h3><p><strong>注意</strong>：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h4 id="1-默认挂载位置"><a href="#1-默认挂载位置" class="headerlink" title="1.默认挂载位置"></a>1.默认挂载位置</h4><p>具体演示（摘自黑马文档）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><p>如上述案例，在docker run命令中加入了 <code>-v html:/usr/share/nginx/html</code>,此时对应的宿主机为<code>/var/lib/docker/volumes/html/_data</code>。</p><p>因为命令中的宿主机存放目录没有 <code>./</code> 或者 <code>/</code>为开头，则会将其认定为数据卷名，文件默认在<code>/var/lib/docker/volumes/</code>下创建<code>数据卷名/_data</code>目录，里面存放具体对应的数据。</p><h4 id="2-挂载本地目录"><a href="#2-挂载本地目录" class="headerlink" title="2.挂载本地目录"></a>2.挂载本地目录</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><p>具体演示（摘自黑马文档）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.删除原来的MySQL容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行新mysql容器，挂载本地目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span></span><br><span class="line"><span class="built_in">ls</span> -l mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">总用量 4</span><br><span class="line">drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf</span><br><span class="line">drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data</span><br><span class="line">drwxr-xr-x. 2 root    root   23 5月  19 15:11 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span></span><br><span class="line"><span class="built_in">ls</span> -l data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查看MySQL容器内数据</span></span><br><span class="line"><span class="comment"># 5.1.进入MySQL</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123</span><br><span class="line"><span class="comment"># 5.2.查看编码表</span></span><br><span class="line">show variables like <span class="string">&quot;%char%&quot;</span>;</span><br><span class="line"><span class="comment"># 5.3.结果，发现编码是utf8mb4没有问题</span></span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| Variable_name            | Value                          |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                        |</span><br><span class="line">| character_set_connection | utf8mb4                        |</span><br><span class="line">| character_set_database   | utf8mb4                        |</span><br><span class="line">| character_set_filesystem | binary                         |</span><br><span class="line">| character_set_results    | utf8mb4                        |</span><br><span class="line">| character_set_server     | utf8mb4                        |</span><br><span class="line">| character_set_system     | utf8mb3                        |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看数据</span></span><br><span class="line"><span class="comment"># 6.1.查看数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="comment"># 结果，hmall是黑马商城数据库</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| hmall              |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment"># 6.2.切换到hmall数据库</span></span><br><span class="line">use hmall;</span><br><span class="line"><span class="comment"># 6.3.查看表</span></span><br><span class="line">show tables;</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_hmall |</span><br><span class="line">+-----------------+</span><br><span class="line">| address         |</span><br><span class="line">| cart            |</span><br><span class="line">| item            |</span><br><span class="line">| order           |</span><br><span class="line">| order_detail    |</span><br><span class="line">| order_logistics |</span><br><span class="line">| pay_order       |</span><br><span class="line">| user            |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="comment"># 6.4.查看address表数据</span></span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| <span class="built_in">id</span> | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  |</span><br><span class="line">| 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  |</span><br><span class="line">| 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  |</span><br><span class="line">| 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><strong>全部摘自黑马文档，太详细了</strong></p><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢？</p><h3 id="1-镜像结构"><a href="#1-镜像结构" class="headerlink" title="1.镜像结构"></a>1.镜像结构</h3><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MTFmMDUyMzUyNTAxNGUxODgzYjAwMWE0ZTQ5NWUyZWRfUzV2WU5BM3VvYXpRM3hWQUR6bDhMemdjTW94S2lKQ25fVG9rZW46SE1Fa2JYTVJ5b1ZDWTl4azdLZWMzUXF1bk9kXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA" alt="img"></p><h3 id="2-Dockerfile"><a href="#2-Dockerfile" class="headerlink" title="2.Dockerfile"></a>2.Dockerfile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>同学们思考一下：以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>是不是简单多了。</p><h3 id="3-构建镜像"><a href="#3-构建镜像" class="headerlink" title="3.构建镜像"></a>3.构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。</p><p>在课前资料中，我们准备好了一个demo项目及对应的Dockerfile：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MjhiYWJlODdhZDhiOWVjNzVmNzI2NWQ0NzRjZWJlMzBfZGVIeXIzTEljRHVaYVkxSDNtNTQ2dHN1VXdreW8wU1hfVG9rZW46SWFYWGJSeXJ1b2ZzeXF4a1h5M2N1SkJpbnVmXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA" alt="img"></p><p>首先，我们将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YWVhN2E1YWI1MmY2ZTJkMGU2MDVkY2EzNDJjOGJkNzNfdE1iQmNtVUVMMTd2d1ZGMjhZMWZ2a1gxSGRuZFRWcTJfVG9rZW46RGFOeGJ3Tjg0bzdtRWx4N3A0OGNRU1NTbnJlXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA" alt="img"></p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<ul><li><pre><code class="Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">![img](https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MTdhZWY2ZjI3OTAxMDcwNmZjNGYwNDRmM2M3ZDQzNmZfUDUxZG5lTGlNYTlsQmV5THNUbjdkUXhNdTdVeGJRem1fVG9rZW46R0RqMmJzeDFzb0Q0eXV4N3hLWmNXcHoxbmhlXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA)</span><br><span class="line"></span><br><span class="line">查看镜像列表：</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line"># 查看镜像列表：</span><br><span class="line">docker images</span><br><span class="line"># 结果</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">docker-demo   1.0       d6ab0b9e64b9   27 minutes ago   327MB</span><br><span class="line">nginx         latest    605c77e624dd   16 months ago    141MB</span><br><span class="line">mysql         latest    3218b38490ce   17 months ago    516MB</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>然后尝试运行该镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run -d --name <span class="built_in">dd</span> -p 8080:8080 docker-demo:1.0</span><br><span class="line"><span class="comment"># 2.查看容器</span></span><br><span class="line">dps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES</span><br><span class="line">78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   <span class="built_in">dd</span></span><br><span class="line">f63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.访问</span></span><br><span class="line">curl localhost:8080/hello/count</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>在docker中，不同容器之间可以互相访问，前提是<strong>加入到同一个网络</strong>中。</p><p>容器在<code>docker run</code>时若没有指定网络，则会默认加入到一个固定的网络中，每次容器启动时，该网络都会分配给容器一个ip。因为该网络无法通过容器名访问，必须通过该网络分配给容器的ip地址进行访问，而容器ip是动态变化的，所以当我们写死项目访问其他中间件的ip时肯定会出问题。而在<strong>自定义网络</strong>中，则可以<strong>通过容器名或别名访问到该容器，无需指定ip地址</strong>。</p><p>在java项目中，往往需要访问其它各种中间件，例如MySQL、Redis等,那么容器之间是否可以相互访问呢？</p><p>首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.用基本命令，寻找Networks.bridge.IPAddress属性</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 也可以使用format过滤结果</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mysql</span><br><span class="line"><span class="comment"># 得到IP地址如下：</span></span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后通过命令进入dd容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在容器内，通过ping命令测试网络</span></span><br><span class="line">ping 172.17.0.2</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms</span><br></pre></td></tr></table></figure><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定（即每次启动容器时，其ip都会发生变化），如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><p>教学演示：自定义网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><p>OK，现在无需记住IP地址也可以实现容器互联了。</p><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h3 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1.基本语法"></a>3.3.1.基本语法</h3><p>docker-compose.yml文件的基本语法可以参考官方文档：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span> <span class="string">//实际指的网络名是hmall</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span> <span class="string">//代称，虽然上面指定的网络是new，但创建出来后其实是下面的hmall</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span> <span class="string">//实际自定义的网络名</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p><p>黑马商城部署文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p><p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><p>教学演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network hmall    Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container hmall  Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE</span><br><span class="line">hmall               root-hmall          latest              32eebee16acd        362MB</span><br><span class="line">mysql               mysql               latest              3218b38490ce        516MB</span><br><span class="line">nginx               nginx               latest              605c77e624dd        141MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS</span><br><span class="line">hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp</span><br><span class="line">mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2025/02/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2025/02/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>指的是把内存中的数据写入磁盘中。因为redis是基于内存进行数据存储的，当服务器关闭或者重启时，内存中的数据会丢失，所以需要通过持久化机制，来把数据定期自动或者按需手动保存到磁盘中，以便服务器启动时恢复数据。<br>实现方法分为如下两种</p><h3 id="1-RDB-Redis-DataBase"><a href="#1-RDB-Redis-DataBase" class="headerlink" title="1.RDB(Redis DataBase)"></a>1.RDB(Redis DataBase)</h3><p>是什么：在指定的时间间隔内，执行数据集的时间点快照，快照文件就是RDB文件（例如dump.rdb）。当Redis重启时，会加载这个<code>.rdb</code>文件，直接将文件中的数据加载到内存中。</p><h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><p>位于redis.conf配置文件的snapshot模块中</p><ol><li><code>save  &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]</code>  大概位于第440行<br>用于配置使时间间隔和数据修改次数，及每个一段固定时间查看当前redis修改数据的次数，超过了设定的i修改次数则进行快照。</li><li><code>dir 文件位置</code>(例如 &#x2F;root&#x2F;myredis&#x2F;dumpfiles) 大概位于第510行<br>用于设置rdb文件存放的位置</li><li><code>dbfilename 文件名</code>（例如dump6379.rdb） 大概位于第487行<br>用于设置rdb文件的名字</li><li>stop-writes-on-bgsave-error</li><li>rdbcompression</li><li>rdbchecksum</li><li>rdb-del-sync-files</li></ol><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>1.配置文件中的默认快照</p><p>根据配置文件中的save进行自动快照操作。</p><p>2.主从复制</p><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><h5 id="1-save"><a href="#1-save" class="headerlink" title="1.save"></a>1.save</h5><ul><li><strong>功能</strong>：<code>SAVE</code> 命令用于在主线程中同步生成 RDB 文件，将当前 Redis 数据库的数据快照保存到磁盘上。</li><li><strong>执行过程</strong>：执行 <code>SAVE</code> 命令时，Redis 会阻塞主线程，直到 RDB 文件创建完成。在此期间，Redis 无法处理其他客户端的任何请求。</li><li><strong>适用场景</strong>：由于其阻塞特性，<code>SAVE</code> 命令通常不适用于生产环境，尤其是在数据量较大时，可能会导致长时间的阻塞。</li></ul><h5 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2.bgsave"></a>2.bgsave</h5><ul><li><strong>功能</strong>：<code>BGSAVE</code> 命令用于异步生成 RDB 文件。它通过创建一个子进程来执行数据快照操作，而主线程继续处理客户端请求。</li><li><strong>执行过程</strong>：<ul><li>主进程调用 <code>fork()</code> 创建一个子进程。</li><li>子进程负责将内存中的数据写入到磁盘上的临时文件中。</li><li>写入完成后，子进程会用新生成的临时文件替换旧的 RDB 文件。</li><li>主进程在整个过程中几乎不受影响，只有在 <code>fork()</code> 阶段会有短暂的阻塞。</li></ul></li><li><strong>适用场景</strong>：<code>BGSAVE</code> 是推荐的持久化命令，尤其适用于生产环境。它可以在不影响 Redis 正常服务的情况下，完成数据的持久化操作。</li></ul><h5 id="3-特殊命令"><a href="#3-特殊命令" class="headerlink" title="3.特殊命令"></a>3.特殊命令</h5><ul><li>执行flushall&#x2F;flushdb命令也会产生dump.rdb文件，但里面是空的，无意义。</li><li>执行shutdown且没有设置开启AOF持久化也会产生dump.rdb文件。</li></ul><h3 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2.AOF(Append Only File)"></a>2.AOF(Append Only File)</h3><p>是什么：AOF是Redis的一种持久化机制，它通过将Redis执行的写操作命令以追加的方式记录到一个日志文件（通常是<code>appendonly.aof</code>）中来实现数据的持久化。在Redis重启时，会加载AOF文件，重新执行其中记录的命令，从而恢复数据。</p><h4 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h4><p>位于redis.conf配置文件的append only模块中</p><ol><li><p><code>appendonly yes/no</code></p><p>用于设置是否启用AOF,默认只启用RDB，不启用AOF。</p></li><li><p><code>dir 文件位置</code></p><p>用于指定<code>.aof</code>文件所在目录的存放的位置。</p></li><li><p><code>appenddirname 目录名</code></p><p>用于指定aof文件所在的目录</p><p>区分：</p><ul><li><p>redis7版本开始，.aof文件存放路径等于<code>dir下的文件位置/appenddirname目录名/xxx.aof</code></p></li><li><p>redis6版本时，.aof文件存放位置仅等于<code>dir下的文件位置/xxx.aof</code></p></li></ul></li><li><p><code>appendfilename 文件名</code></p><p>指定.aof的文件名称</p></li></ol><p><img src="/../images/image-20250205002000869.png" alt="image-20250205002000869"></p><h4 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h4><p>AOF的写回策略决定了Redis何时将内存中的命令写入到AOF文件中。Redis提供了三种写回策略，分别通过配置文件中的<code>appendfsync</code>参数来设置：</p><ol><li><strong><code>appendfsync always</code></strong><ul><li><strong>描述</strong>：每次写操作都会立即同步到AOF文件中。</li><li><strong>优点</strong>：数据安全性最高，即使Redis崩溃，也不会丢失任何数据。</li><li><strong>缺点</strong>：性能开销较大，因为每次写操作都会触发一次磁盘同步操作，可能会降低Redis的性能。</li></ul></li><li><strong><code>appendfsync everysec</code></strong><ul><li><strong>描述</strong>：每秒同步一次AOF文件。这是默认的写回策略。</li><li><strong>优点</strong>：在性能和数据安全性之间取得了较好的平衡。即使发生故障，最多只会丢失1秒内的数据。</li><li><strong>缺点</strong>：在极端情况下（如系统崩溃），可能会丢失1秒内的数据。</li></ul></li><li><strong><code>appendfsync no</code></strong><ul><li><strong>描述</strong>：不主动同步AOF文件，由操作系统决定何时同步。</li><li><strong>优点</strong>：性能开销最小，因为Redis不会主动触发磁盘同步操作。</li><li><strong>缺点</strong>：数据安全性最低，如果操作系统崩溃或Redis进程被意外终止，可能会丢失较多数据。</li></ul></li></ol><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>AOF文件会随着Redis的写操作不断增加，文件大小可能会变得很大。为了优化AOF文件的大小，Redis提供了AOF重写机制，通过<strong>生成一个新的AOF文件来替换旧的AOF文件</strong>，从而减小文件大小并提高性能。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li><strong>触发条件</strong>：<ul><li><strong>自动触发</strong>：可以通过配置文件中的<code>auto-aof-rewrite-percentage</code>和<code>auto-aof-rewrite-min-size</code>参数来设置自动触发条件。<ul><li><code>auto-aof-rewrite-percentage</code>：表示AOF文件大小增长的百分比。例如，设置为<code>100</code>，表示当AOF文件大小增长超过100%时，会触发重写。</li><li><code>auto-aof-rewrite-min-size</code>：表示AOF文件的最小大小。例如，设置为<code>64mb</code>，表示只有当AOF文件大小超过64MB时，才会触发重写。</li></ul></li><li><strong>手动触发</strong>：可以通过命令<code>BGREWRITEAOF</code>手动触发AOF重写。</li></ul></li><li><strong>重写过程</strong>：<ul><li>当触发AOF重写时，Redis会启动一个子进程来执行重写操作。</li><li>子进程会读取当前内存中的数据，并生成一个新的AOF文件，该文件<strong>只包含恢复当前数据集所需的最小命令集合</strong>。</li><li>在重写过程中，主进程会继续处理客户端的请求，并将新的写操作命令追加到一个临时缓冲区中。</li><li>当子进程完成重写后，主进程会将临时缓冲区中的命令追加到新的AOF文件中，然后用新的AOF文件替换旧的AOF文件。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>减小文件大小</strong>：通过生成一个新的AOF文件，只保留恢复当前数据集所需的最小命令集合，从而减小文件大小。</li><li><strong>提高性能</strong>：新的AOF文件更紧凑，加载速度更快，同时减少了磁盘空间的占用。</li></ul></li><li><strong>注意事项</strong>：<ul><li>AOF重写不会阻塞主进程，因为重写操作是由子进程完成的，主进程可以继续处理客户端的请求。</li><li>在重写过程中，主进程会将新的写操作命令追加到临时缓冲区中，以确保数据的完整性。</li></ul></li></ol><h3 id="3-RDB-AOF混合持久化"><a href="#3-RDB-AOF混合持久化" class="headerlink" title="3.RDB-AOF混合持久化"></a>3.RDB-AOF混合持久化</h3><h4 id="一、两种持久化方式优先级"><a href="#一、两种持久化方式优先级" class="headerlink" title="一、两种持久化方式优先级"></a><strong>一、两种持久化方式优先级</strong></h4><ul><li>当同时开启RDB和AOF两种持久化方式时，AOF的优先级高于RDB。若AOF文件存在并无损，则只加载AOF文件。</li></ul><h4 id="二、混合持久化开启"><a href="#二、混合持久化开启" class="headerlink" title="二、混合持久化开启"></a><strong>二、混合持久化开启</strong></h4><ol><li><p>​<strong>开启方式</strong></p><p>配置文件append only模块 <code>aof-use-rdb-preamble yes</code></p></li><li><p><strong>混合持久方式的数据执行流程</strong></p><p>（1）Redis启动时，会检查是否存在AOF文件（<code>appendonly.aof</code>）。如果存在且配置了混合持久化（<code>aof-use-rdb-preamble yes</code>），Redis会加载AOF文件。</p><p>（2）检查<strong>AOF文件是否包含RDB快照</strong></p><p>​混合持久化下重写的AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据。</p><ul><li>如果AOF文件中包含RDB快照（即混合持久化模式），Redis会<strong>先加载RDB快照部分</strong>，快速恢复大部分数据。</li><li>然后，Redis会继续加载AOF文件中自RDB快照之后的<strong>增量日志</strong>，依次执行这些日志中的写操作，以恢复到最新的数据状态。</li><li><img src="/../images/image-20250205195353569.png" alt="混合持久化下的aof文件"></li></ul><p>（3）如果AOF文件不存在或损坏</p><ul><li>如果AOF文件不存在或损坏，Redis会尝试加载RDB文件（<code>dump.rdb</code>）。</li><li>如果RDB文件也不存在或损坏，Redis将无法恢复数据，启动时会报错。</li></ul><p>（4）数据恢复完成</p><p>完成上述步骤后，Redis的数据恢复过程结束，服务开始正常运行。</p></li></ol><p><img src="/../images/redis%E6%8C%81%E4%B9%85%E5%8C%96.png" alt="redis持久化"></p><p>混合持久化本质是通过 AOF 后台重写（bgrewriteaof 命令）完成的，不同的是当开启混合持久化时，fork 出的子进程先将当前全量数据以 RDB 方式写入新的 AOF 文件，然后再将 AOF 重写缓冲区（<a href="https://zhida.zhihu.com/search?content_id=163703728&content_type=Article&match_order=1&q=aof_rewrite_buf_blocks&zhida_source=entity">aof_rewrite_buf_blocks</a>）的增量命令以 AOF 方式写入到文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>优点：结合 RDB 和 AOF 的优点, 更快的重写和恢复。</p><p>缺点：AOF 文件里面的 RDB 部分不再是 AOF 格式，可读性差。</p><h2 id="4-纯缓存模式"><a href="#4-纯缓存模式" class="headerlink" title="4.纯缓存模式"></a>4.纯缓存模式</h2><p><strong>定义</strong><br>纯缓存模式是指同时关闭RDB和AOF持久化功能，将Redis仅作为内存缓存使用，不进行任何数据持久化操作。</p><p><strong>1.关闭RDB</strong></p><p><code>save &quot;&quot;</code> 禁用rdb持久化模式下，仍然可以手动执行<code>save</code>、<code>bgsave</code>命令生成rdb文件</p><p><strong>2.关闭AOF</strong></p><p><code>appendonly no</code> 仍然可以手动执行<code>bgrewriteaof</code>生成aof文件</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尚庭公寓</title>
      <link href="/2024/12/26/%E5%B0%9A%E5%BA%AD%E5%85%AC%E5%AF%93/"/>
      <url>/2024/12/26/%E5%B0%9A%E5%BA%AD%E5%85%AC%E5%AF%93/</url>
      
        <content type="html"><![CDATA[<p>本文总结了尚庭公寓项目中遇到的技术知识点。</p><h2 id="1-项目目录结构设计"><a href="#1-项目目录结构设计" class="headerlink" title="1.项目目录结构设计"></a>1.项目目录结构设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lease</span><br><span class="line">├── common（公共模块——工具类、公用配置等）</span><br><span class="line">│   ├── pom.xml （包含公共模块编写所需的全部依赖）</span><br><span class="line">│   └── src</span><br><span class="line">├── model（数据模型——与数据库相对应地实体类）</span><br><span class="line">│   ├── pom.xml （包含数据模型编写所需的全部依赖）</span><br><span class="line">│   └── src</span><br><span class="line">├── web（Web模块）</span><br><span class="line">│   ├── pom.xml （包含common和model这个两个模块的依赖，以及该模块下所需的其他依赖）</span><br><span class="line">│   ├── web-admin（后台管理系统Web模块——包含mapper、service、controller）</span><br><span class="line">│   │   ├── pom.xml （做为web模块的子类项目）</span><br><span class="line">│   │   └── src</span><br><span class="line">│   └── web-app（移动端Web模块——包含mapper、service、controller）</span><br><span class="line">│       ├── pom.xml</span><br><span class="line">│       └── src</span><br><span class="line">└── pom.xml （统一管理子模块所有的依赖版本号）</span><br></pre></td></tr></table></figure><p>根模块的pom.xml文件中对相关依赖的版本号进行统一管理。</p><p>common、model和web模块均以lease根模块为父级项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ldy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lease<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而common和model模块做为公共模块，提供给web模块进行依赖调用</p><p>web模块的pom.xml文件如下所示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ldy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ldy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各个模块所需的依赖清晰规划好，可以减少依赖的冗余和减少重复配置</p><h2 id="2-实体类和接口的定义要点"><a href="#2-实体类和接口的定义要点" class="headerlink" title="2.实体类和接口的定义要点"></a>2.实体类和接口的定义要点</h2><ul><li><p>实体类中的公共字段（例如<code>id</code>、<code>create_time</code>、<code>update_time</code>、<code>is_deleted</code>）抽取到一个基类，进行统一管理，然后让各实体类继承该基类。</p></li><li><p>实体类中的状态字段（例如<code>status</code>）或类型字段（例如<code>type</code>），全部使用枚举类型。</p></li><li><blockquote><p>状态（类型）字段，在数据库中通常用一个数字表示一个状态（类型）。例如：订单状态（1:待支付，2:待发货，3:待收货，4:已收货，5:已完结）。若实体类中对应的字段也用数字类型，例如<code>int</code>，那么程序中就会有大量的如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">order.setStatus(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (order.getStatus() == <span class="number">1</span>) &#123;</span><br><span class="line">order.setStatus(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码后期维护起来会十分麻烦，所以本项目中所有的此类字段均使用枚举类型。例如上述订单状态可定义为以下枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    CANCEL(<span class="number">0</span>, <span class="string">&quot;已取消&quot;</span>),</span><br><span class="line">    WAIT_PAY(<span class="number">1</span>, <span class="string">&quot;待支付&quot;</span>),</span><br><span class="line">    WAIT_TRANSFER(<span class="number">2</span>, <span class="string">&quot;待发货&quot;</span>),</span><br><span class="line">    WAIT_RECEIPT(<span class="number">3</span>, <span class="string">&quot;待收货&quot;</span>),</span><br><span class="line">    RECEIVE(<span class="number">4</span>, <span class="string">&quot;已收货&quot;</span>),</span><br><span class="line">    COMPLETE(<span class="number">5</span>, <span class="string">&quot;已完结&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单实体类中的状态字段定义为<code>Status</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Integer id;</span><br><span class="line"> <span class="keyword">private</span> Integer userId;</span><br><span class="line"> <span class="keyword">private</span> Status status;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样上述代码便可调整为如下效果，后期维护起来会容易许多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order.setStatus(Status.WAIT_PAY);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>所有的实体类均实现了<code>Serializable</code>接口，方便对实体对象进行缓存。</p><p>因为实现Serializable接口的类可以被序列化，即将对象的状态转换为字节流，以便于存储和传输。在该项目中，是为了让实体类对象缓存到redis当中，当需要从缓存中读取对象时，可以通过反序列化恢复对象状态。</p></li><li><p>所有的<code>Mapper</code>接口均没有使用<code>@Mapper</code>注解，而是使用配置类中的<code>@MapperScan</code>注解统一扫描。</p></li><li><p>vo（View Object）：用于封装或定义接口接收及返回的数据的结构。</p></li><li><p>统一接口返回的数据结构：为方便前端对接口数据进行处理，统一接口返回数据结构是一个良好的习惯。</p><p>以下是该项目所有接口统一返回的数据结构</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正常&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以下是与上述结构相对应的Java类</p><ul><li><p>Result</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回消息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">null</span>)</span><br><span class="line">            result.setData(data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T body, ResultCodeEnum resultCodeEnum)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = build(body);</span><br><span class="line">        result.setCode(resultCodeEnum.getCode());</span><br><span class="line">        result.setMessage(resultCodeEnum.getMessage());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(data, ResultCodeEnum.SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">fail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="literal">null</span>, ResultCodeEnum.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">fail</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = build(<span class="literal">null</span>);</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ResultCodeEnum</p><p>为方便管理，可将返回码<code>code</code>和返回消息<code>message</code>封装到枚举类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCodeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">201</span>, <span class="string">&quot;失败&quot;</span>),</span><br><span class="line">    PARAM_ERROR(<span class="number">202</span>, <span class="string">&quot;参数不正确&quot;</span>),</span><br><span class="line">    SERVICE_ERROR(<span class="number">203</span>, <span class="string">&quot;服务异常&quot;</span>),</span><br><span class="line">    DATA_ERROR(<span class="number">204</span>, <span class="string">&quot;数据异常&quot;</span>),</span><br><span class="line">    ILLEGAL_REQUEST(<span class="number">205</span>, <span class="string">&quot;非法请求&quot;</span>),</span><br><span class="line">    REPEAT_SUBMIT(<span class="number">206</span>, <span class="string">&quot;重复提交&quot;</span>),</span><br><span class="line">    DELETE_ERROR(<span class="number">207</span>, <span class="string">&quot;请先删除子集&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ADMIN_ACCOUNT_EXIST_ERROR(<span class="number">301</span>, <span class="string">&quot;账号已存在&quot;</span>),</span><br><span class="line">    ADMIN_CAPTCHA_CODE_ERROR(<span class="number">302</span>, <span class="string">&quot;验证码错误&quot;</span>),</span><br><span class="line">    ADMIN_CAPTCHA_CODE_EXPIRED(<span class="number">303</span>, <span class="string">&quot;验证码已过期&quot;</span>),</span><br><span class="line">    ADMIN_CAPTCHA_CODE_NOT_FOUND(<span class="number">304</span>, <span class="string">&quot;未输入验证码&quot;</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ADMIN_LOGIN_AUTH(<span class="number">305</span>, <span class="string">&quot;未登陆&quot;</span>),</span><br><span class="line">    ADMIN_ACCOUNT_NOT_EXIST_ERROR(<span class="number">306</span>, <span class="string">&quot;账号不存在&quot;</span>),</span><br><span class="line">    ADMIN_ACCOUNT_ERROR(<span class="number">307</span>, <span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line">    ADMIN_ACCOUNT_DISABLED_ERROR(<span class="number">308</span>, <span class="string">&quot;该用户已被禁用&quot;</span>),</span><br><span class="line">    ADMIN_ACCESS_FORBIDDEN(<span class="number">309</span>, <span class="string">&quot;无访问权限&quot;</span>),</span><br><span class="line"></span><br><span class="line">    APP_LOGIN_AUTH(<span class="number">501</span>, <span class="string">&quot;未登陆&quot;</span>),</span><br><span class="line">    APP_LOGIN_PHONE_EMPTY(<span class="number">502</span>, <span class="string">&quot;手机号码为空&quot;</span>),</span><br><span class="line">    APP_LOGIN_CODE_EMPTY(<span class="number">503</span>, <span class="string">&quot;验证码为空&quot;</span>),</span><br><span class="line">    APP_SEND_SMS_TOO_OFTEN(<span class="number">504</span>, <span class="string">&quot;验证法发送过于频繁&quot;</span>),</span><br><span class="line">    APP_LOGIN_CODE_EXPIRED(<span class="number">505</span>, <span class="string">&quot;验证码已过期&quot;</span>),</span><br><span class="line">    APP_LOGIN_CODE_ERROR(<span class="number">506</span>, <span class="string">&quot;验证码错误&quot;</span>),</span><br><span class="line">    APP_ACCOUNT_DISABLED_ERROR(<span class="number">507</span>, <span class="string">&quot;该用户已被禁用&quot;</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TOKEN_EXPIRED(<span class="number">601</span>, <span class="string">&quot;token过期&quot;</span>),</span><br><span class="line">    TOKEN_INVALID(<span class="number">602</span>, <span class="string">&quot;token非法&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    ResultCodeEnum(Integer code, String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>枚举类的知识点</strong></p><p>枚举常量的初始化<br>每个枚举常量（如 SUCCESS, FAIL, PARAM_ERROR 等）在声明时会调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResultCodeEnum(Integer code, String message) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数，并传入相应的参数。例如：<br>SUCCESS(200, “成功”)：<br>调用 ResultCodeEnum(200, “成功”)，将 code 设为 200，message 设为 “成功”。<br>FAIL(201, “失败”)：<br>调用 ResultCodeEnum(201, “失败”)，将 code 设为 201，message 设为 “失败”。</p><p><strong>注意：</strong></p><p>由于<code>Result</code>和<code>ResultCodeEnum</code>中使用<code>@Data</code>、<code>@Getter</code>注解，因此需要再<strong>common模块</strong>中引入<code>lombok</code>依赖。</p></li></ul><h2 id="3-逻辑删除功能"><a href="#3-逻辑删除功能" class="headerlink" title="3.逻辑删除功能"></a>3.逻辑删除功能</h2><p>由于数据库中所有表均采用逻辑删除策略，所以查询数据时均需要增加过滤条件<code>is_deleted=0</code>。</p><p>上述操作虽不难实现，但是每个查询接口都要考虑到，也显得有些繁琐。为简化上述操作，可以使用Mybatis-Plus提供的逻辑删除功能，它可以自动为查询操作增加<code>is_deleted=0</code>过滤条件，并将删除操作转为更新语句。具体配置如下，详细信息可参考<a href="https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">官方文档</a>。</p><ul><li><p>步骤一：在<code>application.yml</code>中增加如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">flag</span> <span class="comment"># 全局逻辑删除的实体字段名(配置后可以忽略不配置步骤二)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li><li><p>步骤二：在实体类中的删除标识字段上增加<code>@TableLogic</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;主键&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;逻辑删除&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="meta">@TableField(&quot;is_deleted&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>逻辑删除功能只对Mybatis-Plus自动注入的sql起效，也就是说，对于手动在<code>Mapper.xml</code>文件配置的sql不会生效，需要单独考虑。</p></li></ul><p>该项目中因为is_deleted字段取值符合默认值，且所有实体类均继承BaseEntity，所以可以跳过步骤一，只需在isDeleted属性上添加<code>@TableLogic</code>注解即可。</p><h2 id="4-特定字段的忽略和自动填充"><a href="#4-特定字段的忽略和自动填充" class="headerlink" title="4.特定字段的忽略和自动填充"></a>4.特定字段的忽略和自动填充</h2><ul><li><p>特定字段的忽略<br>通常情况下接口响应的Json对象中并不需要<code>create_time</code>、<code>update_time</code>、<code>is_deleted</code>等字段，这时只需在实体类中的相应字段添加<code>@JsonIgnore</code>注解，该字段就会在序列化时被忽略。</p><p>具体配置如下，详细信息可参考Jackson<a href="https://github.com/FasterXML/jackson-annotations#annotations-for-ignoring-properties">官方文档</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;主键&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;create_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;update_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;逻辑删除&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(&quot;is_deleted&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动填充特定字段<br>保存或更新数据时，前端通常不会传入<code>isDeleted</code>、<code>createTime</code>、<code>updateTime</code>这三个字段，因此我们需要手动赋值。但是数据库中几乎每张表都有上述字段，所以手动去赋值就显得有些繁琐。为简化上述操作，我们可采取以下措施。</p><p><code>is_deleted</code>字段：可在数据库中设置该字段的默认值为0。</p><p><code>create_time</code>和<code>update_time</code>：可使用mybatis-plus的自动填充功能，所谓自动填充，就是通过统一配置，在插入或更新数据时，自动为某些字段赋值，具体配置如下，详细信息可参考<a href="https://baomidou.com/pages/4c6bcf/">官方文档</a>。</p><p>为相关字段配置触发填充的时机，例如<code>create_time</code>需要在插入数据时填充，而<code>update_time</code>需要在插入和更新数据时填充。具体配置如下，观察<code>@TableField</code>注解中的<code>fill</code>属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;主键&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;逻辑删除&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="meta">@TableField(&quot;is_deleted&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置自动填充的内容，具体配置如下</p><p>在<strong>common模块</strong>下创建<code>com.atguigu.lease.common.mybatisplus.MybatisMetaObjectHandler</code>类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//插入操作时，更新时间也要赋值</span></span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@TableField(fill &#x3D; …) 和 MetaObjectHandler 的关系</strong><br>@TableField(fill &#x3D; …) 注解和 MetaObjectHandler 类是协同工作的，但它们各自有不同的作用。为了确保自动填充功能正常生效，两者需要配合使用。</p><ol><li>@TableField(fill &#x3D; …) 注解的作用<br>指定自动填充规则：<br>在实体类字段上使用 @TableField(fill &#x3D; FieldFill.INSERT) 或 @TableField(fill &#x3D; FieldFill.INSERT_UPDATE) 等注解，明确指定了该字段在插入或更新操作时需要自动填充。<br>告知 MyBatis Plus：<br>这些注解告诉 MyBatis Plus 框架哪些字段需要在特定的操作（如插入或更新）时进行自动填充。</li><li>MetaObjectHandler 类的作用<br>实现具体的填充逻辑：<br>MetaObjectHandler 接口的实现类（如 MybatisMetaObjectHandler）定义了如何为这些字段赋值。<br>insertFill 和 updateFill 方法中具体实现了在插入和更新操作时为字段赋值的逻辑。</li><li>两者的关系<br>必须配合使用：<br>注解：@TableField(fill &#x3D; …) 注解用于标记哪些字段需要自动填充。<br>处理器：MetaObjectHandler 实现类提供了具体的填充逻辑。<br>如果只设置了注解而没有实现 MetaObjectHandler，则自动填充不会生效；反之，如果只实现了 MetaObjectHandler 而没有设置注解，框架也不会知道哪些字段需要自动填充。</li></ol><p>总之就是fill指定哪些字段<strong>可以</strong>在MetaObjectHandler 类的特定方法里进行填充，至于是否一定填充，则看是否在该特定方法里对该字段进行赋值。</p><p>因为该项目原先<code>update_time</code>是只记录更新的，但我觉得<code>update_time</code>应该在插入时也要赋初值，所以我进行了<code>fill=FieldFill.INSERT_UPDATE</code>的改动，但因为当时在MetaObjectHandler 类中的insertFill方法中没有添加如下对update_time字段赋值的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作时，更新时间也要赋值</span></span><br><span class="line"><span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure><p>导致插入时，<code>update_time</code>字段仍然没有自动填充，我想了挺久才定位到这个原因。</p></li></ul><h2 id="5-枚举类型转换"><a href="#5-枚举类型转换" class="headerlink" title="5.枚举类型转换"></a>5.枚举类型转换</h2><p>由于数据库中的状态值通常以数值类型表示，但我们在定义实体类的时候因为为了方便知道各个状态数值对应的状态而使用枚举类型表示。</p><p>以实体类的<strong>LabelInfo</strong>中的<strong>type</strong>为例，由于这个<strong>type</strong>字段在数据库、实体类、前后端交互的过程中有多种不同的形式，因此在请求和响应的过程中，<strong>type</strong>字段会涉及到多次类型转换。：</p><ul><li><p><strong>数据库中</strong></p><p>数据库中的<strong>type</strong>字段为<code>tinyint</code>类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-------------+--------------+</span><br><span class="line">| Field       | Type         |</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| id          | bigint       |</span><br><span class="line">| type        | tinyint      |</span><br><span class="line">| name        | varchar(255) |</span><br><span class="line">| create_time | timestamp    |</span><br><span class="line">| update_time | timestamp    |</span><br><span class="line">| is_deleted  | tinyint      |</span><br><span class="line">+-------------+--------------+</span><br></pre></td></tr></table></figure></li><li><p><strong>实体类</strong></p><p>实体类中的<strong>type</strong>字段为<code>ItemType</code>枚举类型</p><p><code>LabelInfo</code>实体类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Schema(description = &quot;标签信息表&quot;)</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;label_info&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LabelInfo</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;类型&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;type&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ItemType type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;标签名称&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemType</code>枚举类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ItemType</span> &#123;</span><br><span class="line"></span><br><span class="line">    APARTMENT(<span class="number">1</span>, <span class="string">&quot;公寓&quot;</span>),</span><br><span class="line">    ROOM(<span class="number">2</span>, <span class="string">&quot;房间&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ItemType(Integer code, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>前后端交互中</strong></p><p>前后端交互所传递的数据中<strong>type</strong>字段为<strong>数字</strong>（1&#x2F;2）。</p><p><img src="/../images/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%92%8C%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="请求参数和响应结果"></p></li></ul><p>具体转换过程如下图所示：</p><ul><li><p><strong>请求流程：</strong><br><img src="/../images/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0.drawio.png" alt="枚举类型转换过程-请求参数.drawio"></p><p>说明</p><ul><li>SpringMVC中的<code>WebDataBinder</code>组件负责将HTTP的请求参数绑定到Controller方法的参数（请求体的JSON字符串类型转换则交给<code>HTTPMessageConverter</code>组件），并实现参数类型的转换。</li><li>Mybatis中的<code>TypeHandler</code>用于处理Java中的实体对象与数据库之间的数据类型转换。</li></ul></li><li><p><strong>响应流程</strong><br><img src="/../images/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-%E5%93%8D%E5%BA%94%E4%BD%93.drawio.png" alt="枚举类型转换过程-响应体.drawio"></p><p><strong>说明</strong></p><ul><li>SpringMVC中的<code>HTTPMessageConverter</code>组件负责将<strong>Controller方法的返回值（Java对象）</strong>转换为HTTP响应体中的JSON字符串。</li><li>或者将<strong>请求体中的JSON字符串</strong>转换为Controller方法中的参数（Java对象），如下图所示。<br><img src="/../images/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-%E8%AF%B7%E6%B1%82%E4%BD%93.drawio.png" alt="枚举类型转换过程-请求体.drawio"></li></ul></li></ul><p>下面介绍一下每个环节的类型转换原理</p><ul><li><p><strong>WebDataBinder枚举类型转换</strong></p><p><code>WebDataBinder</code>依赖于<a href="https://docs.spring.io/spring-framework/reference/core/validation/convert.html"><code>Converter</code></a>实现类型转换，若Controller方法声明的<code>@RequestParam</code>参数的类型不是<code>String</code>，<code>WebDataBinder</code>就会自动进行数据类型转换。SpringMVC提供了常用类型的转换器，例如<code>String</code>到<code>Integer</code>、<code>String</code>到<code>Date</code>，<code>String</code>到<code>Boolean</code>等等，其中也包括<code>String</code>到枚举类型，但是<code>String</code>到枚举类型的默认转换规则是根据实例名称（”APARTMENT”）转换为枚举对象实例（ItemType.APARTMENT）。若想实现<code>code</code>属性到枚举对象实例的转换，需要自定义<code>Converter</code>，代码如下，具体内容可参考<a href="https://docs.spring.io/spring-framework/reference/core/validation/convert.html#core-convert-Converter-API">官方文档</a>。</p><ul><li><p>在<strong>web-admin模块</strong>自定义<code>com.atguigu.lease.web.admin.custom.converter.StringToItemTypeConverter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToItemTypeConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, ItemType&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/*这里的code参数就是前端传过来需要进行类型转换的值</span></span><br><span class="line"><span class="comment">    所以这里转换器定义并添加FormatterRegistry后，主类下的所有Controller中的接收参数只要是ItemType类型，默认前端传过来的值都是他的code值*/</span></span><br><span class="line">    <span class="keyword">public</span> ItemType <span class="title function_">convert</span><span class="params">(String code)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ItemType value : ItemType.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.getCode().equals(Integer.valueOf(code))) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;code非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册上述的<code>StringToItemTypeConverter</code>，在<strong>web-admin模块</strong>创建<code>com.atguigu.lease.web.admin.custom.config.WebMvcConfiguration</code>，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringToItemTypeConverter stringToItemTypeConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        registry.addConverter(<span class="built_in">this</span>.stringToItemTypeConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是我们有很多的枚举类型都需要考虑类型转换这个问题，按照上述思路，我们需要为每个枚举类型都定义一个Converter，并且每个Converter的转换逻辑（code值–&gt;枚举类）都完全相同，针对这种情况，我们使用<a href="https://docs.spring.io/spring-framework/reference/core/validation/convert.html#core-convert-ConverterFactory-SPI"><code>ConverterFactory</code></a>接口更为合适，这个接口可以将同一个转换逻辑应用到一个接口的所有实现类，因此我们可以定义一个<code>BaseEnum</code>接口，然后令所有的枚举类都实现该接口，然后就可以自定义<code>ConverterFactory</code>，集中编写各枚举类的转换逻辑了。具体实现如下：</p><ul><li><p>在<strong>model模块</strong>定义<code>com.atguigu.lease.model.enums.BaseEnum</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseEnum</span> &#123;</span><br><span class="line">    Integer <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>令所有<code>com.atguigu.lease.model.enums</code>包下的枚举类都实现<code>BaseEnun</code>接口</p></li><li><p>在<strong>web-admin模块</strong>自定义<code>com.atguigu.lease.web.admin.custom.converter.StringToBaseEnumConverterFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBaseEnumConverterFactory</span> <span class="keyword">implements</span> <span class="title class_">ConverterFactory</span>&lt;String, BaseEnum&gt; &#123;</span><br><span class="line">    <span class="comment">//因为Converter&lt;String（前端所传数据类型）, T（后端所接受的数据类型）&gt;是一个接口，所以还要进行内部类的convert方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">BaseEnum</span>&gt; Converter&lt;String, T&gt; <span class="title function_">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> T <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line"><span class="comment">//遍历目标枚举类型的所有枚举值，将其code值和source值进行比较</span></span><br><span class="line">                <span class="keyword">for</span> (T enumConstant : targetType.getEnumConstants()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (enumConstant.getCode().equals(Integer.valueOf(source))) &#123;</span><br><span class="line">                        <span class="keyword">return</span> enumConstant;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;非法的枚举值:&quot;</span> + source);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册上述的<code>ConverterFactory</code>，在<strong>web-admin模块</strong>创建<code>com.atguigu.lease.web.admin.custom.config.WebMvcConfiguration</code>，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringToBaseEnumConverterFactory stringToBaseEnumConverterFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        registry.addConverterFactory(<span class="built_in">this</span>.stringToBaseEnumConverterFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>本项目最终采用的是<code>ConverterFactory</code>方案，因此<code>StringToItemTypeConverter</code>相关代码可以直接删除。</p></li></ul></li><li><p><strong>TypeHandler枚举类型转换</strong></p><p>Mybatis预置的<code>TypeHandler</code>可以处理常用的数据类型转换，例如<code>String</code>、<code>Integer</code>、<code>Date</code>等等，其中也包含枚举类型，但是枚举类型的默认转换规则是枚举对象实例（ItemType.APARTMENT）和实例名称（”APARTMENT”）相互映射。若想实现<code>code</code>属性到枚举对象实例的相互映射，需要自定义<code>TypeHandler</code>。</p><p>不过MybatisPlus提供了一个<a href="https://baomidou.com/pages/8390a4/">通用的处理枚举类型的TypeHandler</a>。其使用十分简单，只需在<code>ItemType</code>枚举类的<code>code</code>属性上增加一个注解<code>@EnumValue</code>，Mybatis-Plus便可完成从<code>ItemType</code>对象到<code>code</code>属性之间的相互映射，具体配置如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ItemType</span> &#123;</span><br><span class="line"></span><br><span class="line">    APARTMENT(<span class="number">1</span>, <span class="string">&quot;公寓&quot;</span>),</span><br><span class="line">    ROOM(<span class="number">2</span>, <span class="string">&quot;房间&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ItemType(Integer code, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>HTTPMessageConverter枚举类型转换</strong></p><p><code>HttpMessageConverter</code>依赖于Json序列化框架（默认使用Jackson）。其对枚举类型的默认处理规则也是枚举对象实例（ItemType.APARTMENT）和实例名称（”APARTMENT”）相互映射。不过其提供了一个注解<code>@JsonValue</code>，同样只需在<code>ItemType</code>枚举类的<code>code</code>属性上增加一个注解<code>@JsonValue</code>，Jackson便可完成从<code>ItemType</code>对象到<code>code</code>属性之间的互相映射。具体配置如下，详细信息可参考Jackson<a href="https://fasterxml.github.io/jackson-annotations/javadoc/2.8/com/fasterxml/jackson/annotation/JsonValue.html">官方文档</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ItemType</span> &#123;</span><br><span class="line"></span><br><span class="line">    APARTMENT(<span class="number">1</span>, <span class="string">&quot;公寓&quot;</span>),</span><br><span class="line">    ROOM(<span class="number">2</span>, <span class="string">&quot;房间&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">  <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ItemType(Integer code, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-图片上传管理"><a href="#6-图片上传管理" class="headerlink" title="6.图片上传管理"></a>6.图片上传管理</h2><p>由于公寓、房间等实体均包含图片信息，所以在新增或修改公寓、房间信息时，需要上传图片，因此我们需要实现一个上传图片的接口。</p><p><strong>1. 图片上传流程</strong></p><p>下图展示了新增房间或公寓时，上传图片的流程。</p><p><img src="/../images/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88.drawio.png" alt="图片存储方案.drawio"></p><p>可以看出图片上传接口接收的是图片文件，返回的Minio对象的URL。</p><p><strong>2. 图片上传接口开发</strong></p><p>下面为该接口的具体实现</p><ul><li><p><strong>配置Minio Client</strong></p><ul><li><p>引入Minio Maven依赖</p><p>在<strong>common模块</strong>的<code>pom.xml</code>文件增加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Minio相关参数</p><p>在<code>application.yml</code>中配置Minio的<code>endpoint</code>、<code>accessKey</code>、<code>secretKey</code>、<code>bucketName</code>等参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minio:</span></span><br><span class="line">  <span class="attr">endpoint:</span> <span class="string">http://&lt;hostname&gt;:&lt;port&gt;</span></span><br><span class="line">  <span class="attr">access-key:</span> <span class="string">&lt;access-key&gt;</span></span><br><span class="line">  <span class="attr">secret-key:</span> <span class="string">&lt;secret-key&gt;</span></span><br><span class="line">  <span class="attr">bucket-name:</span> <span class="string">&lt;bucket-name&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上述<code>&lt;hostname&gt;</code>、<code>&lt;port&gt;</code>等信息需根据实际情况进行修改。</p></li><li><p>在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.minio.MinioProperties</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;minio&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.minio.MinioConfiguration</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MinioProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MinioProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MinioClient <span class="title function_">minioClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MinioClient.builder().endpoint(properties.getEndpoint()).credentials(properties.getAccessKey(), properties.getSecretKey()).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>开发图片上传接口</strong></p><ul><li><p>编写Controller层逻辑</p><p>在<code>FileUploadController</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tag(name = &quot;文件管理&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/file&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FileService fileService;</span><br><span class="line">    <span class="meta">@Operation(summary = &quot;上传文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> fileService.upload(file);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(url);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><code>MultipartFile</code>是Spring框架中用于处理文件上传的类，它包含了上传文件的信息（如文件名、文件内容等）。</p></li><li><p>编写Service层逻辑</p><ul><li><p>在<code>FileService</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>FileServiceImpl</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MinioClient minioClient;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MinioProperties minioProperties;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> minioClient.bucketExists(BucketExistsArgs.builder().bucket(minioProperties.getBucketName()).build());</span><br><span class="line">        <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">            <span class="comment">//若该桶不存在，则创建桶并设置访问权限</span></span><br><span class="line">            minioClient.makeBucket(MakeBucketArgs.builder().bucket(minioProperties.getBucketName()).build());</span><br><span class="line">            minioClient.setBucketPolicy(SetBucketPolicyArgs.builder().</span><br><span class="line">                    bucket(minioProperties.getBucketName()).</span><br><span class="line">                    config(createBucketPolicyConfig(minioProperties.getBucketName())).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件命名为 日期+UUID+文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()) +</span><br><span class="line">            <span class="string">&quot;/&quot;</span> + UUID.randomUUID() + <span class="string">&quot;-&quot;</span> + file.getOriginalFilename();</span><br><span class="line">        minioClient.putObject(</span><br><span class="line">                PutObjectArgs.builder()</span><br><span class="line">                        .bucket(minioProperties.getBucketName())</span><br><span class="line">                        .stream(file.getInputStream(), file.getSize(), -<span class="number">1</span>)</span><br><span class="line">                        .object(filename)</span><br><span class="line">                        .contentType(file.getContentType())</span><br><span class="line">                        .build()</span><br><span class="line">                );</span><br><span class="line">    <span class="comment">//返回图片的url</span></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;/&quot;</span>, minioProperties.getEndpoint(), minioProperties.getBucketName(), filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">createBucketPolicyConfig</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">              &quot;Statement&quot; : [ &#123;</span></span><br><span class="line"><span class="string">                &quot;Action&quot; : &quot;s3:GetObject&quot;,</span></span><br><span class="line"><span class="string">                &quot;Effect&quot; : &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">                &quot;Principal&quot; : &quot;*&quot;,</span></span><br><span class="line"><span class="string">                &quot;Resource&quot; : &quot;arn:aws:s3:::%s/*&quot;</span></span><br><span class="line"><span class="string">              &#125; ],</span></span><br><span class="line"><span class="string">              &quot;Version&quot; : &quot;2012-10-17&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.formatted(bucketName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>上述<code>createBucketPolicyConfig</code>方法的作用是生成用于描述指定bucket访问权限的JSON字符串。最终生成的字符串格式如下，其表示，允许(<code>Allow</code>)所有人(<code>*</code>)获取(<code>s3:GetObject</code>)指定桶(<code>&lt;bucket-name&gt;</code>)的内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Action&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;s3:GetObject&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Effect&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Principal&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Resource&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;arn:aws:s3:::&lt;bucket-name&gt;/*&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>由于公寓、房间的图片为公开信息，所以将其设置为所有人可访问。</p></li></ul></li></ul></li></ul><h2 id="7-全局异常处理"><a href="#7-全局异常处理" class="headerlink" title="7.全局异常处理"></a>7.全局异常处理</h2><p>在处理信息时，若遇到有问题的数据，可以手动抛出异常，配置全局异常处理器对该异常进行捕获并返回相应的响应结果，只需要自定义一个异常类，并构造接收合适参数的构造器即可。</p><p>为灵活设置响应信息，可自定义异常类，如下</p><p>在<strong>common模块</strong>创建<code>com.atguigu.lease.common.exception.LeaseException</code>类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常状态码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过状态码和错误消息创建异常对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaseException</span><span class="params">(String message, Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据响应结果枚举对象创建异常对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCodeEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaseException</span><span class="params">(ResultCodeEnum resultCodeEnum)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(resultCodeEnum.getMessage());</span><br><span class="line">        <span class="built_in">this</span>.code = resultCodeEnum.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LeaseException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;, message=&quot;</span> + <span class="built_in">this</span>.getMessage() +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局异常处理器设置于<strong>common模块</strong>的<code>com.atguigu.lease.common.exception.GlobalExceptionHandler</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exception</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.fail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(LeaseException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">LeaseException</span><span class="params">(LeaseException e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.build(e.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为Result新增一个构造方法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">    Result&lt;T&gt; result = build(<span class="literal">null</span>);</span><br><span class="line">    result.setCode(code);</span><br><span class="line">    result.setMessage(message);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在认为有问题，可以直接返回结果时，即可通过抛出异常（注意带上结构枚举参数或者msg值+code值）让全局异常处理器返回响应结果，不需要再经由controller返回。</p><h2 id="8-登陆管理"><a href="#8-登陆管理" class="headerlink" title="8.登陆管理"></a>8.登陆管理</h2><p>以后台管理的登录为例，跟移动端差不多，就少了个短信验证功能。</p><h4 id="8-1-背景知识"><a href="#8-1-背景知识" class="headerlink" title="8.1 背景知识"></a>8.1 背景知识</h4><p><strong>1. 认证方案概述</strong></p><p>有两种常见的认证方案，分别是基于<strong>Session</strong>的认证和基于<strong>Token</strong>的认证，下面逐一进行介绍</p><ul><li><p><strong>基于Session</strong></p><p>基于Session的认证流程如下图所示</p><p><img src="/../images/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8ESession.drawio.png"></p><p>该方案的特点</p><ul><li>登录用户信息保存在服务端内存中，若访问量增加，单台节点压力会较大</li><li>随用户规模增大，若后台升级为集群，则需要解决集群中各服务器登录状态共享的问题。</li></ul></li><li><p><strong>基于Token</strong></p><p>基于Token的认证流程如下图所示</p><p><img src="/../images/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EToken.drawio.png"></p><p>该方案的特点</p><ul><li>登录状态保存在客户端，服务器没有存储开销</li><li>客户端发起的每个请求自身均携带登录状态，所以即使后台为集群，也不会面临登录状态共享的问题。</li></ul></li></ul><p><strong>2. Token详解</strong></p><p>本项目采用基于Token的登录方案，下面详细介绍Token这一概念。</p><p>我们所说的Token，通常指<strong>JWT</strong>（JSON Web TOKEN）。JWT是一种轻量级的安全传输方式，用于在两个实体之间传递信息，通常用于身份验证和信息传递。</p><p>JWT是一个字符串，如下图所示，该字符串由三部分组成，三部分由<code>.</code>分隔。三个部分分别被称为</p><ul><li><code>header</code>（头部）</li><li><code>payload</code>（负载）</li><li><code>signature</code>（签名）</li></ul><p><img src="/../images/JWT.png"></p><p>各部分的作用如下</p><ul><li><p><strong>Header（头部）</strong></p><p>Header部分是由一个JSON对象经过<code>base64url</code>编码得到的，这个JSON对象用于保存JWT 的类型（<code>typ</code>）、签名算法（<code>alg</code>）等元信息，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Payload（负载）</strong></p><p>也称为 Claims（声明），也是由一个JSON对象经过<code>base64url</code>编码得到的，用于保存要传递的具体信息。JWT规范定义了7个官方字段，如下：</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除此之外，我们还可以自定义任何字段，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Signature（签名）</strong></p><p>由头部、负载和秘钥一起经过（header中指定的签名算法）计算得到的一个字符串，用于防止消息被篡改。</p></li></ul><h4 id="8-2-登录流程"><a href="#8-2-登录流程" class="headerlink" title="8.2 登录流程"></a>8.2 登录流程</h4><p>后台管理系统的登录流程如下图所示</p><p><img src="/../images/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.drawio.png"></p><p>根据上述登录流程，可分析出，登录管理共需三个接口，分别是<strong>获取图形验证码</strong>、<strong>登录</strong>、<strong>获取登录用户个人信息</strong>，除此之外，我们还需为所有受保护的接口增加验证JWT合法性的逻辑，这一功能可通过<code>HandlerInterceptor</code>来实现。</p><h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><h5 id="1-获取图形验证码"><a href="#1-获取图形验证码" class="headerlink" title="1.获取图形验证码"></a><strong>1.获取图形验证码</strong></h5><ul><li><p><strong>查看响应的数据结构</strong></p><p>查看<strong>web-admin模块</strong>下的<code>com.atguigu.lease.web.admin.vo.login.CaptchaVo</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;图像验证码&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description=&quot;验证码图片信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description=&quot;验证码key&quot;)</span> <span class="comment">//校验时，会通过key在redis中查找答案，再和填入值进行比较</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置所需依赖</strong></p><ul><li><p><strong>验证码生成工具</strong></p><p>本项目使用开源的验证码生成工具<strong>EasyCaptcha</strong>，其支持多种类型的验证码，例如gif、中文、算术等，并且简单易用，具体内容可参考其<a href="https://gitee.com/ele-admin/EasyCaptcha">官方文档</a>。</p><p>在<strong>common模块</strong>的pom.xml文件中增加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.whvcse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easy-captcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Redis</strong></p><p>在<strong>common模块</strong>的pom.xml中增加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中增加如下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">&lt;hostname&gt;</span></span><br><span class="line">      <span class="attr">port:</span> <span class="string">&lt;port&gt;</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上述<code>hostname</code>和<code>port</code>需根据实际情况进行修改</p></li></ul></li><li><p><strong>编写Controller层逻辑</strong></p><p>在<code>LoginController</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;获取图形验证码&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;login/captcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;CaptchaVo&gt; <span class="title function_">getCaptcha</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CaptchaVo</span> <span class="variable">captcha</span> <span class="operator">=</span> service.getCaptcha();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(captcha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写Service层逻辑</strong></p><ul><li><p>在<code>LoginService</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CaptchaVo <span class="title function_">getCaptcha</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>LoginServiceImpl</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CaptchaVo <span class="title function_">getCaptcha</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SpecCaptcha</span> <span class="variable">specCaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpecCaptcha</span>(<span class="number">130</span>, <span class="number">48</span>, <span class="number">4</span>); <span class="comment">//长、宽、位数</span></span><br><span class="line">    specCaptcha.setCharType(Captcha.TYPE_DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> specCaptcha.text().toLowerCase(); <span class="comment">//验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstant.ADMIN_LOGIN_PREFIX + UUID.randomUUID(); </span><br><span class="line">    <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> specCaptcha.toBase64(); </span><br><span class="line">    redisTemplate.opsForValue().set(key, code, RedisConstant.ADMIN_LOGIN_CAPTCHA_TTL_SEC, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CaptchaVo</span>(image, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>知识点</strong>：</p><ul><li><p>本项目Reids中的key需遵循以下命名规范：<strong>项目名:功能模块名:其他</strong>，例如<code>admin:login:123456</code></p></li><li><p><code>spring-boot-starter-data-redis</code>已经完成了<code>StringRedisTemplate</code>的自动配置，我们直接注入即可。</p></li><li><p>为方便管理，可以将Reids相关的一些值定义为常量，例如key的前缀、TTL时长，内容如下。这些常量统一定义在<strong>common模块</strong>下的<code>com.atguigu.lease.common.constant.RedisConstant</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ADMIN_LOGIN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;admin:login:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ADMIN_LOGIN_CAPTCHA_TTL_SEC</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_LOGIN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;app:login:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">APP_LOGIN_CODE_RESEND_TIME_SEC</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">APP_LOGIN_CODE_TTL_SEC</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_ROOM_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;app:room:&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h5 id="2-登录接口"><a href="#2-登录接口" class="headerlink" title="2. 登录接口"></a>2. 登录接口</h5><ul><li><p><strong>登录校验逻辑</strong></p><p>用户登录的校验逻辑分为三个主要步骤，分别是<strong>校验验证码</strong>，<strong>校验用户状态</strong>和<strong>校验密码</strong>，具体逻辑如下</p><ul><li>前端发送<code>username</code>、<code>password</code>、<code>captchaKey</code>、<code>captchaCode</code>请求登录。</li><li>判断<code>captchaCode</code>是否为空，若为空，则直接响应<code>验证码为空</code>；若不为空进行下一步判断。</li><li>根据<code>captchaKey</code>从Redis中查询之前保存的<code>code</code>，若查询出来的<code>code</code>为空，则直接响应<code>验证码已过期</code>；若不为空进行下一步判断。</li><li>比较<code>captchaCode</code>和<code>code</code>，若不相同，则直接响应<code>验证码不正确</code>；若相同则进行下一步判断。</li><li>根据<code>username</code>查询数据库，若查询结果为空，则直接响应<code>账号不存在</code>；若不为空则进行下一步判断。</li><li>查看用户状态，判断是否被禁用，若禁用，则直接响应<code>账号被禁</code>；若未被禁用，则进行下一步判断。</li><li>比对<code>password</code>和数据库中查询的密码，若不一致，则直接响应<code>账号或密码错误</code>，若一致则进行入最后一步。</li><li>创建JWT，并响应给浏览器。</li></ul></li><li><p><strong>配置所需依赖</strong></p><p>登录接口需要为登录成功的用户创建并返回JWT，本项目使用开源的JWT工具<strong>Java-JWT</strong>，配置如下，具体内容可参考<a href="https://github.com/jwtk/jjwt/tree/0.11.2">官方文档</a>。</p><ul><li><p><strong>引入Maven依赖</strong></p><p>在<strong>common模块</strong>的pom.xml文件中增加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建JWT工具类</strong></p><p>在<strong>common模块</strong>下创建<code>com.atguigu.lease.common.utils.JwtUtil</code>工具类，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">tokenExpiration</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SecretKey</span> <span class="variable">tokenSignKey</span> <span class="operator">=</span> Keys.hmacShaKeyFor(<span class="string">&quot;M0PKKI6pYGVWWfDZw90a0lTpGYX1d4AQ&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createToken</span><span class="params">(Long userId, String username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder().</span><br><span class="line">                setSubject(<span class="string">&quot;USER_INFO&quot;</span>).</span><br><span class="line">                setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + tokenExpiration)).</span><br><span class="line">                claim(<span class="string">&quot;userId&quot;</span>, userId).</span><br><span class="line">                claim(<span class="string">&quot;username&quot;</span>, username).</span><br><span class="line">                signWith(tokenSignKey).</span><br><span class="line">                compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>，claim(自定义添加字段)用于向 JWT 中添加用户信息，因为本项目中在认证通过后需要获取用户的数据，通过jwt的解析，用户id和用户名username得到后可以满足该项目移动端的接口需求。</p></li><li><p><strong>编写HandlerInterceptor拦截器</strong></p><p>我们需要为所有受保护的接口增加校验JWT合法性的逻辑。具体实现如下</p><ul><li><p>在<code>JwtUtil</code>中增加<code>parseToken</code>方法，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseToken</span><span class="params">(String token)</span>&#123;</span><br><span class="line">    <span class="comment">//判断token是否为null</span></span><br><span class="line">    <span class="keyword">if</span>(token == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LeaseException</span>(ResultCodeEnum.ADMIN_LOGIN_AUTH);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回Claims(含有负载信息)给拦截器使用，若token存在问题则会直接抛出异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">JwtParser</span> <span class="variable">jwtParser</span> <span class="operator">=</span> Jwts.parserBuilder().setSigningKey(tokenSingKey).build();</span><br><span class="line">        <span class="keyword">return</span> jwtParser.parseClaimsJws(token).getBody();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ExpiredJwtException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LeaseException</span>(ResultCodeEnum.TOKEN_EXPIRED);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (JwtException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LeaseException</span>(ResultCodeEnum.TOKEN_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写HandlerInterceptor</strong></p><p>在<strong>web-admin模块</strong>中创建<code>com.atguigu.lease.web.admin.custom.interceptor.AuthenticationInterceptor</code>类，内容如下，有关<code>HanderInterceptor</code>的相关内容，可参考<a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet/handlermapping-interceptor.html">官方文档</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseToken(token);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> claims.get(<span class="string">&quot;username&quot;</span>, String.class);</span><br><span class="line">        LoginUserHolder.setLoginUser(<span class="keyword">new</span> <span class="title class_">LoginUser</span>(userId, username));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LoginUserHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>我们约定，前端登录后，后续请求都将JWT，放置于HTTP请求的Header中，其Header的key为<code>access-token</code>。</p></li><li><p><strong>注册HandlerInterceptor</strong></p><p>在<strong>web-admin模块</strong>的<code>com.atguigu.lease.web.admin.custom.config.WebMvcConfiguration</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationInterceptor authenticationInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"> registry.addInterceptor(<span class="built_in">this</span>.authenticationInterceptor).addPathPatterns(<span class="string">&quot;/admin/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/admin/login/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="3-获取登录用户个人信息"><a href="#3-获取登录用户个人信息" class="headerlink" title="3. 获取登录用户个人信息"></a>3. 获取登录用户个人信息</h5><ul><li><p><strong>查看请求和响应的数据结构</strong></p><ul><li><p><strong>响应的数据结构</strong></p><p>查看<strong>web-admin模块</strong>下的<code>com.atguigu.lease.web.admin.vo.system.user.SystemUserInfoVo</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Schema(description = &quot;员工基本信息&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemUserInfoVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户头像&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>请求的数据结构</strong></p><p>按理说，前端若想获取当前登录用户的个人信息，需要传递当前用户的<code>id</code>到后端进行查询。但是由于请求中携带的JWT中就包含了当前登录用户的<code>id</code>，故请求个人信息时，就无需再传递<code>id</code>。</p></li></ul></li><li><p><strong>编写ThreadLocal工具类</strong></p><p>理论上我们可以在Controller方法中，使用<code>@RequestHeader</code>获取JWT，然后在进行解析，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;获取登陆用户个人信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;SystemUserInfoVo&gt; <span class="title function_">info</span><span class="params">(<span class="meta">@RequestHeader(&quot;access-token&quot;)</span> String token)</span> &#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseToken(token);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">    <span class="type">SystemUserInfoVo</span> <span class="variable">userInfo</span> <span class="operator">=</span> service.getLoginUserInfo(userId);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的逻辑没有任何问题，但是这样做，JWT会被重复解析两次（一次在拦截器中，一次在该方法中）。为避免重复解析，通常会在拦截器将Token解析完毕后，将结果保存至<strong>ThreadLocal</strong>中，这样一来，我们便可以在整个请求的处理流程中进行访问了。</p><blockquote><p><strong>ThreadLocal概述</strong></p><p>ThreadLocal的主要作用是为每个使用它的线程提供一个独立的变量副本，使每个线程都可以操作自己的变量，而不会互相干扰，其用法如下图所示。</p><p><img src="/../images/ThreadLocal.drawio.png"></p></blockquote><p>在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.login.LoginUserHolder</code>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;LoginUser&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setLoginUser</span><span class="params">(LoginUser loginUser)</span> &#123;</span><br><span class="line">        threadLocal.set(loginUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoginUser <span class="title function_">getLoginUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.login.LoginUser</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>AuthenticationInterceptor</code>拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseToken(token);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> claims.get(<span class="string">&quot;username&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//将结果保存到ThreadLocal中</span></span><br><span class="line">        LoginUserHolder.setLoginUser(<span class="keyword">new</span> <span class="title class_">LoginUser</span>(userId, username));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Controller层逻辑</strong></p><p>在<code>LoginController</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;获取登陆用户个人信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;SystemUserInfoVo&gt; <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SystemUserInfoVo</span> <span class="variable">userInfo</span> <span class="operator">=</span> service.getLoginUserInfo(LoginUserHolder.getLoginUser().getUserId());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-Mybatis插件分页注意事项"><a href="#9-Mybatis插件分页注意事项" class="headerlink" title="9.Mybatis插件分页注意事项"></a>9.Mybatis插件分页注意事项</h2><p>使用Mybatis-Plus的分页插件进行分页查询时，如果结果需要使用<code>&lt;collection&gt;</code>进行映射，只能使用**<a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#nested-select-for-collection">嵌套查询（Nested Select for Collection）</a><strong>，而不能使用</strong><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#nested-results-for-collection">嵌套结果映射（Nested Results for Collection）</a>**。</p><p><strong>嵌套查询</strong>和<strong>嵌套结果映射</strong>是Collection映射的两种方式，下面通过一个案例进行介绍</p><p>例如有<code>room_info</code>和<code>graph_info</code>两张表，其关系为一对多，如下</p><p><img src="/../images/mybatis-%E4%B8%80%E5%AF%B9%E5%A4%9A.drawio.png"></p><p>现需要查询房间列表及其图片信息，期望返回的结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="number">201</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rent&quot;</span><span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;graphList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="number">202</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rent&quot;</span><span class="punctuation">:</span> <span class="number">3000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;graphList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>为得到上述结果，可使用以下两种方式</p><ul><li><p><strong>嵌套结果映射</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectRoomPage&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;RoomPageMap&quot;</span>&gt;</span></span><br><span class="line">    select ri.id room_id,</span><br><span class="line">           ri.number,</span><br><span class="line">           ri.rent,</span><br><span class="line">       gi.id graph_id,</span><br><span class="line">           gi.url,</span><br><span class="line">           gi.room_id</span><br><span class="line">    from room_info ri</span><br><span class="line">   left join graph_info gi on ri.id=gi.room_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;RoomPageMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;RoomInfoVo&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;room_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;graphInfoList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;GraphInfo&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;graph_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式的执行原理如下图所示</p><p><img src="/../images/mybatis-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84.drawio.png"></p></li><li><p><strong>嵌套查询</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectRoomPage&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;RoomPageMap&quot;</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">           number,</span><br><span class="line">           rent</span><br><span class="line">    from room_info</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;RoomPageMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;RoomInfoVo&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;graphInfoList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;GraphInfo&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectGraphByRoomId&quot;</span>  <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectGraphByRoomId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;GraphInfo&quot;</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">           url,</span><br><span class="line">       room_id</span><br><span class="line">    from graph_info</span><br><span class="line">    where room_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法使用两个独立的查询语句来获取一对多关系的数据。首先，Mybatis会执行主查询来获取<code>room_info</code>列表，然后对于每个<code>room_info</code>，Mybatis都会执行一次子查询来获取其对应的<code>graph_info</code>。</p><p><img src="/../images/mybatis-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2.drawio.png"></p></li></ul><p>若现在使用MybatisPlus的分页插件进行分页查询，假如查询的内容是第<strong>1</strong>页，每页<strong>2</strong>条记录，则上述两种方式的查询结果分别是</p><ul><li><p><strong>嵌套结果映射</strong></p><p><img src="/../images/mybatis-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84.drawio.png"></p></li><li><p><strong>嵌套查询</strong></p><p><img src="/../images/mybatis-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2.drawio.png"></p></li></ul><p>总结起来就是，<strong>嵌套结果映射</strong>是对最后的数据表进行limit，而最后的数据表的多条数据会合并成一个对象，导致最终得到的结果并没有设置的size一样多，所以分页逻辑是存在问题的。而<strong>嵌套查询</strong>会先对主查询（不包含映射对象的列表属性对应的字段）进行limit，然后在子查询中查询并添加集合字段，这样映射出来的结果是正确的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SprinBoot Redis MinIO Linux Knife4j Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis+MybatisPlus总结</title>
      <link href="/2024/12/06/Mybatis-MybatisPlus%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/06/Mybatis-MybatisPlus%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>一、Mybatis简介</p><p>mybatis类似于jdbcTemplate,它是一个封装了java对数据库操作的一个依赖，相比于jdbcTemplate，感觉可用性更好。</p><p>二、实战</p>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis mybatisplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot3学习</title>
      <link href="/2024/11/23/SpringBoot3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/23/SpringBoot3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h2><p>springboot框架简化了SSM框架。之前使用SSM框架时，我们需要导入大量的依赖，和配置许多配置类及其相应的注解，太过于繁琐，不好记，而springboot极大的减轻了这些操作，把这些操作都封装了起来，提高开发效率。</p><h2 id="二、快速启动"><a href="#二、快速启动" class="headerlink" title="二、快速启动"></a>二、快速启动</h2><h3 id="2-1-创建Maven工程"><a href="#2-1-创建Maven工程" class="headerlink" title="2.1 创建Maven工程"></a>2.1 创建Maven工程</h3><p>重新创建一个Maven工程，要求无父工程。</p><h3 id="2-2-继承-spring-boot-starter-parent"><a href="#2-2-继承-spring-boot-starter-parent" class="headerlink" title="2.2 继承 spring-boot-starter-parent"></a>2.2 继承 spring-boot-starter-parent</h3><p>在项目的pom文件中添加如下的继承语句。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--继承springboot父工程--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-添加web启动依赖-spring-boot-starter-web"><a href="#2-3-添加web启动依赖-spring-boot-starter-web" class="headerlink" title="2.3 添加web启动依赖 spring-boot-starter-web"></a>2.3 添加web启动依赖 spring-boot-starter-web</h3><p>整合了spring-webmvc,servlet,jackson等依赖</p><p>不需要指定版本号，上面的父工程已经帮我们指定好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入web启动器依赖即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-创建一个Main类"><a href="#2-4-创建一个Main类" class="headerlink" title="2.4 创建一个Main类"></a>2.4 创建一个Main类</h3><p>@SpringBootApplication是启动类的注解</p><p>而SpringApplication.run(Main.class, args)是固定的启动类配置语句。</p><p>SpringBoot不需要我们在IDEA里配置tomcat，它已经封装好了，当我们运行main方法时，tomcat就会自己启动。而且它还会自己创建ioc容器和进行包扫描，扫描范围为当前Main类所在的包下的所有类，包括了包下包的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查看@SpringBootApplication源码可知有如下注解功能</span></span><br><span class="line"><span class="comment">    1.@SpringBootConfiguration 声明配置类</span></span><br><span class="line"><span class="comment">    2.@EnableAutoConfiguration 自动加载其他配置类</span></span><br><span class="line"><span class="comment">    3.@ComponentScan 包扫描，默认是当前所在的包</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//启动类注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//自动创建ioc容器，启动tomcat服务软件</span></span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-创建HelloController类"><a href="#2-5-创建HelloController类" class="headerlink" title="2.5 创建HelloController类"></a>2.5 创建HelloController类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Springboot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-启动运行"><a href="#2-6-启动运行" class="headerlink" title="2.6 启动运行"></a>2.6 启动运行</h3><p>网址开头默认是localhost:8080</p><p><img src="/../images/image-20241123133343605.png" alt="image-20241123133343605"></p><p>由快速入门可见，springboot相比于SSM实在是太过于方便了，省去了许多麻烦的配置。</p><h2 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h2><h3 id="3-1-统一配置管理概述"><a href="#3-1-统一配置管理概述" class="headerlink" title="3.1 统一配置管理概述"></a>3.1 统一配置管理概述</h3><p>SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中！</p><p>配置文件应该放置在SpringBoot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p><p><img src="/../images/image-20241123145118773.png" alt="image-20241123145118773"></p><h3 id="3-2-快速案例"><a href="#3-2-快速案例" class="headerlink" title="3.2 快速案例"></a>3.2 快速案例</h3><p>springboot规定了读取的配置文件名称，application.properties是其中之一，所以我们在resources文件夹下创建application.properties文件即可，它会自动读取该配置文件。</p><p>1.application.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用springboot提供的配置类来修改参数，key是固定的，有需要则查阅官方文档</span><br><span class="line"># server.port指定了服务器开启的端口号</span><br><span class="line">server.port=80</span><br><span class="line"># server.servlet.context-path指定虚拟目录</span><br><span class="line">server.servlet.context-path=/sb</span><br><span class="line"></span><br><span class="line"># 自定义配置key=value</span><br><span class="line">ldy.name=ldy</span><br><span class="line">ldy.age=19</span><br></pre></td></tr></table></figure><p>2.controller层设置访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ldy.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ldy.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Springboot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;ldy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ldy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name=&quot;</span>+name+<span class="string">&quot;,age=&quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.启动并访问</p><p><img src="/../images/image-20241123144831465.png" alt="image-20241123144831465"></p><h3 id="3-3-yml-ymal-配置文件"><a href="#3-3-yml-ymal-配置文件" class="headerlink" title="3.3 yml(ymal)配置文件"></a>3.3 yml(ymal)配置文件</h3><p>传统的properties因为key不能重复，所以对key使用多层次的命名方法 如 server.servlet.context-path.每次写都要加上许多相同的前缀，如 server。</p><p>yml相比于properties化繁为简显得更加有层次。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法如下,要求每一层进行一次缩进，然后赋值时需要 :空格value,不能忘记冒号后面先加个空格</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/sb</span></span><br><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ldy</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">19</span></span><br></pre></td></tr></table></figure><p>此外，yaml还支持集合赋值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ggbone</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">11</span></span><br><span class="line">    <span class="attr">hbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eat</span></span><br></pre></td></tr></table></figure><h3 id="3-4配置文件读取"><a href="#3-4配置文件读取" class="headerlink" title="3.4配置文件读取"></a>3.4配置文件读取</h3><p>之前在SSM框架的学习中，学会了使用@Value注解，而在springboot中有着更加简便使用的**@ConfigurationProperties**注解。可以进行批量配置以及读取集合。以下是快速案例。</p><p>1.User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 读取配置文件的方式1：@Value</span></span><br><span class="line"><span class="comment">*   1.直接在属性上添加@Value</span></span><br><span class="line"><span class="comment">*   2.@Value(key的全名)</span></span><br><span class="line"><span class="comment">*   3.不能读取集合并赋值</span></span><br><span class="line"><span class="comment">* 方式2：@ConfigurationProperties</span></span><br><span class="line"><span class="comment">*   优点：1.添加在类上，批量配置</span></span><br><span class="line"><span class="comment">*        2.可以给集合赋值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ldy.user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;ldy.user.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;ldy.user.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;ldy.user.hbs&#125;&quot;) //报错，不能读取集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.启动并访问</p><p><img src="/../images/image-20241123153008538.png" alt="image-20241123153008538"></p><h3 id="3-5多环境配置和激活"><a href="#3-5多环境配置和激活" class="headerlink" title="3.5多环境配置和激活"></a>3.5多环境配置和激活</h3><p>当我们把所有配置信息都塞到application.yaml配置文件时，该文件会显得相当冗杂，所以，我们可以进行多环境的配置和激活，将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。只需要在application.yaml文件里指定激活的配置文件即可。</p><p>激活方式见下application.yaml文件。</p><p>要求，其他配置文件的命名规范为application-xxx.yaml。</p><p><img src="/../images/image-20241123154442847.png" alt="image-20241123154442847"></p><p>1.application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ggbone</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">11</span></span><br><span class="line">    <span class="attr">hbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eat</span></span><br><span class="line"><span class="comment">#激活方式：</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">druid</span></span><br></pre></td></tr></table></figure><p>2.application-druid.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">druid:</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">bk201</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>当激活的配置文件的key和application的key有重复时，以激活的配置文件的value值为主。如下图所示。</p><p><img src="/../images/image-20241123154934271.png" alt="image-20241123154934271"></p><h2 id="四、SpringMvc整合"><a href="#四、SpringMvc整合" class="headerlink" title="四、SpringMvc整合"></a>四、SpringMvc整合</h2><p>前面的已经介绍过，springboot整合了springmvc大部分的注解和配置。下面是某些其他springmvc功能的设置。</p><h3 id="4-1-静态资源访问"><a href="#4-1-静态资源访问" class="headerlink" title="4.1 静态资源访问"></a>4.1 静态资源访问</h3><p>使用Spring Boot做开发时 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？springboot给我们配置好了默认的静态资源访问路径。只需要把静态资源创建在相应的路径下即可访问。在maven工程中，classpath指的是main&#x2F;java&#x2F;resources。创建文件如下所示</p><p><img src="/../images/image-20241125133910828.png" alt="image-20241125133910828"></p><p>1.默认路径</p><p><strong>默认的静态资源路径为：</strong></p><p><strong>· classpath:&#x2F;META-INF&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;static&#x2F;</strong></p><p><strong>· classpath:&#x2F;public&#x2F;</strong></p><p>2.自定义路径</p><p>指定路径的语法格式为 classpath:&#x2F;xxx。指定多个时，仅需加逗号写同样的格式。不能是classpath:&#x2F;webapps, web。无法访问web下面的静态资源，因为我试过。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/webapps,</span> <span class="string">classpath:/web</span> <span class="comment">#自定义静态资源访问路径</span></span><br><span class="line">      <span class="comment">#注意，配置静态资源地址后,会覆盖默认值</span></span><br></pre></td></tr></table></figure><h3 id="4-2-拦截器设置"><a href="#4-2-拦截器设置" class="headerlink" title="4.2 拦截器设置"></a>4.2 拦截器设置</h3><p>拦截器的设置没什么变化，都是要创建一个实现HandlerInterceptor接口的类</p><p><img src="/../images/image-20241125134408792.png" alt="image-20241125134408792"></p><p>然后，在Main类所在的包下创建一个配置类</p><p>1.添加@Configuration注解，springboot会自动进行配置类扫描</p><p>2.实现WebMvcConfigurer接口</p><p>3.重写addInterceptor方法，添加自定义的拦截器类对象即可</p><p><img src="/../images/image-20241125134624664.png" alt="image-20241125134624664"></p><h2 id="五、Druid连接池配置"><a href="#五、Druid连接池配置" class="headerlink" title="五、Druid连接池配置"></a>五、Druid连接池配置</h2><h3 id="5-1-添加相应的依赖"><a href="#5-1-添加相应的依赖" class="headerlink" title="5.1 添加相应的依赖"></a>5.1 添加相应的依赖</h3><p>druid-spring-boot-3-starter目前1.2.20即以上版本已经兼容springboot3了。1.2.20以下版本需要额外配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-配置application-yaml"><a href="#5-2-配置application-yaml" class="headerlink" title="5.2 配置application.yaml"></a>5.2 配置application.yaml</h3><p>druid连接池配置相应信息的固定格式如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># druid连接池配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="comment"># 使用druid连接池</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h3><p>1.实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> completed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Controller类</p><p>因为添加了jdbcTemplate的相应依赖，springboot会自动把JdbcTemplate对象添加到ioc容器里，所以直接用@Autowired获取即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sche&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate template;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Schedule&gt; <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from schedule&quot;</span>;</span><br><span class="line">        List&lt;Schedule&gt; query = template.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Schedule.class));</span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.启动类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.启动并访问</p><p><img src="/../images/image-20241125141114710.png" alt="image-20241125141114710"></p><h2 id="六、Mybatis整合"><a href="#六、Mybatis整合" class="headerlink" title="六、Mybatis整合"></a>六、Mybatis整合</h2><h3 id="6-1Mybatis整合步骤"><a href="#6-1Mybatis整合步骤" class="headerlink" title="6.1Mybatis整合步骤"></a>6.1Mybatis整合步骤</h3><ol><li>导入依赖：在您的Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。</li><li>配置数据源：在<code>application.properties</code>或<code>application.yml</code>中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。</li><li>创建实体类：创建与数据库表对应的实体类。</li><li>创建Mapper接口：创建与数据库表交互的Mapper接口。</li><li>创建Mapper接口的SQL实现： 可以使用mapperxml文件或者注解方式</li><li>创建程序启动类</li><li>注解扫描：在Spring Boot的主应用类上添加<code>@MapperScan</code>注解，用于扫描和注册Mapper接口的动态代理对象到ioc容器。</li><li>使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。</li></ol><p>以下是快速案例</p><h3 id="6-2依赖导入"><a href="#6-2依赖导入" class="headerlink" title="6.2依赖导入"></a>6.2依赖导入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-配置application-yaml文件"><a href="#6-3-配置application-yaml文件" class="headerlink" title="6.3 配置application.yaml文件"></a>6.3 配置application.yaml文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># druid连接池配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mybatis配置， 彻底抛弃mybatis-config.xml文件</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span>  <span class="comment">#指定mapper的xml文件的位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.ldy.bean</span>  <span class="comment">#设置实体类别名</span></span><br><span class="line">  <span class="attr">configuration:</span> <span class="comment"># setting设置</span></span><br><span class="line">    <span class="attr">auto-mapping-behavior:</span> <span class="string">full</span> <span class="comment">#自动映射，full表示可以嵌套映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#开启驼峰式命名法</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span> <span class="comment">#开启日志输出</span></span><br></pre></td></tr></table></figure><h3 id="6-4-类和接口"><a href="#6-4-类和接口" class="headerlink" title="6.4 类和接口"></a>6.4 类和接口</h3><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> completed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduleMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Schedule&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sche&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ScheduleMapper mapper;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Schedule&gt; <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Schedule&gt; schedules = mapper.selectAll();</span><br><span class="line">        <span class="keyword">return</span> schedules;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在Main中开启<strong>mapper包扫描</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ldy.mapper&quot;)</span> <span class="comment">//mapper包扫描,会把接口的代理对象放到ioc容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、其他SSM功能实现"><a href="#七、其他SSM功能实现" class="headerlink" title="七、其他SSM功能实现"></a>七、其他SSM功能实现</h2><h3 id="1-aop切面管理"><a href="#1-aop切面管理" class="headerlink" title="1.aop切面管理"></a>1.aop切面管理</h3><p>知识点：切点表达式，在之前文章里有总结。</p><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对比</p><p>ssm要在配置类中开启Aspcetj注解支持:</p><p><img src="/../images/image-20241126005435013.png" alt="image-20241126005435013"></p><p>而springboot不需要。直接创建advice类添加@Aspect注解即可使用。</p><p>创建一个advice包用于存储各种Advice类。别忘了在类上添加@Aspect和@Component注解</p><p><img src="/../images/image-20241126003945240.png" alt="image-20241126003945240"></p><p>也可以单独创建一个切点表达式的包用于存放切点信息。</p><p><img src="/../images/image-20241126004131771.png" alt="image-20241126004131771"></p><h3 id="2-tx事务管理"><a href="#2-tx事务管理" class="headerlink" title="2.tx事务管理"></a>2.tx事务管理</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了。</p><p>具体使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sche&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ScheduleMapper mapper;</span><br><span class="line">    <span class="comment">//自定义异常</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> mapper.delete(id);</span><br><span class="line">        <span class="comment">//id大于20时制造异常，进行事务回滚</span></span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@Transactional的属性propagation的各种参数具体功能可以参考如下博客</p><p><a href="https://blog.csdn.net/happydecai/article/details/80338053">Spring事务的传播：PROPAGATION_REQUIRED_propagation.required-CSDN博客</a></p><h2 id="八、springboot项目打包运行"><a href="#八、springboot项目打包运行" class="headerlink" title="八、springboot项目打包运行"></a>八、springboot项目打包运行</h2><blockquote><p>在Spring Boot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加<code>spring-boot-maven-plugin</code>插件配置，使用常规的<code>java -jar</code>命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-执行打包"><a href="#6-2-执行打包" class="headerlink" title="6.2 执行打包"></a>6.2 执行打包</h3><p>在idea点击package进行打包</p><p>可以在编译的target文件中查看jar包</p><p><img src="/../images/image_xY_DhdZdAA.png"></p><h3 id="6-3-命令启动和参数说明"><a href="#6-3-命令启动和参数说明" class="headerlink" title="6.3 命令启动和参数说明"></a>6.3 命令启动和参数说明</h3><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。下面是关于<code>java -jar</code>命令的说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令格式：java -jar  [选项] [参数] <span class="tag">&lt;<span class="name">jar文件名</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code>。</li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：<ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如 <code>-Xmx512m</code> 表示设置最大堆内存为512MB。</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如 <code>-Xms256m</code> 表示设置初始堆内存为256MB。</li></ul></li><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定Spring Boot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code>。</li></ol><p>启动和测试：</p><p><img src="/../images/image_sH3S3fZ9Cy.png"></p><p>注意： -D 参数必须要在jar之前！否者不生效！</p><p>以上，即为springboot的快速入门学习，总的来说确实比ssm省事多了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springmvc总结</title>
      <link href="/2024/11/22/Springmvc%E6%80%BB%E7%BB%93/"/>
      <url>/2024/11/22/Springmvc%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringMVC内容较多，且要结合Spring的内容，所以知识点比较散，总结起来太晕了，所以我复制了尚硅谷的springmvc教案，该教案可以说是相当详细了，我对教案内容的某些晦涩难懂地方进行可理解的表达修改。</p><h2 id="一、SpringMVC简介和体验"><a href="#一、SpringMVC简介和体验" class="headerlink" title="一、SpringMVC简介和体验"></a>一、SpringMVC简介和体验</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>SpringMVC官网<a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">https://docs.spring.io/spring-framework/reference/web/webmvc.html</a></p><p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ <code>spring-webmvc</code> ），但它通常被称为“Spring MVC”。</p><p>在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的<strong>首选方案</strong>。之所以能做到这一点，是因为SpringMVC具备如下显著优势：</p><ul><li><strong>Spring 家族原生产品</strong>，与IOC容器等基础设施无缝对接</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><p>原生Servlet API开发代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">                                                        <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于SpringMVC开发代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(&quot;userName&quot;)</span> String userName,Sting password)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">    <span class="comment">//调用业务即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-主要作用"><a href="#1-2-主要作用" class="headerlink" title="1.2 主要作用"></a>1.2 主要作用</h3><p><img src="/../images/image_ubxbkc-DZ5-17322800921573.png"></p><p>SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！</p><p>SpringMVC的作用主要覆盖的是表述层，例如：</p><ul><li>请求映射</li><li>数据输入</li><li>视图界面</li><li>请求分发</li><li>表单回显</li><li>会话控制</li><li>过滤拦截</li><li>异步交互</li><li>文件上传</li><li>文件下载</li><li>数据校验</li><li>类型转换(如JSON)</li><li>等等等</li></ul><p><strong>最终总结：</strong></p><ol><li>简化前端参数接收( 形参列表 )</li><li>简化后端数据响应(返回值)</li><li>以及其他……</li></ol><h3 id="1-3-核心组件和调用流程理解"><a href="#1-3-核心组件和调用流程理解" class="headerlink" title="1.3 核心组件和调用流程理解"></a>1.3 核心组件和调用流程理解</h3><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><strong>SpringMVC处理请求流程：</strong></p><p><img src="/../images/image_tmdw8dA_0q.png"></p><p><strong>SpringMVC涉及组件理解：</strong></p><ol><li>DispatcherServlet :  SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ]</li><li>HandlerMapping :  SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]</li><li>HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]</li><li>Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]</li><li>ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]</li></ol><h3 id="1-4-快速体验"><a href="#1-4-快速体验" class="headerlink" title="1.4 快速体验"></a>1.4 快速体验</h3><ol><li><p>体验场景需求</p><p><img src="/../images/image_JrHCHOxu_n.png"></p></li><li><p>配置分析</p><ol><li>DispatcherServlet，设置处理所有请求！</li><li>HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！</li><li>Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！</li></ol></li><li><p>准备项目</p><ol><li><p>创建项目</p><p>springmvc-base-quick</p><p>注意：需要转成maven&#x2F;web程序！！</p></li><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.api</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">servlet.api</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springioc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- web相关依赖  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用</span></span><br><span class="line"><span class="comment">         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’</span></span><br><span class="line"><span class="comment">         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的</span></span><br><span class="line"><span class="comment">         Servlet API，没有更新到 Jakarta EE 规范。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.api&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- springwebmvc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Controller声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler就是controller内部的具体方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestMapping</span>(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ResponseBody</span> 代表向浏览器直接返回数据!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/springmvc/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloController.hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello springmvc!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Spring MVC核心组件配置类</p><blockquote><p>声明springmvc涉及组件信息的配置类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>     </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerMapping <span class="title function_">handlerMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SpringMVC环境搭建</p><blockquote><p>对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> getServletMappings 返回的地址 设置DispatherServlet对应处理的地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定service / mapper层的配置类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定springmvc的配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置dispatcherServlet的处理路径!</span></span><br><span class="line"><span class="comment">   * 一般情况下为 / 代表处理所有请求!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动测试</p><p>注意： tomcat应该是10+版本！方可支持 Jakarta EE API!</p><p><img src="/../images/image_196iViHp_T.png"></p></li></ol><h2 id="二、SpringMVC接收数据"><a href="#二、SpringMVC接收数据" class="headerlink" title="二、SpringMVC接收数据"></a>二、SpringMVC接收数据</h2><h3 id="2-1-访问路径设置"><a href="#2-1-访问路径设置" class="headerlink" title="2.1 访问路径设置"></a>2.1 访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><ol><li><p><strong>精准路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>模糊路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/*  </span></span><br><span class="line"><span class="comment">     *    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *    /product/a/a 不可以</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/** </span></span><br><span class="line"><span class="comment">     *   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *   /product/a/a 也可以访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/product/*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductController.show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;product show!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单层匹配和多层匹配：</span><br><span class="line">  /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。</span><br><span class="line">  /**：可以匹配URL地址中的多层。</span><br><span class="line">其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次</span><br><span class="line">这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</span><br></pre></td></tr></table></figure></li><li><p><strong>类和方法级别区别</strong></p><p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p><ol><li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li><li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.标记到handler方法</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/logout&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.优化标记类+handler方法</span></span><br><span class="line"><span class="comment">//类上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//handler方法上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>附带请求方式限制</strong></p><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！</p><p>如果需要特定指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     * method = RequestMethod.POST 可以指定单个或者多个请求方式!</span></span><br><span class="line"><span class="comment">     * 注意:违背请求方式会出现405异常!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：违背请求方式，会出现405异常！！！</p></li><li><p><strong>进阶注解</strong></p><p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)</span></span><br><span class="line">||</span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/login&quot;)</span></span><br></pre></td></tr></table></figure><p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p></li><li><p><strong>常见配置问题</strong></p><p>出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。</p><blockquote><p>There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() <strong>mapped</strong>.</p></blockquote></li></ol><h3 id="2-2-接收参数（重点）"><a href="#2-2-接收参数（重点）" class="headerlink" title="2.2 接收参数（重点）"></a>2.2 接收参数（重点）</h3><h4 id="2-2-1-param-和-json参数比较"><a href="#2-2-1-param-和-json参数比较" class="headerlink" title="2.2.1 param 和 json参数比较"></a>2.2.1 param 和 json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li><p>参数编码： &#x20;</p><p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。</p></li><li><p>参数顺序： &#x20;</p><p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p></li><li><p>数据类型： &#x20;</p><p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p></li><li><p>嵌套性： &#x20;</p><p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p></li><li><p>可读性： &#x20;</p><p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p></li></ol><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><h4 id="2-2-2-param参数接收"><a href="#2-2-2-param参数接收" class="headerlink" title="2.2.2 param参数接收"></a>2.2.2 param参数接收</h4><ol><li><p><strong>直接接值</strong></p><p>客户端请求</p><p><img src="/../images/image_3SOeT8tvvW.png"></p><p>handler接收参数</p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">     *    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">     *          类型相同</span></span><br><span class="line"><span class="comment">     * 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@RequestParam注解</strong></p><p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p><code>@RequestParam</code>使用场景：</p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值<br>基本用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment"> *  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;stuAge&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p><p>如果没有没有设置非必须，也没有传递参数会出现：</p><p><img src="/../images/image_vIkYCRMSZL.png"></p><p>将参数设置非必须，并且设置默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>特殊场景接值</strong></p><ol><li><p>一名多值</p><p>多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment"> *  前提就是参数名一致，如上述网址的两个hbs</span></span><br><span class="line"><span class="comment"> *  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line">    <span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体接收</p><p>Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例：</p><p>定义一个用于接收参数的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中，使用实体对象接收，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p><p>使用postman传递参数测试：</p><p><img src="/../images/image_5BkbhZjtyX.png"></p></li></ol></li></ol><h4 id="2-2-3-路径-参数接收"><a href="#2-2-3-路径-参数接收" class="headerlink" title="2.2.3 路径 参数接收"></a>2.2.3 路径 参数接收</h4><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <code>@PathVariable</code> 注解来处理路径传递参数。</p><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment"> * 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment"> *              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-json参数接收"><a href="#2-2-4-json参数接收" class="headerlink" title="2.2.4 json参数接收"></a>2.2.4 json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p><ol><li><p>前端发送 JSON 数据的示例：（使用postman测试）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个用于接收 JSON 数据的 Java 类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String gender;</span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。</p></li><li><p>完善配置</p><p>测试：</p><p><img src="/../images/image_-vKMBKKMSZ.png"></p><p>问题：</p><p>org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported]</p><p><img src="/../images/image_Kb8Lv29M2o.png"></p><p>原因：</p><ul><li>不支持json数据类型处理</li><li>没有json类型处理的工具（jackson）<br>解决：<br>springmvc handlerAdpater配置json转化器,配置类需要明确：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br></pre></td></tr></table></figure><p> }<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pom.xml 加入jackson依赖</span><br><span class="line">```xml</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.15.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p></li><li><p>@EnableWebMvc注解说明</p><p>@EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素！我们来解析<code>&lt;mvc:annotation-driven&gt;</code>对应的解析工作！</p><p>让我们来查看下<code>&lt;mvc:annotation-driven&gt;</code>具体的动作！</p><ul><li><p>先查看<code>&lt;mvc:annotation-driven&gt;</code>标签最终对应解析的Java类</p><p><img src="/../images/image_WJXPabVDSl.png"></p></li><li><p>查看解析类中具体的动作即可</p><p>打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler</p><p><img src="/../images/image_37KWhccu6c.png"></p><p>打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_MAPPING_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerMapping.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_ADAPTER_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> AnnotationDrivenBeanDefinitionParser.class.getClassLoader();</span><br><span class="line">    javaxValidationPresent = ClassUtils.isPresent(<span class="string">&quot;jakarta.validation.Validator&quot;</span>, classLoader);</span><br><span class="line">    romePresent = ClassUtils.isPresent(<span class="string">&quot;com.rometools.rome.feed.WireFeed&quot;</span>, classLoader);</span><br><span class="line">    jaxb2Present = ClassUtils.isPresent(<span class="string">&quot;jakarta.xml.bind.Binder&quot;</span>, classLoader);</span><br><span class="line">    jackson2Present = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>, classLoader) &amp;&amp;</span><br><span class="line">            ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.core.JsonGenerator&quot;</span>, classLoader);</span><br><span class="line">    jackson2XmlPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;</span>, classLoader);</span><br><span class="line">    jackson2SmilePresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;</span>, classLoader);</span><br><span class="line">    jackson2CborPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;</span>, classLoader);</span><br><span class="line">    gsonPresent = ClassUtils.isPresent(<span class="string">&quot;com.google.gson.Gson&quot;</span>, classLoader);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><pre><code> @Override @Nullable public BeanDefinition parse(Element element, ParserContext context) &#123;   //handlerMapping加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);   //添加jackson转化器   addRequestBodyAdvice(handlerAdapterDef);   addResponseBodyAdvice(handlerAdapterDef);   //handlerAdapter加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);   return null; &#125; //具体添加jackson转化对象方法 protected void addRequestBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;requestBodyAdvice&quot;,         new RootBeanDefinition(JsonViewRequestBodyAdvice.class));   &#125; &#125; protected void addResponseBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;responseBodyAdvice&quot;,         new RootBeanDefinition(JsonViewResponseBodyAdvice.class));   &#125; &#125;</code></pre>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.3 接收Cookie数据</span><br><span class="line"></span><br><span class="line">可以使用 `@CookieValue` 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</span><br><span class="line"></span><br><span class="line">考虑使用以下 cookie 的请求：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>下面的示例演示如何获取 cookie 值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-接收请求头数据"><a href="#2-4-接收请求头数据" class="headerlink" title="2.4 接收请求头数据"></a>2.4 接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-原生Api对象操作"><a href="#2-5-原生Api对象操作" class="headerlink" title="2.5 原生Api对象操作"></a>2.5 原生Api对象操作</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p><p>下表描述了支持的控制器方法参数</p><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment"> * 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">                  HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-共享域对象操作"><a href="#2-6-共享域对象操作" class="headerlink" title="2.6 共享域对象操作"></a>2.6 共享域对象操作</h3><h4 id="2-6-1-属性（共享）域作用回顾"><a href="#2-6-1-属性（共享）域作用回顾" class="headerlink" title="2.6.1 属性（共享）域作用回顾"></a>2.6.1 属性（共享）域作用回顾</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f97dcee32b6069830a598d4c04428f21.png" alt="四大域"></p><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。总结，<strong>直至服务器关闭前都有效</strong>。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。总结，<strong>当前浏览器，直至服务器会话过期</strong>。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。总结，<strong>一次请求，转发</strong>。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><p><img src="/../images/img010_VQ5ta0PT96.png"></p><h4 id="2-6-2-Request级别属性（共享）域"><a href="#2-6-2-Request级别属性（共享）域" class="headerlink" title="2.6.2 Request级别属性（共享）域"></a>2.6.2 Request级别属性（共享）域</h4><p>在springmvc中使用共享域时，只需要在方法参数上声明共享域对象，方法体上就可以直接使用该共享域对象的方法了。</p><ol><li><p>使用 Model 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Model model)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ModelMap 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        ModelMap modelMap)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Map 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用原生 request 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">        HttpServletRequest request)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ModelAndView 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">// 2.存入模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-6-3-Session级别属性（共享）域"><a href="#2-6-3-Session级别属性（共享）域" class="headerlink" title="2.6.3 Session级别属性（共享）域"></a>2.6.3 Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-4-Application级别属性（共享）域"><a href="#2-6-4-Application级别属性（共享）域" class="headerlink" title="2.6.4 Application级别属性（共享）域"></a>2.6.4 Application级别属性（共享）域</h4><p>解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、SpringMVC响应数据"><a href="#三、SpringMVC响应数据" class="headerlink" title="三、SpringMVC响应数据"></a>三、SpringMVC响应数据</h2><h3 id="3-1-handler方法分析"><a href="#3-1-handler方法分析" class="headerlink" title="3.1 handler方法分析"></a>3.1 handler方法分析</h3><p>理解handler方法的作用和组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中注册,供DS查找!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment"> *       1.接收请求参数(param,json,pathVariable,共享域等) </span></span><br><span class="line"><span class="comment"> *       2.调用业务逻辑 </span></span><br><span class="line"><span class="comment"> *       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment"> *       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment"> *       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment"> *       3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">    调用业务方法</span><br><span class="line">    返回的结果 （页面跳转，返回数据（json））</span><br><span class="line">    <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 请求数据接收，我们都是通过handler的形参列表</p><p>&#x20;            前端数据响应，我们都是通过handler的return关键字快速处理！</p><p>&#x20;       springmvc简化了参数接收和响应！</p><h3 id="3-2-页面跳转控制"><a href="#3-2-页面跳转控制" class="headerlink" title="3.2 页面跳转控制"></a>3.2 页面跳转控制</h3><h4 id="3-2-1-快速返回模板视图"><a href="#3-2-1-快速返回模板视图" class="headerlink" title="3.2.1 快速返回模板视图"></a>3.2.1 快速返回模板视图</h4><ol><li><p>开发模式回顾</p><p>在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。</p><p>前后端分离模式：[重点]</p><p>指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。</p><p>混合开发模式：</p><p>指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。</p><p>对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！</p></li><li><p>jsp技术了解</p><p>JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。</p><p>JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。</p><p>JSP 的主要特点包括：</p><ol><li>简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。</li><li>高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。</li><li>多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。<br>总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。</li></ol></li><li><p>准备jsp页面和依赖</p><p>pom.xml依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp需要依赖! jstl--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsp页面创建</p><p>建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！</p><p>位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;</span><br><span class="line">        $&#123;msg&#125;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>快速响应模版页面</p><ol><li><p>配置jsp视图解析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handler返回视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  跳转到提交文件页面  /save/jump</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  如果要返回jsp页面!</span></span><br><span class="line"><span class="comment"> *     1.方法返回值改成字符串类型</span></span><br><span class="line"><span class="comment"> *     2.返回逻辑视图名即可    </span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;</span></span><br><span class="line"><span class="comment"> *            + 逻辑视图名 +</span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;jump&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jumpJsp</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;FileController.jumpJsp&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;request data!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="3-2-2-转发和重定向"><a href="#3-2-2-转发和重定向" class="headerlink" title="3.2.2 转发和重定向"></a>3.2.2 转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 转发到 /demo 路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h3 id="3-3-返回JSON数据（重点）"><a href="#3-3-返回JSON数据（重点）" class="headerlink" title="3.3 返回JSON数据（重点）"></a>3.3 返回JSON数据（重点）</h3><h4 id="3-3-1-前置准备"><a href="#3-3-1-前置准备" class="headerlink" title="3.3.1 前置准备"></a>3.3.1 前置准备</h4><p>导入jackson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加json数据转化器</p><p>@EnableWebMvc&#x20;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-ResponseBody"><a href="#3-3-2-ResponseBody" class="headerlink" title="3.3.2 @ResponseBody"></a>3.3.2 @ResponseBody</h4><ol><li><p>方法上使用@ResponseBody</p><p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="/../images/image_GfNTc3Ei41.png"></p></li><li><p>类上使用@ResponseBody</p><p>如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//responseBody可以添加到类上,代表默认类中的所有方法都生效!</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-3-RestController"><a href="#3-3-3-RestController" class="headerlink" title="3.3.3 @RestController"></a>3.3.3 @RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。</p><p>RestController源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-返回静态资源处理"><a href="#3-4-返回静态资源处理" class="headerlink" title="3.4 返回静态资源处理"></a>3.4 返回静态资源处理</h3><ol><li><p><strong>静态资源概念</strong></p><p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括：</p><ul><li>纯HTML文件</li><li>图片</li><li>CSS文件</li><li>JavaScript文件</li><li>……</li></ul></li><li><p><strong>静态资源访问和问题解决</strong></p><ul><li><p>web应用加入静态资源</p><p><img src="/../images/image_4ZDfBKo7ze.png"></p></li><li><p>手动构建确保编译</p><p><img src="/../images/image_WNWOVOea6e.png"></p><p><img src="/../images/image_jkHB39M3Xa.png"></p><p><img src="/../images/image_iUBYDKRqy5.png"></p></li><li><p>访问静态资源</p><p><img src="/../images/image_k7bhHrwvx1.png"></p></li><li><p>问题分析</p><ul><li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li><li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul></li><li><p>问题解决</p><p>在 SpringMVC 配置配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试访问图片：</p><p><img src="/../images/image_mrBsYbjiMM.png"></p></li><li><p>新的问题：其他原本正常的handler请求访问不了了</p><p>handler无法访问</p><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="四、RESTFul风格设计和实战"><a href="#四、RESTFul风格设计和实战" class="headerlink" title="四、RESTFul风格设计和实战"></a>四、RESTFul风格设计和实战</h2><h3 id="4-1-RESTFul风格概述"><a href="#4-1-RESTFul风格概述" class="headerlink" title="4.1 RESTFul风格概述"></a>4.1 RESTFul风格概述</h3><h4 id="4-1-1-RESTFul风格简介"><a href="#4-1-1-RESTFul风格简介" class="headerlink" title="4.1.1 RESTFul风格简介"></a>4.1.1 RESTFul风格简介</h4><p><img src="/../images/image_wEi6we5MJQ.png"></p><p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。</p><p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。</p><p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p><p><img src="/../images/image_X8M-XfzI_A.png"></p><p>学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！</p><h4 id="4-1-2-RESTFul风格特点"><a href="#4-1-2-RESTFul风格特点" class="headerlink" title="4.1.2 RESTFul风格特点"></a>4.1.2 RESTFul风格特点</h4><ol><li>每一个URI代表1种资源（URI 是名词）；</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是XML或者<strong>JSON</strong>；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li></ol><h4 id="4-1-3-RESTFul风格设计规范"><a href="#4-1-3-RESTFul风格设计规范" class="headerlink" title="4.1.3 RESTFul风格设计规范"></a>4.1.3 <strong>RESTFul风格设计规范</strong></h4><ol><li><p><strong>HTTP协议请求方式要求</strong></p><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table></li><li><p><strong>URL路径风格要求</strong></p><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li></ol><ul><li><p>总结</p><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！</p></li></ul><h4 id="4-1-4-RESTFul风格好处"><a href="#4-1-4-RESTFul风格好处" class="headerlink" title="4.1.4 RESTFul风格好处"></a>4.1.4 RESTFul风格好处</h4><ol><li><p>含蓄，安全</p><p>使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。</p></li><li><p>风格统一</p><p>URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。</p></li><li><p>无状态</p><p>在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。</p></li><li><p>严谨，规范</p><p>严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。</p></li><li><p>简洁，优雅</p><p>过去做增删改查操作需要设计4个不同的URL，现在一个就够了。</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li><li><p>丰富的语义</p><p>通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。</p><blockquote><p><a href="http://localhost:8080/shop" title="http://localhost:8080/shop">http://localhost:8080/shop</a> <a href="http://localhost:8080/shop/product" title="http://localhost:8080/shop/product">http://localhost:8080/shop/product</a> <a href="http://localhost:8080/shop/product/cellPhone" title="http://localhost:8080/shop/product/cellPhone">http://localhost:8080/shop/product/cellPhone</a> <a href="http://localhost:8080/shop/product/cellPhone/iPhone" title="http://localhost:8080/shop/product/cellPhone/iPhone">http://localhost:8080/shop/product/cellPhone/iPhone</a></p></blockquote></li></ol><h3 id="4-2-RESTFul风格实战"><a href="#4-2-RESTFul风格实战" class="headerlink" title="4.2 RESTFul风格实战"></a>4.2 RESTFul风格实战</h3><h4 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1 需求分析"></a>4.2.1 需求分析</h4><ul><li>数据结构： User {id 唯一标识,name 用户名，age 用户年龄}</li><li>功能分析<ul><li>用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10）</li><li>保存用户功能</li><li>根据用户id查询用户详情功能</li><li>根据用户id更新用户数据功能</li><li>根据用户id删除用户数据功能</li><li>多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10）</li></ul></li></ul><h4 id="4-2-2-RESTFul风格接口设计"><a href="#4-2-2-RESTFul风格接口设计" class="headerlink" title="4.2.2 RESTFul风格接口设计"></a>4.2.2 RESTFul风格接口设计</h4><ol><li><p><strong>接口设计</strong></p><table><thead><tr><th>功能</th><th>接口和请求方式</th><th>请求参数</th><th>返回值</th></tr></thead><tbody><tr><td>分页查询</td><td>GET  &#x2F;user</td><td>page&#x3D;1&amp;size&#x3D;10</td><td>{ 响应数据 }</td></tr><tr><td>用户添加</td><td>POST &#x2F;user</td><td>{ user 数据 }</td><td>{响应数据}</td></tr><tr><td>用户详情</td><td>GET &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>用户更新</td><td>PUT &#x2F;user</td><td>{ user 更新数据}</td><td>{响应数据}</td></tr><tr><td>用户删除</td><td>DELETE &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>条件模糊</td><td>GET &#x2F;user&#x2F;search</td><td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td><td>{响应数据}</td></tr></tbody></table></li><li><p><strong>问题讨论</strong></p><p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p><p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p><p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p><ul><li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li><li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。<br>此外，还有一些通用的原则可以遵循：</li><li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li><li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li><li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li></ul></li></ol><h4 id="4-2-3-后台接口实现"><a href="#4-2-3-后台接口实现" class="headerlink" title="4.2.3 后台接口实现"></a>4.2.3 后台接口实现</h4><p>准备用户实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>准备用户Controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 用户模块的控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户保存业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户保存业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户详情业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">detailUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户详情业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户更新业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户更新业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟条件分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;search&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;keyword&quot;,required= false)</span>String keyword)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size + <span class="string">&quot;, keyword = &quot;</span> + keyword);</span><br><span class="line">        System.out.println(<span class="string">&quot;条件分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、SpringMVC其他扩展"><a href="#五、SpringMVC其他扩展" class="headerlink" title="五、SpringMVC其他扩展"></a>五、SpringMVC其他扩展</h2><h3 id="5-1-全局异常处理机制"><a href="#5-1-全局异常处理机制" class="headerlink" title="5.1 全局异常处理机制"></a>5.1 全局异常处理机制</h3><h4 id="5-1-1-异常处理两种方式"><a href="#5-1-1-异常处理两种方式" class="headerlink" title="5.1.1 异常处理两种方式"></a>5.1.1 异常处理两种方式</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p><p>对于异常的处理，一般分为两种方式：</p><ul><li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p>站在宏观角度来看待声明式事务处理：</p><p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p><p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p><h4 id="5-1-2-基于注解异常声明异常处理"><a href="#5-1-2-基于注解异常声明异常处理" class="headerlink" title="5.1.2 基于注解异常声明异常处理"></a>5.1.2 基于注解异常声明异常处理</h4><ol><li><p>声明异常处理控制器类</p><p>异常处理控制类，统一定义异常处理handler方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.execptionhandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * description: 全局异常处理器,内部可以定义异常处理Handler!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明异常处理hander方法</p><p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理handler </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment"> * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment"> * 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment"> * 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment"> *       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件扫描控制器类配置</p><p>确保异常处理控制类被扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,</span></span><br><span class="line"><span class="meta">&quot;com.atguigu.exceptionhandler&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-拦截器使用"><a href="#5-2-拦截器使用" class="headerlink" title="5.2 拦截器使用"></a>5.2 拦截器使用</h3><h4 id="5-2-1-拦截器概念"><a href="#5-2-1-拦截器概念" class="headerlink" title="5.2.1 拦截器概念"></a>5.2.1 拦截器概念</h4><p>拦截器和过滤器解决问题</p><ul><li><p>生活中</p><p>为了提高乘车效率，在乘客进入站台前统一检票</p><p><img src="/../images/img008_uQA2iP6_5n.png"></p></li><li><p>程序中</p><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p><p><img src="/../images/img009_aXz6GsRSMQ.png"></p></li></ul><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li>相似点<ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li>不同点<ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul></li></ul><p>选择：</p><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。</p><p><img src="/../images/image_7rIm3LKXgr.png"></p><h4 id="5-2-2-拦截器使用"><a href="#5-2-2-拦截器使用" class="headerlink" title="5.2.2 拦截器使用"></a>5.2.2 拦截器使用</h4><ol><li><p>创建拦截器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if( ! preHandler())&#123;return;&#125;</span></span><br><span class="line">    <span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 返回true：放行</span></span><br><span class="line">        <span class="comment">// 返回false：不放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器方法拦截位置：</p><p><img src="/../images/image_FwhiGWjP_t.png"></p></li><li><p>修改配置类添加拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line">        <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 配置详解</span><br><span class="line"></span><br><span class="line">   1. 默认拦截全部</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      @Override</span><br><span class="line">      public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">          //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br><span class="line">          registry.addInterceptor(new Process01Interceptor());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><ol start="2"><li><p>精准配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>排除配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排除匹配,排除应该在匹配的范围内排除</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>())</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>多个拦截器执行顺序</p><ol><li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li><li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li><li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li></ol></li></ol><h3 id="5-3-参数校验"><a href="#5-3-参数校验" class="headerlink" title="5.3 参数校验"></a>5.3 参数校验</h3><blockquote><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p></blockquote><ol><li><p><strong>校验概述</strong></p><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr><tr><td>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</td><td></td></tr><tr><td>注解</td><td>规则</td></tr><tr><td>————————————————————————————————————————————————————————————————————————————————————————————————————————————————-</td><td>——————–</td></tr><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr><tr><td>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</td><td></td></tr><tr><td>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</td><td></td></tr></tbody></table></li><li><p><strong>操作演示</strong></p><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>应用校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line">    <span class="meta">@Min(10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line">    <span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//email 邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>handler标记和绑定错误收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">                       BindingResult result)</span>&#123;</span><br><span class="line">       <span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试效果</p><p><img src="/../images/image_BKORDdDEb9.png"></p></li></ul></li><li><p><strong>易混总结</strong></p><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ol><li><p>@NotNull  (用于检测<strong>包装类型</strong>不为null，如Integer, Float, Double…)</p><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p></li><li><p>@NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 <strong>CharSequence、Collection、Map 或者数组对象类型</strong>的属性进行校验，校验时会检查该属性是否<strong>为 Null 或者 size()&#x3D;&#x3D;0</strong>，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p></li><li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于<strong>字符串类型</strong>的属性进行校验，校验时会检查该属性是否<strong>为 Null 或 “” 或者只包含空格</strong>，如果是的话就会校验失败。需要注意的是，**@NotBlank 注解只能用于字符串类型的校验**。<br>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p></li></ol></li></ol><h2 id="六、SpringMVC总结"><a href="#六、SpringMVC总结" class="headerlink" title="六、SpringMVC总结"></a>六、SpringMVC总结</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>springmvc框架</td><td>主要作用、核心组件、调用流程</td></tr><tr><td>简化参数接收</td><td>路径设计、参数接收、请求头接收、cookie接收</td></tr><tr><td>简化数据响应</td><td>模板页面、转发和重定向、JSON数据、静态资源</td></tr><tr><td>restful风格设计</td><td>主要作用、具体规范、请求方式和请求参数选择</td></tr><tr><td>功能扩展</td><td>全局异常处理、拦截器、参数校验注解</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题易错点整理</title>
      <link href="/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这篇博客用于提醒自己在写算法题时，很容易忽视的易错点，有时明明是很小的问题，却花了好长时间才发现。</p><p>2024&#x2F;12&#x2F;10 要考试了，此博客除了易错点整理外，还整理了各种算法思想来应对考试！例题是选取pta上面我提交了好几次才ac的题目。┭┮﹏┭┮</p><h1 id="一、易错点"><a href="#一、易错点" class="headerlink" title="一、易错点"></a>一、易错点</h1><h2 id="1-qsort的cmp函数"><a href="#1-qsort的cmp函数" class="headerlink" title="1.qsort的cmp函数"></a>1.qsort的cmp函数</h2><p>如下图代码，a.d 和b.d都是double类型,如果return语句是a.d-b.d，那么当a.d和b.d的整数位的值相同时，它们并不会排序，导致排序有问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * x, <span class="type">const</span> <span class="type">void</span> * y)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">a</span> =</span> *(<span class="keyword">struct</span> <span class="built_in">map</span>*)x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">b</span> =</span> *(<span class="keyword">struct</span> <span class="built_in">map</span>*)y;</span><br><span class="line">    <span class="keyword">if</span>(a.d &gt; b.d)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-memset函数"><a href="#2-memset函数" class="headerlink" title="2.memset函数"></a>2.memset函数</h2><p>void *memset(void *str, int c, size_t n)</p><p>str是数组名，c是数值，n是sizeof(数组名)</p><p>例如：memset(arr, 0, sizeof(arr));</p><p>memset对于char数组，可以任意c赋值，而int数组只能用于赋值0。因为它是按字节赋值的。</p><p>参考链接<a href="https://blog.csdn.net/Supreme7/article/details/115431235">memset()函数的用法详解-CSDN博客</a></p><h2 id="3-strcmp函数"><a href="#3-strcmp函数" class="headerlink" title="3.strcmp函数"></a>3.strcmp函数</h2><h2 id="4-c-的队列对象"><a href="#4-c-的队列对象" class="headerlink" title="4.c++的队列对象"></a>4.c++的队列对象</h2><h2 id="5-qsort函数"><a href="#5-qsort函数" class="headerlink" title="5.qsort函数"></a>5.qsort函数</h2><p>qsort函数包含四个参数，分别是：</p><p>1.数组名</p><p>2.元素个数（从前往后计算）</p><p>3.数组元素所占字节（int，double，char等所占字节）</p><p>4.排序原则（递增，递减，奇偶交叉等）</p><p>使用例子：</p><p>int arr[100];</p><p>qsort(arr, n, sizeof(int), cmp);</p><p>参考链接<a href="https://blog.csdn.net/Cooler_z/article/details/122384559">C语言排序神器——qsort函数（看这一篇，足矣）-CSDN博客</a></p><h1 id="二、算法整理"><a href="#二、算法整理" class="headerlink" title="二、算法整理"></a>二、算法整理</h1><h2 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h2><h3 id="1）普通的0-1背包问题"><a href="#1）普通的0-1背包问题" class="headerlink" title="1）普通的0-1背包问题"></a>1）普通的0-1背包问题</h3><p>直接根据动态规划来做</p><p>但是，注意，有时会有坑，比如如下代码，问题出在第18行，j应该是&gt;&#x3D;0,而不是&gt;0,原因是vol[i]可能为0.</p><p>因为题目的输入要求为</p><p>第一行包含整数 T ，即个案数。后面是 T 个案例，每个案例有三行，第一行包含两个整数 N ， V ， （N &lt;&#x3D; 1000 ， V &lt;&#x3D; 1000 ） 代表骨头的数量和他的袋子的体积。第二行包含 N 个整数，表示每个骨骼的值。第三行包含 N 个整数，表示每个骨骼的体积。</p><p>这里V没有说大于0，所以0也是可能的。真的吐了，检查了半天，也太恶心了，正常来说肯定大于0啊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int t, n, v;</span><br><span class="line">    int val[1111] = &#123;0&#125;, vol[1111] = &#123;0&#125;;</span><br><span class="line">    int dp[1111] = &#123;0&#125;;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t-- &gt; 0)&#123;</span><br><span class="line">        memset(val, 0, sizeof(val));</span><br><span class="line">        memset(vol, 0, sizeof(vol));</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;n, &amp;v);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;vol[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = v; j &gt; 0; j--)&#123;</span><br><span class="line">                if(j &gt;= vol[i])</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-vol[i]] + val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）普通的完全背包问题"><a href="#2）普通的完全背包问题" class="headerlink" title="2）普通的完全背包问题"></a>2）普通的完全背包问题</h3><p>即可以取任意个相同的物品，应该对于每一个物品，都把它遍历至容量结束为止，可以参考如下代码。</p><p>题目链接<a href="https://blog.csdn.net/weixin_45808737/article/details/115147213">湫湫系列故事——减肥记I(HDU-4808)-CSDN博客</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">111</span>], b[<span class="number">111</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">111111</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = b[i]; j &lt;= m; j ++)&#123;</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-b[i]] + a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）对于判断是否装满背包的完全背包情况下"><a href="#3）对于判断是否装满背包的完全背包情况下" class="headerlink" title="3）对于判断是否装满背包的完全背包情况下"></a>3）对于判断是否装满背包的完全背包情况下</h3><p>得最大&#x2F;最小的价值情况，要额外进行判段，给每一个物品从头遍历至容量最大值时，先判断该容量是否可以装满，可以则进行赋值，不行则不管它。</p><p>题目链接<a href="https://blog.csdn.net/Alanrookie/article/details/107468511">Piggy-Bank HDU - 1114 （完全背包模板题）_在acm能够做任何事情之前,必须编制预算并获得必要的财政支持。这一行动的主要收入-CSDN博客</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">600</span>], w[<span class="number">600</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">11000</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t -- &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;e, &amp;f);</span><br><span class="line">        f = f - e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= f; i++)&#123;</span><br><span class="line">            dp[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p[i], &amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = w[i]; j &lt;= f; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - w[i]] != INF)&#123;</span><br><span class="line">                    dp[j] = min(dp[j], dp[j-w[i]] + p[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[f] != INF)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;</span>, dp[f]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;This is impossible.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）对于普通背包问题，不要进行额外判断了，会出错"><a href="#4）对于普通背包问题，不要进行额外判断了，会出错" class="headerlink" title="4）对于普通背包问题，不要进行额外判断了，会出错"></a>4）对于普通背包问题，不要进行额外判断了，会出错</h3><p>和第二点的题目一样，但使用了额外判断时不能通过。</p><p>未通过代码如下，原因是，从后找能完全符合容量的幸福度不一定是最大的，这是因为占满容量的限制。导致越大的容量价值不一定最高。</p><p>例如 价值    容量</p><p>​ 111      100</p><p>​   1         123</p><p>这个情况下，123容量装满只有1元，而100容量装满有111元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int max(int x, int y)&#123;</span><br><span class="line">    if(x &gt; y)</span><br><span class="line">        return x;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    int a[111], b[111];</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) != EOF)&#123;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;a[i], &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int dp[111111];</span><br><span class="line">        for(int i = 0; i &lt; 111111; i++)&#123;</span><br><span class="line">            dp[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = b[i]; j &lt;= m; j ++)&#123;</span><br><span class="line">                if(dp[j - b[i]] != -1)</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-b[i]] + a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[m] != -1)</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[m]);</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int i = m - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">                if(dp[i] != -1)&#123;</span><br><span class="line">                    printf(&quot;%d&quot;, dp[i]);</span><br><span class="line">                    break;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-放挡板法"><a href="#2-放挡板法" class="headerlink" title="2.放挡板法"></a>2.放挡板法</h2><p>核心思想，<strong>数量最多的种类的数量值 - 1&lt;&#x3D;总数-数量最多的种类的数量值</strong>时，才可以将同种类的物品都隔开。</p><h3 id="例题，吃糖果"><a href="#例题，吃糖果" class="headerlink" title="例题，吃糖果"></a>例题，吃糖果</h3><p>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样； 可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？ 请你写个程序帮忙计算一下。</p><p>输入格式:</p><p>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;&#x3D;1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;&#x3D;1000000)。 </p><p>输出格式:</p><p>对于每组数据，输出一行，包含一个”Yes”或者”No”。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4 1 1</span><br><span class="line">5</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--)</span><br><span class="line">&#123;</span><br><span class="line">int n, num;</span><br><span class="line">//long long保险，毕竟有可能要加很多数，有很大几率超出int</span><br><span class="line">long long sum = 0;</span><br><span class="line">//最大值假定-1完美没问题，因为题目输入都是自然数</span><br><span class="line">int max = -1;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">while (n--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">if (max &lt; num)</span><br><span class="line">max = num;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">//个人感觉这个写法容易理解</span><br><span class="line">if (sum - max &lt;= max - 2)</span><br><span class="line">//sum - max &lt; max - 1</span><br><span class="line">//sum - max + 1 &lt; max</span><br><span class="line">//都是等价的</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-贪心"><a href="#3-贪心" class="headerlink" title="3.贪心"></a>3.贪心</h2><p><strong>核心思想：每次都先取最优解</strong></p><h3 id="例题，田忌赛马"><a href="#例题，田忌赛马" class="headerlink" title="例题，田忌赛马"></a>例题，田忌赛马</h3><p><strong>输入格式:</strong></p><p>输入最多包含 50 个测试用例。每个情况都以第一行的正整数 n （n &lt;&#x3D; 1000） 开始，这是每边的马匹数量。第二行接下来的 n 个整数是 Tian 的马的速度。然后第三行的下一个 n 个整数是国王的马的速度。input 以一行结尾，该行在最后一个测试用例后有一个 0。</p><p><strong>输出格式:</strong></p><p>对于每个 Importing case，输出一行包含单个数字的行，这是 Tian Ji 将获得的最大金额，以银元为单位。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">92 83 71</span><br><span class="line">95 87 74</span><br><span class="line">2</span><br><span class="line">20 20</span><br><span class="line">20 20</span><br><span class="line">2</span><br><span class="line">20 19</span><br><span class="line">22 18</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用田忌最快的马与王最快的马相比较</p><p>如果田忌的快马比王的快马要快</p><p>果断把先用田忌的快马先赢一把(这样赢是代价最小的)</p><p>如果田忌的快马比王的快马要慢</p><p>果断把最慢的马与王最快的马比赛(因为反正都要输，这样我输的价值更大，因为我把最快的马比下去了，可以增加后面其他马赢的机会)</p><p>如果田忌的快马与王的快马<strong>速度一样</strong>——重点！！！</p><p>拿田忌最慢的马和王最慢的马比较</p><p>慢马能赢就让慢马赢，直到慢马比王的慢马速度一样或者更慢时，让慢马和王的快马比，</p><p>之所以慢马速度相同时依旧要让慢马输给快马的原因是如下情况</p><p>王     90 80 70</p><p>田忌 90 80 70</p><p>这时候，如果慢马比掉快马，田忌后面两只都能赢，最后得分200，但如果慢马依旧和慢马比，得分最后是0。</p><p>此外，还需要判断，是否慢吗和快马的速度一样，因为有可能是如下形式</p><p>王     90 90 90</p><p>田忌 90 90 90</p><p>这种情况，不需要减得分。</p><p>答案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = *(<span class="type">int</span>*)a;</span><br><span class="line">    <span class="type">int</span> n2 = *(<span class="type">int</span>*)b;</span><br><span class="line">    <span class="keyword">return</span> n2 - n1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> tianji[num];</span><br><span class="line">        <span class="type">int</span> king[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; num; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tianji[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;king[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        qsort(tianji, num, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">        qsort(king, num, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">        <span class="type">int</span> end = num - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(king[i] &gt; tianji[top])&#123;</span><br><span class="line">                score -= <span class="number">200</span>;</span><br><span class="line">                end -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(king[i] &lt; tianji[top])&#123;</span><br><span class="line">                score += <span class="number">200</span>;</span><br><span class="line">                top += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//慢马能赢就让它赢</span></span><br><span class="line">                <span class="keyword">if</span>(tianji[end] &gt; king[num<span class="number">-1</span>])&#123;</span><br><span class="line">                    score+= <span class="number">200</span>;</span><br><span class="line">                    end -= <span class="number">1</span>;</span><br><span class="line">                    num-= <span class="number">1</span>;</span><br><span class="line">                    i -= <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tianji[end] == king[i])&#123;</span><br><span class="line">                    end -= <span class="number">1</span>; <span class="comment">//慢吗和王的快马的速度一样时不需要减得分</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    score -= <span class="number">200</span>; <span class="comment">//慢马和王的慢马速度一样或者更慢，且慢马比对面快马慢时，需要减得分</span></span><br><span class="line">                    end -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h2><p><strong>核心思想：确立后续</strong></p><h3 id="例题一、母牛的故事"><a href="#例题一、母牛的故事" class="headerlink" title="例题一、母牛的故事"></a>例题一、母牛的故事</h3><p>有一头母牛，它每年年初生一头小母牛。 每头小母牛从第四个年头开始，每年年初也生一头小母牛。 请编程实现在第n年的时候，共有多少头母牛？</p><p>输入格式:</p><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n&#x3D;0表示输入数据的结束，不做处理。</p><p>输出格式:</p><p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：n年母牛的数量等于n-1年母牛的数量加上n-3年母牛的数量，因为n-3年的所有母牛到n年都已经成年了，所以第n年出生的母牛等于n-3年的母牛数量。而第n年的母牛数量等于去年母牛数量加新生母牛数量。故可得递推式m[n] &#x3D; m[n-1] + m[n-3]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long m[55];</span><br><span class="line">    m[1] = 1;</span><br><span class="line">    m[2] = 2;</span><br><span class="line">    m[3] = 3;</span><br><span class="line">    m[4] = 4;</span><br><span class="line">    for(int i = 5; i &lt; 55; i++)&#123;</span><br><span class="line">        m[i] = m[i - 1] + m[i - 3];</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, m[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、儿童队列"><a href="#例题二、儿童队列" class="headerlink" title="例题二、儿童队列"></a>例题二、儿童队列</h3><p>PHT School 有很多学生。有一天，名叫 PigHeader 的校长希望所有学生站成一排。他规定女孩不能单身。换句话说，要么队列中没有女孩，要么不止一个女孩并排站着。情况 n&#x3D;4（n 是孩子的数量）类似于<br>FFFF、FFFM、MFFF、FFMM、MFFM、MMFF、MMMM<br>这里 F 代表女孩，M 代表男孩。满足校长需求的队列总数为 7。你能做一个程序来找到有 n 个孩子的队列总数吗？</p><p>输入格式:</p><p>此问题有多种情况，并由 EOF 结束。在每种情况下，只有一个整数 n 表示子项的数量 （1&lt;&#x3D;n&lt;&#x3D;1000）</p><p>输出格式:</p><p>对于每个测试用例，只有一个整数表示满足 Headmaster 需求的队列数量。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：</p><p>设f[n]合法</p><p>前提，队尾是M,那么前面一定要合法，因为非法无法变成合法。若队伍最后两位是MF,那么只有去掉最后两位后是合法，且该队伍继续进入的下一位是F的情况非法才能变为合法。</p><p>当f[n]的队尾是M时，前n-1个数肯定合法，所以f[n] 的数量等于 f[n-1] 的数量</p><p>当f[n]的队尾是F时，要求f[n]合法，所以f[n-1]的队尾是F.</p><p>此时，f[n-2]既可以合法又可以非法</p><p>f[n-2]合法时，f[n]的数量等于f[n-2].</p><p>而f[n-2]非法时，f[n-2]的队尾两个元素为MF。所以f[n-4]是合法的，f[n]数量等于f[n-4]</p><p>综上三种情况整合起来，得递推式f[n] &#x3D; f[n-1] + f[n-2] + f[n-4]。</p><p>此外，本题还要求高精度，超过了long long，所以用了二维数组来存值每个十进制位的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long f[1001][101] =&#123;0&#125;;</span><br><span class="line">    f[0][1] = 1;</span><br><span class="line">    f[1][1] = 1;</span><br><span class="line">    f[2][1] = 2;</span><br><span class="line">    f[3][1] = 4;</span><br><span class="line">    f[4][1] = 7;</span><br><span class="line">    for(int i = 5; i &lt; 1001; i++)&#123;</span><br><span class="line">        int add =0;</span><br><span class="line">        for(int j = 1; j &lt;= 100; j++)&#123;</span><br><span class="line">            f[i][j] = add + f[i - 1][j] + f[i - 2][j] + f[i - 4][j];</span><br><span class="line">            add = f[i][j] / 10000;</span><br><span class="line">            f[i][j] = f[i][j] % 10000;</span><br><span class="line">            if(add == 0 &amp;&amp; f[i][j] == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;k) != EOF)&#123;</span><br><span class="line">        int end = 0;</span><br><span class="line">        for(int i = 100; i  &gt; 0; i--)&#123;</span><br><span class="line">            if(f[k][i] != 0)&#123;</span><br><span class="line">                end = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d&quot;, f[k][end--]);</span><br><span class="line">        for(int j = end; j &gt; 0; j--)&#123;</span><br><span class="line">            printf(&quot;%04d&quot;, f[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h2><h3 id="例题一、免费馅饼"><a href="#例题一、免费馅饼" class="headerlink" title="例题一、免费馅饼"></a>例题一、免费馅饼</h3><p>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：<br><img src="http://acm.hdu.edu.cn/data/images/1176_1.jpg" alt="img"><br>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</p><p>输入格式:</p><p>输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n&#x3D;0时输入结束。</p><p>输出格式:</p><p>每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。<br>提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5 1</span><br><span class="line">4 1</span><br><span class="line">6 1</span><br><span class="line">7 2</span><br><span class="line">7 2</span><br><span class="line">8 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="例题二、搬寝室"><a href="#例题二、搬寝室" class="headerlink" title="例题二、搬寝室"></a>例题二、搬寝室</h3><p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 &#x3D; 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</p><p>输入格式:</p><p>每组输入数据有两行,第一行有两个数n,k(2&lt;&#x3D;2*k&lt;&#x3D;n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p><p>输出格式:</p><p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="例题三、最大总和"><a href="#例题三、最大总和" class="headerlink" title="例题三、最大总和"></a>例题三、最大总和</h3><p>给定序列 a[1]，a[2]，a[3]……a[n]，你的工作是计算子序列的最大和。例如，给定 （6，-1,5,4，-7），此序列中的最大总和为 6 + （-1） + 5 + 4 &#x3D; 14。</p><p>输入格式:</p><p>输入的第一行包含一个整数 T（1&lt;&#x3D;T&lt;&#x3D;20），表示测试用例的数量。然后是 T 行，每行以一个数字 N（1&lt;&#x3D;N&lt;&#x3D;100000） 开头，然后是 N 个整数（所有整数都在 -1000 到 1000 之间）。</p><p>输出格式:</p><p>对于每个测试用例，您应该输出两行。第一行是 “Case #：”，# 表示测试用例的编号。第二行包含三个整数，序列中的 Max Sum、子序列的开始位置、子序列的结束位置。如果有多个结果，则输出第一个结果。在两个 case 之间输出一个空行。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 6 -1 5 4 -7</span><br><span class="line">7 0 6 -1 1 -6 7 -5</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">14 1 4</span><br><span class="line"></span><br><span class="line">Case 2:</span><br><span class="line">7 1 6</span><br></pre></td></tr></table></figure><p>答案</p><p>解法: </p><p>前提，若第n个元素前面的最大序列值小于0，果断舍弃前面的值，单独列出做为起始值。</p><p>从头开始，用temp不断累加遍历到的元素，不断与max进行比较。若temp&lt;0,则说明后面的值没必要留着前面累赘了，放弃前面，temp&#x3D;0重新开始记录。</p><p>设dp[n]是当前最大序列值数组</p><p>则可得动态规划式：dp[n] &#x3D; dp[n-1] &gt; 0 ? m[n] + dp[n-1] : m[n]。</p><p>下面没有用这个式子，但实际想法差不多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">        int len;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;len);</span><br><span class="line">        int m[100001] = &#123;0&#125;;</span><br><span class="line">        for(int i = 1; i &lt;= len; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        int start = 1; </span><br><span class="line">        int up = 1;</span><br><span class="line">        int end = 1;</span><br><span class="line">        int max = -10000;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">​    for(int i = 1; i &lt;= len; i++)&#123;</span><br><span class="line">​        temp += m[i];</span><br><span class="line">​        if(temp &gt; max)&#123;</span><br><span class="line">​            up = start;</span><br><span class="line">​            max = temp;</span><br><span class="line">​            end = i;</span><br><span class="line">​        &#125;if(temp &lt; 0)&#123;</span><br><span class="line">​            start = i + 1;</span><br><span class="line">​            temp = 0;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    printf(&quot;Case %d:\n%d %d %d\n&quot;, j, max, up, end);</span><br><span class="line">​    if(j!=n)&#123;</span><br><span class="line">​        printf(&quot;\n&quot;);</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-宽度优先搜索BFS"><a href="#6-宽度优先搜索BFS" class="headerlink" title="6.宽度优先搜索BFS"></a>6.宽度优先搜索BFS</h2><p><strong>核心思想：队列</strong></p><p>参考链接<a href="https://blog.csdn.net/aliyonghang/article/details/128724989">宽度优先搜索算法（BFS）详解（超级详细讲解，附有大图）-CSDN博客</a></p><p>bfs函数设计</p><p>可以参考下面两个例题的bfs函数，函数可以不需要参数值，因为不需要递归，在函数里面主要就是在while循环进行入队出队操作，直至遍历到满足的元素后输出结果+return结束，或者队列为空后再输出结果。</p><p>模板一：使用c++的queue对象</p><p>queue&lt;结构体对象名&gt; q</p><p>q.push(元素对象) 放入对象</p><p>q.empty()检测队列是否为空</p><p>q.front() 获取队首元素</p><p>q.pop() 队首元素出队</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//以下两个是必要的头文件！！！！</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct qu&#123;</span><br><span class="line">    int item;</span><br><span class="line">    int step;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">        qu cur = &#123;0, 0&#125;;</span><br><span class="line">        queue&lt;qu&gt; q;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        qu nex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板二、使用c++的priority_queue对象</p><p>priority_queue对象会自动排序，但要求我们自定义的结构体里面有声明相应的排序规则</p><p>注意，priority_queue获取队首用的是top(),不是front()</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int x,y;</span><br><span class="line">bool operator &lt; (const node &amp; a) const</span><br><span class="line">&#123;</span><br><span class="line">return x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个node结构体有两个成员，x和y，它的小于规则是x小者小。</p><p>就是说若当前x比新来的x要小的话，就return true，进行交换，把大的放在靠近队首的地方。</p><p>所以把元素(10,100),(12,60),(14,40),(6,20),(8,20)这五个node加入到队列后，一个个pop()的输出结果是(14,40) (12,60) (10,100) (8,20) (6,80)</p><p>参考链接<a href="https://blog.csdn.net/c20182030/article/details/70757660">【原创】优先队列 priority_queue 详解-CSDN博客</a></p><h3 id="例题一、胜利大逃亡"><a href="#例题一、胜利大逃亡" class="headerlink" title="例题一、胜利大逃亡"></a>例题一、胜利大逃亡</h3><p><strong>7-5 胜利大逃亡</strong></p><p>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会. </p><p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个. 现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.</p><p><img src="https://images.ptausercontent.com/d20c18e1-1c3c-4097-8056-7bb2ad155250.png" alt="image.png"></p><p>输入格式:</p><p>输入数据的第一行是一个正整数K,表明测试数据的数量. 每组测试数据的第一行是四个正整数A,B,C和T(1&lt;&#x3D;A,B,C&lt;&#x3D;50,1&lt;&#x3D;T&lt;&#x3D;1000),它们分别代表城堡的大小和魔王回来的时间. 然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙. (如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)</p><p>输出格式:</p><p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 3 4 20</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 0 0 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 1 1 0</span><br><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><p>答案</p><p>注意点：该题是一个三维数组，需要建立三维坐标，以及六个方向数组。</p><p>2.bfs函数里，该函数没有传入值，在函数开头需要先把队列里元素全都pop掉，再把初始的node cur &#x3D; {0, 0, 0, 0}传入到queue&lt;node&gt; q中。</p><p>3.函数的结束判定。因为只要能遍历到终点或者当前时间已经超时了，那么一定有输出，所以再输出完之后直接return掉结束函数就可以了。</p><p>4.若函数的while循环里，没有最终遍历到终点，那么要记得在while循环外面放一个printf(“-1\n”)语句。</p><p>或者在while循环里最后放上这么一段</p><pre><code>if(q.empty())&#123;    printf(&quot;-1\n&quot;);    return;&#125;</code></pre><p>总之，核心关键点就是记得拿到结果时，<strong>使用return直接结束函数</strong>。因为这个老是会忘记┭┮﹏┭┮。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map[51][51][51];</span><br><span class="line">int vis[51][51][51];</span><br><span class="line">int k, a, b, c, t;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x, y, z;</span><br><span class="line">    int time;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">int dir[6][3] = &#123;&#123;-1, 0, 0&#125;, &#123;1, 0, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, 0, -1&#125;, &#123;0, 0, 1&#125;&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    node n = &#123;0, 0, 0, 0&#125;;</span><br><span class="line">    q.push(n);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        node cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(cur.time &gt; t)&#123;</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur.x == a - 1 &amp;&amp; cur.y == b - 1 &amp;&amp; cur.z == c -1)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, cur.time);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        node nex;</span><br><span class="line">        for(int i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">            int x = cur.x + dir[i][0];</span><br><span class="line">            int y = cur.y + dir[i][1];</span><br><span class="line">            int z = cur.z + dir[i][2];</span><br><span class="line">            if(!vis[x][y][z] &amp;&amp; !map[x][y][z] &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; a &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; b &amp;&amp; z &gt;= 0 &amp;&amp; z &lt; c)&#123;</span><br><span class="line">                nex = &#123;x, y, z, cur.time+1&#125;;</span><br><span class="line">                q.push(nex);</span><br><span class="line">                vis[x][y][z] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">    while(k -- &gt;0)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;t);</span><br><span class="line">        for(int i = 0; i &lt; a; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; b; j++)&#123;</span><br><span class="line">                for(int p = 0; p &lt; c; p++)&#123;</span><br><span class="line">                    scanf(&quot;%d&quot;, &amp;map[i][j][p]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(vis, 0, sizeof(vis));</span><br><span class="line">        vis[0][0][0] = 1;</span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、营救"><a href="#例题二、营救" class="headerlink" title="例题二、营救"></a>例题二、营救</h3><p><strong>7-4 营救</strong></p><p>Angel 被 MOLIGPY 抓住了！他被 Moligpy 关进了监狱。监狱被描述为 N * M （N， M &lt;&#x3D; 200） 矩阵。监狱里有 WALLs、ROAD 和 GUARDs。Angel 的朋友想救 Angel。他们的任务是：接近 Angel。我们假设 “接近 Angel” 是为了到达 Angel 停留的位置。当网格中有守卫时，我们必须杀死他（或她）才能进入网格。我们假设我们向上、向下、向右、向左移动需要 1 个单位的时间，杀死一个守卫也需要 1 个单位的时间。而且我们足够强大，可以杀死所有的守卫。您必须计算接近 Angel 的最短时间。（当然，我们只能将 UP、DOWN、LEFT 和 RIGHT 移动到边界内的相邻网格。</p><p>输入格式:</p><p>第一行包含两个整数，分别代表 N 和 M。然后是 N 行，每行有 M 个字符。“.” 代表道路，“a” 代表 Angel，“r” 代表 Angel 的每个朋友。进程到文件末尾。</p><p>输出格式:</p><p>对于每个测试用例，您的程序应输出一个整数，代表所需的最短时间。如果不存在这样的数字，您应该输出一行，其中包含“可怜的天使必须终生留在监狱中”。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">#.#####.</span><br><span class="line">#.a#..r.</span><br><span class="line">#..#x...</span><br><span class="line">..#..#.#</span><br><span class="line">#...##..</span><br><span class="line">.#......</span><br><span class="line">........</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：</p><p>因为这道题里，time的值不是一直+1，还有可能+2,所以，所以用普通的队列不能ac，因为我们要保证队列前面的元素一定要是time最小的，从前到后遍历时，元素的time是非递减的，这样子才能保证遍历到结束点的时候用时最短。故需要在原普通队列的基础上做一点改动就能够ac了。</p><p>1.queue&lt;node&gt; q 改为 priority_queue&lt;node&gt; q</p><p>2.取队首元素从q.front()改为q.top()。 </p><p>3.结构体里要内嵌比较函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x, y, time;</span><br><span class="line">    <span class="comment">//固定写法，试过了，不能不写const</span></span><br><span class="line">    <span class="type">bool</span> operator &lt;(<span class="type">const</span> node&amp;other)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="comment">//当前元素的值和其他元素的time比较，若返回true,则交换，即当前元素放到后面，所以就是从小到大排</span></span><br><span class="line">        <span class="keyword">return</span> time &gt; other.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易错点：这道题重新写，让我崩溃的是我x和y的范围没有写全，漏了x &gt;&#x3D; 0 和 y &gt;&#x3D; 0，导致一直报段错误，害我找半天错误。</p><p>队列会写的话，优先队列只需要改动一点就行了O(∩_∩)O。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, sx, sy;</span><br><span class="line">char map[201][201];</span><br><span class="line">int vis[201][201];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x, y, time;</span><br><span class="line">    </span><br><span class="line">    bool operator&lt;(const node&amp; other) const &#123;</span><br><span class="line">        return time &gt; other.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">    node st = &#123;sx, sy, 0&#125;;</span><br><span class="line">    q.push(st);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node cur = q.top();</span><br><span class="line">        if(map[cur.x][cur.y] == &#x27;r&#x27;)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, cur.time);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        node nex;</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int x = cur.x + dir[i][0];</span><br><span class="line">            int y = cur.y + dir[i][1];</span><br><span class="line">            if(vis[x][y] == 0 &amp;&amp; map[x][y] != &#x27;#&#x27; &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)&#123;</span><br><span class="line">                if(map[x][y] == &#x27;x&#x27;)&#123;</span><br><span class="line">                    nex = &#123;x, y, cur.time + 2&#125;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    nex = &#123;x, y, cur.time+1&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[x][y] = 1;</span><br><span class="line">                q.push(nex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Poor ANGEL has to stay in the prison all his life.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        q = &#123;&#125;;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            // getchar();</span><br><span class="line">            scanf(&quot;%s&quot;, &amp;map[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                if(map[i][j] == &#x27;a&#x27;)&#123;</span><br><span class="line">                    sx = i; </span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(vis, 0, sizeof(vis));</span><br><span class="line">        vis[sx][sy] = 1;</span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-深度优先搜索DFS"><a href="#7-深度优先搜索DFS" class="headerlink" title="7.深度优先搜索DFS"></a>7.深度优先搜索DFS</h2><p><strong>核心思想：回溯、递归</strong></p><ol><li>为了求得问题的解，先选择某一种可能情况向前探索；</li><li>在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索；</li><li>如此反复进行，直至得到解或证明无解。</li></ol><p>模板</p><p>主要就是设置一个vis数组标记是否访问过。</p><p>难点在如何剪枝</p><p>参考链接<a href="https://blog.csdn.net/qq_47733361/article/details/123858318">DFS (深度优先搜索) 算法详解 + 模板 + 例题，这一篇就够了_dfs算法-CSDN博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int a[510];   //存储每次选出来的数据</span><br><span class="line">int book[510];   //标记是否被访问</span><br><span class="line">int ans = 0; //记录符合条件的次数</span><br><span class="line"></span><br><span class="line">void DFS(int cur)&#123;</span><br><span class="line">if(cur == k)&#123; //k个数已经选完，可以进行输出等相关操作 </span><br><span class="line">for(int i = 0; i &lt; cur; i++)&#123;</span><br><span class="line">printf(&quot;%d &quot;, a[i]);</span><br><span class="line">&#125; </span><br><span class="line">ans++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123; //遍历 n个数，并从中选择k个数 </span><br><span class="line">if(!book[i])&#123; //若没有被访问 </span><br><span class="line">book[i] = 1; //标记已被访问 </span><br><span class="line">a[cur] = i;  //选定本数，并加入数组 </span><br><span class="line">DFS(cur + 1);  //递归，cur+1 </span><br><span class="line">book[i] = 0;  //释放，标记为没被访问，方便下次引用 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题一、骨头者的诱惑"><a href="#例题一、骨头者的诱惑" class="headerlink" title="例题一、骨头者的诱惑"></a>例题一、骨头者的诱惑</h3><p><strong>7-1 骨头的诱惑者</strong></p><p>这只小狗在一个古老的迷宫里发现了一根骨头，这让他非常着迷。然而，当他捡起它时，迷宫开始晃动，小狗能感觉到地面在下沉。他意识到那块骨头是一个陷阱，他拼命想走出这个迷宫。迷宫是一个尺寸为 N x M 的矩形。迷宫里有一扇门。一开始，门是关着的，它会在第 T 秒打开一小段时间（不到 1 秒）。因此，这只小狗必须在第 T 秒到达门口。在每一秒内，他可以将一个块移动到上、下、左、右相邻块中的一个。一旦他进入一个方块，这个方块的地面就会开始下沉，并在下一秒消失。他不能在一个区块上停留超过一秒钟，也不能进入一个被访问过的区块。可怜的小狗能活下来吗？请帮助他。</p><p>输入格式:</p><p>输入由多个测试用例组成。每个测试用例的第一行包含三个整数 N、M 和 T （1 &lt; N， M &lt; 7;0 &lt; T &lt; 50），分别表示迷宫的大小和门打开的时间。接下来的 N 行给出了迷宫布局，每行包含 M 个字符。字符是以下之一： ‘X’：一块墙，小狗不能进入;’S’：小狗的起点;’D’：门;或 ‘.’：一个空块。input 以三个 0 终止。此测试用例不予处理。</p><p>输出格式:</p><p>对于每个测试用例，如果 doggie 可以存活，则在一行中打印 “YES”，否则打印 “NO”。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">..XD</span><br><span class="line">....</span><br><span class="line">3 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">...D</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：</p><p>dfs和剪枝</p><p>1.dfs()，以当前元素的位置和时间作为参数</p><p>2.剪枝。当目前时间减去最短距离所需时间时的剩余时间小于0，或者等于奇数时，那么该点一定走不到终点，直接return。</p><p>问题：该代码读取map各个位置的元素时不能使用getchar()加scanf(),cin或者直接scanf(“%s”)就可以，也不知道为什么。我自己重新写时出一堆问题，明明和原代码差不多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, t, nt;</span><br><span class="line">int ex, ey;</span><br><span class="line">char map[10][10];</span><br><span class="line">int flag = 0;</span><br><span class="line">int dir[4][2] = &#123;&#123;0,1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">void dfs(int x, int y, int cnt)&#123;</span><br><span class="line">    if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x == ex &amp;&amp; y == ey &amp;&amp; cnt == t)&#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = t - cnt - fabs(x - ex) - fabs(y - ey);</span><br><span class="line">    if(temp &lt; 0 || temp % 2 == 1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        if(map[x + dir[i][0]][y + dir[i][1]] != &#x27;X&#x27;)&#123;</span><br><span class="line">            map[x + dir[i][0]][y + dir[i][1]] = &#x27;X&#x27;;</span><br><span class="line">            dfs(x + dir[i][0], y + dir[i][1], cnt+1);</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            map[x + dir[i][0]][y + dir[i][1]] = &#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int sx, sy;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t)&amp;&amp;(m+n+t))&#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        //scanf(&quot;%s&quot;, &amp;map[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                cin&gt;&gt;map[i][j];</span><br><span class="line">                if(map[i][j] == &#x27;S&#x27;)&#123;</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(map[i][j] == &#x27;D&#x27;)&#123;</span><br><span class="line">                    ex = i; </span><br><span class="line">                    ey = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map[sx][sy] = &#x27;X&#x27;;</span><br><span class="line">        dfs(sx, sy, 0);</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、FatMouse-和奶酪"><a href="#例题二、FatMouse-和奶酪" class="headerlink" title="例题二、FatMouse 和奶酪"></a>例题二、FatMouse 和奶酪</h3><p><strong>7-7 FatMouse 和奶酪</strong></p><p>FatMouse 在一个城市储存了一些奶酪。城市可以看作是维度 n 的方形网格：每个网格位置都标记为 （p，q），其中 0 &lt;&#x3D; p &lt; n 和 0 &lt;&#x3D; q &lt; n。在每个网格位置，Fatmouse 都在一个洞中隐藏了 0 到 100 块奶酪。现在他要享受他最喜欢的食物了。FatMouse 首先站在位置 （0,0）。他吃掉了自己站着的奶酪，然后水平或垂直地跑到另一个地方。问题是有一只名叫 Top Killer 的超级猫坐在他的洞附近，所以每次他最多可以跑 k 个位置进入洞中，然后被 Top Killer 抓住。更糟糕的是 – 在一个地方吃完奶酪后，FatMouse 变得更胖了。因此，为了获得足够的能量进行下一次跑步，他必须跑到一个比当前洞的奶酪块更多的地方。给定 n、k 和每个网格位置的奶酪块数，计算 FatMouse 在无法移动之前可以吃的最大奶酪量。</p><p>输入格式:</p><p>有几个测试用例。每个测试用例由一行组成，其中包含两个介于 1 和 100 之间的整数：n 行和 k n 行，每行有 n 个数字：第一行包含位置 （0,0） （0,1） 的奶酪块数……（0，n-1）;下一行包含位置 （1,0）、（1,1）、…（1，n-1） 等。input 以一对 -1 结尾。</p><p>输出格式:</p><p>对于每个测试用例，在一行中输出单个整数，给出收集的奶酪块数。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 2 5</span><br><span class="line">10 11 6</span><br><span class="line">12 12 7</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure><p>答案:</p><p>解法：dfs+dp</p><p>这道题需要注意的是，由于要计算收集的奶酪的最大值，所以我们不能只单纯进行dfs，而应该在dfs过程中运用dp思想，把当前位置可以拿到的最大奶酪数记录到dp数组里。而且由于只能走比自己当前位置大的数的方向，所以没有必要再用vis数组记录当前位置是否被遍历过。</p><p>剪枝:</p><p>若dp数组一开始就赋予了和map数组一样的值，那么进行dfs时，遍历到的位置最大值可能要求好多次。</p><p>从结果推到起点来看，如果我们在dfs中开始先判断dp是否有值，若有，若没有，那么再把同样位置的map值赋给dp当初始值进行最大值搜索，因为这样做，如果从别的位置又遍历到当前位置时，不需要再进行dfs下去，直接return该值即可，因为之前已经dfs过，把当前位置的最大值给记录到了。总之就是当前dp进行dfs后就已经获取最大值了，只是借用dp不为0来进行直接返回。换用其他标记数组也可以达到同样效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[x][y] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x][y] = <span class="built_in">map</span>[x][y];</span><br><span class="line">    <span class="type">int</span> tx, ty, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            tx = dir[i][<span class="number">0</span>] * j + x;</span><br><span class="line">            ty = dir[i][<span class="number">1</span>] * j + y;</span><br><span class="line">            <span class="keyword">if</span>(tx &gt;= <span class="number">0</span> &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; tx &lt; n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[tx][ty] &gt; <span class="built_in">map</span>[x][y])&#123;</span><br><span class="line">                    dp[x][y] = max(<span class="built_in">map</span>[x][y] + dfs(tx, ty), dp[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memset(map, 0, sizeof(map));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;  n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        res = dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-并查集"><a href="#8-并查集" class="headerlink" title="8.并查集"></a>8.并查集</h2><p><strong>核心思想：找父亲findp(), 合并merge()</strong></p><p>1.给每个元素都先把它们自己定义为父亲。</p><p>2.查找目标元素父亲时，使用while循环，直至遍历的当前元素的父亲等于当前元素，此时当前元素即为目标元素的父类。</p><p>3.合并时要注意，合并的是<strong>当前两个元素的父亲</strong>，即先findp(x)和findp(y)，把x和y的父亲先找到，再给y的父亲的父亲设置为x的父亲。而不是直接f[x] &#x3D; y!!!!。</p><p>优化：</p><p>查找目标元素父亲时，顺便把找父亲时遍历的其他元素的f[n]也都直接设置为父亲，这样子可以有效减少之后找父亲的循环次数。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int findp(int x)&#123;</span><br><span class="line">    int r = x;</span><br><span class="line">    //找到最终的父亲</span><br><span class="line">    while(f[r] != r)&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    //给当前元素的f直接设置为父亲的值</span><br><span class="line">    //i存储当前元素，j存储当前元素的f</span><br><span class="line">    int i=x,j;</span><br><span class="line">    while(f[i]!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        j=f[i];</span><br><span class="line">        f[i]=r;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板</p><p>1.findp函数如上面的优化写即可</p><p>2.merge函数</p><p>注意：merge函数有两种写法，一个是在merge里找父亲元素，一个是在调用merge函数之前把父亲找好了再传值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> xp = findp(x);</span><br><span class="line">    <span class="type">int</span> yp = findp(y);</span><br><span class="line">    f[yp] = xp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">f[y] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题一、畅通工程再续"><a href="#例题一、畅通工程再续" class="headerlink" title="例题一、畅通工程再续"></a>例题一、畅通工程再续</h3><p><strong>7-3 畅通工程再续</strong></p><p>全屏浏览切换布局</p><p>作者 刘春英</p><p>单位 杭州电子科技大学</p><p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元&#x2F;米。</p><p>输入格式:</p><p>输入包括多组数据。输入首先包括一个整数T(T &lt;&#x3D; 200)，代表有T组数据。<br>每组数据首先是一个整数C(C &lt;&#x3D; 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;&#x3D; x, y &lt;&#x3D; 1000的整数。</p><p>输出格式:</p><p>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">20 20</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1000 1000</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1414.2</span><br><span class="line">oh!</span><br></pre></td></tr></table></figure><p>答案</p><p>解法</p><p>贪心+并查集</p><p>1.该题使用并查集之前，需要自己在读完所有岛屿信息后，根据条件筛选出两两对应的不同岛屿，把他们的编号和距离存放到结构体数组node中。由于两个for循环遍历完，所以结构体node数组开辟的大小应该是c*(c-1)&#x2F;2。之后使用qsort函数排序后进行并查集操作。</p><p>易错点</p><p>node数组的大小不等于岛的个数c，而是等于<em><em>c</em>(c-1)&#x2F;2</em>*，这点很重要，否则一直报段错误。还有，qsort函数里面排序数量也是c*(c-1),这些都是极易忽视的易错点啊(╯°□°）╯︵ ┻━┻。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int t, c;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    double dis;</span><br><span class="line">&#125;node[10000];</span><br><span class="line">int land[111][2], f[111], vis[101];</span><br><span class="line">int cmp(const void * a, const void * b)&#123;</span><br><span class="line">    struct node x = *(struct node*)a;</span><br><span class="line">    struct node y = *(struct node*)b;</span><br><span class="line">    if(x.dis - y.dis &gt; 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int findp(int x)&#123;</span><br><span class="line">    int r = x;</span><br><span class="line">    while(f[r] != r)&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    int a = x, b;</span><br><span class="line">    while(f[a] != r)&#123;</span><br><span class="line">        b = f[a];</span><br><span class="line">        f[a] = r;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">void merge(int a, int b)&#123;</span><br><span class="line">    f[b] = a;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;c);</span><br><span class="line">        for(int i = 0; i &lt; c; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;land[i][0], &amp;land[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        double dis = 0;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for(int i = 0; i &lt; c-1; i ++)&#123;</span><br><span class="line">            for(int j = i + 1; j &lt; c; j++)&#123;</span><br><span class="line">                dis = sqrt(pow(land[j][0] - land[i][0], 2)+pow(land[j][1]-land[i][1], 2));</span><br><span class="line">                if(dis &gt;= 10 &amp;&amp; dis &lt;= 1000)&#123;</span><br><span class="line">                    node[index].a = i;</span><br><span class="line">                    node[index].b = j;</span><br><span class="line">                    node[index].dis = dis;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; c; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        double sum = 0;</span><br><span class="line">        int num = 0;</span><br><span class="line">        qsort(node, c*(c-1)/2, sizeof(struct node), cmp);</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;</span><br><span class="line">            int fx = findp(node[i].a);</span><br><span class="line">            int fy = findp(node[i].b);</span><br><span class="line">            if(fx != fy)&#123;</span><br><span class="line">                merge(fx, fy);</span><br><span class="line">                sum += node[i].dis;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num == c - 1)</span><br><span class="line">            printf(&quot;%.1lf\n&quot;, sum*100);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;oh!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、Is-It-A-Tree"><a href="#例题二、Is-It-A-Tree" class="headerlink" title="例题二、Is It A Tree"></a>例题二、Is It A Tree</h3><p><strong>7-6 Is It A Tree?</strong></p><p>全屏浏览切换布局</p><p>作者 刘春英</p><p>单位 杭州电子科技大学</p><p>A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties.<br>There is exactly one node, called the root, to which no directed edges point.</p><p>Every node except the root has exactly one edge pointing to it.</p><p>There is a unique sequence of directed edges from the root to each node.</p><p>For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not.<br><img src="https://images.ptausercontent.com/68a90dcf-b7f1-47ae-b69f-e27d254896b6.png" alt="image.png"><img src="https://images.ptausercontent.com/3a21ddd6-66ae-4c58-a4d8-68df04c524bb.png" alt="image.png"><img src="https://images.ptausercontent.com/b85985db-76f8-4b76-9f1a-3fe18f5d5faa.png" alt="image.png"></p><p>In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not.</p><p>输入格式:</p><p>The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero.</p><p>输出格式:</p><p>For each test case display the line <code>Case k is a tree.&quot; or the line </code>Case k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1).</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8 5 3 5 2 6 4</span><br><span class="line">5 6 0 0</span><br><span class="line">8 1 7 3 6 2 8 9 7 5</span><br><span class="line">7 4 7 8 7 6 0 0</span><br><span class="line">3 8 6 8 6 4</span><br><span class="line">5 3 5 6 5 2 0 0</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1 is a tree.</span><br><span class="line">Case 2 is a tree.</span><br><span class="line">Case 3 is not a tree.</span><br></pre></td></tr></table></figure><p>答案</p><p>解法</p><p>1.一个节点有两个父节点时，这就不是一个树了。所以在合并前，应先判断b是否已经有父节点了。</p><p>2.用一个vis数组来记录节点是否存在，若存在，再根据其是否等于父节点（即该节点是否是根），给sum+1, 若最后sum&#x3D;&#x3D;1,则是树，否则不是树。</p><p>3.空集合是树，即输入为 0 0 的情况。因此需要额外判断。</p><p>易错点</p><p>气死我了，输出样例最后句子有个小数点，但我没注意，结果一直反复查看代码哪里出错了，(╯▔皿▔)╯。另外，该题<strong>不能用两个while循环来读取数据，会一直超时</strong>。也不知道啥原因。所以只能用一个while循环来写，若遍历到了0 0，则调用isAtree()函数判断是否是树，再用initial()函数重置数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10005</span>], vis[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>,index = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findp</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> r = a;</span><br><span class="line">    <span class="keyword">while</span>(r != f[r])&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x =a, y;</span><br><span class="line">    <span class="keyword">while</span>(f[x] != r)&#123;</span><br><span class="line">        y = f[x];</span><br><span class="line">        f[x] = r;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    f[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initial</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10005</span>; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isAtree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>, index++);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10005</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[i] == i)&#123;</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">1</span> || !ok)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is a tree.\n&quot;</span>, index++);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>, index++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    initial();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">-1</span> &amp;&amp; b == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)&#123;</span><br><span class="line">            isAtree();</span><br><span class="line">            initial();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vis[a] = <span class="number">1</span>;</span><br><span class="line">            vis[b] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[b] != b || a == b)&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> fa = findp(a);</span><br><span class="line">            <span class="type">int</span> fb = findp(b);</span><br><span class="line">            <span class="keyword">if</span>(fa != fb)&#123;</span><br><span class="line">                merge(fa, fb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术总结03-Aop</title>
      <link href="/2024/11/08/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9303-Aop/"/>
      <url>/2024/11/08/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9303-Aop/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring技术总结03-Aop"><a href="#Spring技术总结03-Aop" class="headerlink" title="Spring技术总结03-Aop"></a>Spring技术总结03-Aop</h1><h2 id="一、什么是Aop"><a href="#一、什么是Aop" class="headerlink" title="一、什么是Aop"></a>一、什么是Aop</h2><p>AOP：Aspect Oriented Programming面向切面编程。</p><p>AOP利用的是一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>AOP技术包含了切点表达式和增强方法的知识点。</p><h2 id="二、切点表达式和增强方法"><a href="#二、切点表达式和增强方法" class="headerlink" title="二、切点表达式和增强方法"></a>二、切点表达式和增强方法</h2><p>增强方法用于获取调用切面类的类信息，可以根据其信息进行添加独特的功能。</p><h3 id="1-增强方法"><a href="#1-增强方法" class="headerlink" title="1.增强方法"></a>1.增强方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.定义增强方法</span></span><br><span class="line"><span class="comment"> * 2.使用注解指定对应的方法      @After等</span></span><br><span class="line"><span class="comment"> * 3.配置切点表达式中的方法     在增强方法的注解上配置</span></span><br><span class="line"><span class="comment"> * 4.切面和ioc配置        在类前面添加相应的注解@Component @Aspect</span></span><br><span class="line"><span class="comment"> * 5.开启aspectj注解的支持    在配置类或者配置文件中开启</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span>实践获取目标类的信息</span></span><br><span class="line"><span class="comment"> *      1.全部增强方法中，获取目标方法的信息(方法名，参数，访问修饰符，所属类的信息)</span></span><br><span class="line"><span class="comment"> *          在增强方法的参数中添加JoinPoint形参，该参数包含了目标类的信息</span></span><br><span class="line"><span class="comment"> *      2.返回的结果</span></span><br><span class="line"><span class="comment"> *          增强方法的参数列表中添加(Object result)</span></span><br><span class="line"><span class="comment"> *          在@AfterReturning(value = &quot;execution()&quot;, returning = &quot;result&quot;)中添加returing=&quot;形参名&quot;接收返回结果</span></span><br><span class="line"><span class="comment"> *      3.异常的信息</span></span><br><span class="line"><span class="comment"> *          增强方法的参数列表中添加(Throwable throwable)</span></span><br><span class="line"><span class="comment"> *          在@AfterThrowing(value = &quot;execution()&quot;, throwing = &quot;throwable&quot;)中添加throwing=&quot;形参名&quot;接收返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(15)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdivce</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="comment">//获取方法参数列表</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法参数列表：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//获取方法的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法名称：&quot;</span>+ name);</span><br><span class="line">        <span class="comment">//获取方法的访问修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> joinPoint.getSignature().getModifiers();</span><br><span class="line">        <span class="type">String</span> <span class="variable">modifer</span> <span class="operator">=</span> Modifier.toString(modifiers);</span><br><span class="line">        System.out.println(<span class="string">&quot;访问修饰符：&quot;</span>+ modifer);</span><br><span class="line">        <span class="comment">//获取方法所属类的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法所属类：&quot;</span>+className);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.ldy.service.impl.*.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object result)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法返回值：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.ldy.service.impl.*.*(..))&quot;,throwing = &quot;throwable&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable throwable)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法异常对象：&quot;</span>+ throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Around(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="comment">//    public void around()&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用注解来创建ioc容器对象</span></span><br><span class="line"><span class="comment">//      要求依赖： spring-text</span></span><br><span class="line"><span class="comment">//@SpringJUnitConfig(value= , location= )</span></span><br><span class="line"><span class="comment">//      value: 指定配置类</span></span><br><span class="line"><span class="comment">//      location: 指定配置文件</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = Config.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用注解自动获取ioc容器中的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//若多个类实现某个接口，代理时可以加@Qualifier指定代理的对象</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;demo2&quot;)</span></span><br><span class="line">    <span class="comment">//若不指定，则根据变量名来选对应的代理对象，即demo选Demo,demo2选Demo2</span></span><br><span class="line">    <span class="keyword">public</span> DemoService demo;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> Calculate calculate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        方法参数列表：[1, 2]</span></span><br><span class="line"><span class="comment">        方法名称：div</span></span><br><span class="line"><span class="comment">        访问修饰符：public abstract</span></span><br><span class="line"><span class="comment">        方法所属类：com.ldy.service.impl.Demo</span></span><br><span class="line"><span class="comment">        方法返回值：-1</span></span><br><span class="line"><span class="comment">        div=-1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> demo.div(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;div=&quot;</span> + div);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        方法参数列表：[1, 0]</span></span><br><span class="line"><span class="comment">        方法名称：chu</span></span><br><span class="line"><span class="comment">        访问修饰符：public abstract</span></span><br><span class="line"><span class="comment">        方法所属类：com.ldy.service.impl.Demo</span></span><br><span class="line"><span class="comment">        方法异常对象：java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//        int chu = demo.chu(1, 0);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;chu=&quot; + chu);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> calculate.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;add=&quot;</span>+add);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-切点表达式"><a href="#2-切点表达式" class="headerlink" title="2.切点表达式"></a>2.切点表达式</h3><p> 切点表达式语法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span>切点表达式</span></span><br><span class="line"><span class="comment">*       固定语法： execution(&quot;1 2 3 4 5 6&quot;)</span></span><br><span class="line"><span class="comment">*           1: 访问修饰符</span></span><br><span class="line"><span class="comment">*               public/private</span></span><br><span class="line"><span class="comment">*           2: 返回参数类型</span></span><br><span class="line"><span class="comment">*               int/void/...</span></span><br><span class="line"><span class="comment">*           细节: * 代表任意修饰符和返回参数类型，但不能独立表示其中一个，即不能 * int</span></span><br><span class="line"><span class="comment">*           3: 包名</span></span><br><span class="line"><span class="comment">*               具体: com.ldy.service.impl</span></span><br><span class="line"><span class="comment">*               单层模糊: com.ldy.service.*  *单层模糊</span></span><br><span class="line"><span class="comment">*               多层模糊: com..impl   ..多层模糊</span></span><br><span class="line"><span class="comment">*               细节: 不能..开头</span></span><br><span class="line"><span class="comment">*               查询所有包下的impl包  *..impl</span></span><br><span class="line"><span class="comment">*               全部包: *..</span></span><br><span class="line"><span class="comment">*           4: 类名</span></span><br><span class="line"><span class="comment">*               具体: DemoService</span></span><br><span class="line"><span class="comment">*               部分模糊: Demo*   表示以Demo开头的所有类</span></span><br><span class="line"><span class="comment">*               模糊: *</span></span><br><span class="line"><span class="comment">*           5: 方法名  与类名一致</span></span><br><span class="line"><span class="comment">*           6: 方法参数</span></span><br><span class="line"><span class="comment">*               具体: (String, int)</span></span><br><span class="line"><span class="comment">*               部分模糊: (String..)  String后面有没有都无所谓</span></span><br><span class="line"><span class="comment">*               模糊: (..)</span></span><br><span class="line"><span class="comment">*       实战:</span></span><br><span class="line"><span class="comment">*           1.全部包下的impl包的所有参数为int的方法</span></span><br><span class="line"><span class="comment">*               * *..impl.*.*(int)</span></span><br><span class="line"><span class="comment">*           2.某包某类下，访问修饰符公有的，返回值类型是int的全部方法，</span></span><br><span class="line"><span class="comment">*               public int xx.xx.jj.*(..)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">*       切点表达式的提取和复用</span></span><br><span class="line"><span class="comment">*           法1.当前类中定义空方法</span></span><br><span class="line"><span class="comment">*               添加注解@Pointcut()里面传要复用的切点表达式 @Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line"><span class="comment">*           法2.创建一个存储切点的类</span></span><br><span class="line"><span class="comment">*               增强方法的注解里写存储切点类的 全类名.方法名()</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h2 id="三、依赖和注解介绍"><a href="#三、依赖和注解介绍" class="headerlink" title="三、依赖和注解介绍"></a>三、依赖和注解介绍</h2><h3 id="aspectj依赖"><a href="#aspectj依赖" class="headerlink" title="aspectj依赖"></a><strong>aspectj依赖</strong></h3><p>在新的子类工程的pom文件里添加aspectj依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a><strong>注解介绍</strong></h3><h4 id="1-Aspect"><a href="#1-Aspect" class="headerlink" title="1.@Aspect"></a>1.<strong>@Aspect</strong></h4><p>作用于类上，声明该类为切面类</p><h4 id="2-Component"><a href="#2-Component" class="headerlink" title="2.@Component"></a>2.<strong>@Component</strong></h4><p>作用于类上，使得该切面类能放到ioc容器</p><h4 id="3-Order"><a href="#3-Order" class="headerlink" title="3.@Order"></a>3.<strong>@Order</strong></h4><p>作用于类上，用于声明切面类的优先级，数字越小级别越优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(10)</span></span><br></pre></td></tr></table></figure><h4 id="4-Pointcut"><a href="#4-Pointcut" class="headerlink" title="4.@Pointcut"></a>4.@Pointcut</h4><p>@Pointcut作用于空方法上，为其他方法提供切点表达式。</p><h4 id="4-切面类的方法上的注解"><a href="#4-切面类的方法上的注解" class="headerlink" title="4.切面类的方法上的注解"></a>4.切面类的方法上的注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*       使用注解配置</span><br><span class="line">*           前置  <span class="meta">@Before</span></span><br><span class="line">*           后置  <span class="meta">@AfterReturning</span></span><br><span class="line">*           最后  <span class="meta">@After</span></span><br><span class="line">*           异常  <span class="meta">@AfterThrowing</span></span><br><span class="line">*           环绕  <span class="meta">@Around</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这些注解可以指定切点表达式，也可以引用本类或其他类的切点表达式。</p><p>直接指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure><p>引用本类的切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">//该类中的表达式提取</span></span><br><span class="line"><span class="meta">@Before(&quot;pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;事务开启&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用其他类中的切点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类中切点表达式提取</span></span><br><span class="line"><span class="meta">@After(&quot;com.ldy.pointcut.MyPointcut.all())</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void after()&#123;</span></span><br><span class="line"><span class="string">    System.out.println(&quot;</span>事务结束<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>被引用的切点类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPointcut</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* *..impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">impl</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-EnableAspectJAutoProxy"><a href="#5-EnableAspectJAutoProxy" class="headerlink" title="5.@EnableAspectJAutoProxy"></a>5.@EnableAspectJAutoProxy</h4><p>作用于配置类上面，用于开启Aspectj注解支持</p><h2 id="四、实操"><a href="#四、实操" class="headerlink" title="四、实操"></a>四、实操</h2><p>简单实操如下</p><h3 id="1-配置类"><a href="#1-配置类" class="headerlink" title="1.配置类"></a>1.配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&#123;&quot;com.ldy.service&quot;, &quot;com.ldy.advice&quot;,&quot;com.ldy.pointcut&quot;&#125;)</span></span><br><span class="line"><span class="comment">//开启支持Aspectj的注解配置</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAspectAutoProxy用于开启Aspectj的注解支持</p><h3 id="2-切面类"><a href="#2-切面类" class="headerlink" title="2.切面类"></a>2.切面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   增强类的内部存储增强代码</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*      1.定义方法存储增强代理</span></span><br><span class="line"><span class="comment">*           具体定义几个根据实际需要</span></span><br><span class="line"><span class="comment">*       2.使用注解配置</span></span><br><span class="line"><span class="comment">*           前置  @Before</span></span><br><span class="line"><span class="comment">*           后置  @AfterReturning</span></span><br><span class="line"><span class="comment">*           最后  @After</span></span><br><span class="line"><span class="comment">*           异常  @AfterThrowing</span></span><br><span class="line"><span class="comment">*           环绕  @Around</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="comment">//@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myaop</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法报错了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Service类"><a href="#3-Service类" class="headerlink" title="3.Service类"></a>3.Service类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ldy.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ldy.service.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试类"><a href="#4-测试类" class="headerlink" title="4.测试类"></a>4.测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">        <span class="type">DemoService</span> <span class="variable">demo</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;demo&quot;</span>, DemoService.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> demo.div(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;div=&quot;</span> + div);</span><br><span class="line"><span class="comment">//        int chu = demo.chu(2, 0);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;chu=&quot; + chu);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo02</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Aop的实现原理"><a href="#五、Aop的实现原理" class="headerlink" title="五、Aop的实现原理"></a>五、Aop的实现原理</h2><p>2024&#x2F;12&#x2F;6 突然想起aop的实现原理</p><p>静态代理和动态代理可参考以下文章，有空再用自己的语言整理整理</p><p><a href="https://blog.csdn.net/xiaojin21cen/article/details/79487769">AOP的实现原理 —— 静态代理 和 动态代理（ Spring AOP）_aspectj 静态代理-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring java ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术总结02-IoC</title>
      <link href="/2024/10/31/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9302-IoC/"/>
      <url>/2024/10/31/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9302-IoC/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring技术总结02-IoC"><a href="#Spring技术总结02-IoC" class="headerlink" title="Spring技术总结02-IoC"></a>Spring技术总结02-IoC</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p> Ioc：Inverse of Control的简写，为 控制反转，指把创建对象交给Spring进行管理。即不通过new 对象的方式在dao、service等Impl类中获取对象，而是通过读取<strong>xml文件</strong>或者<strong>配置类</strong>的方式创建一个统一管理所有对象的<strong>ApplicationContext类</strong>，通过**getBean()**的方法获取所需对象。</p><p>Spring中的IoC容器就是IoC思想的一个落地产品实现。IoC容器中管理的组件也叫做bean。</p><h2 id="二、基于xml方式管理bean"><a href="#二、基于xml方式管理bean" class="headerlink" title="二、基于xml方式管理bean"></a>二、基于xml方式管理bean</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h3><p>1.根据上一篇文章，已经按要求重新创建了一个项目。</p><p><img src="/../images/image-20241031163048915.png" alt="image-20241031163048915"></p><p>2.创建实体类和xml配置文件</p><p>配置文件创建方式如下图</p><p><img src="/../images/image-20241031164148051.png" alt="image-20241031164148051"></p><p>实体类创建</p><p><img src="/../images/image-20241031165746906.png" alt="image-20241031165746906"></p><p><img src="/../images/image-20241031165803766.png" alt="image-20241031165803766"></p><p><img src="/../images/image-20241031165824485.png" alt="image-20241031165824485"></p><h3 id="2-管理bean对象——基本操作"><a href="#2-管理bean对象——基本操作" class="headerlink" title="2.管理bean对象——基本操作"></a>2.管理bean对象——基本操作</h3><p>在spring01.xml上编写语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.通过无参构造函数创建实例化的组件，配置方法</span></span><br><span class="line"><span class="comment">    &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span></span><br><span class="line"><span class="comment">        id: 组件的标识，自定义名字，方便读取对象</span></span><br><span class="line"><span class="comment">        class: 组件的全限定符，即全类名</span></span><br><span class="line"><span class="comment">`   默认是单例模式，声明两个相同的组件信息，会实例化两个组件对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.bean.User&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.基本属性注入</span></span><br><span class="line"><span class="comment">    在bean标签中添加&lt;property name=&quot;&quot; value/ref=&quot;&quot; &gt;标签</span></span><br><span class="line"><span class="comment">            name:组件set方法去掉set后面一个字母小写的规则命名，例如setName -&gt; name</span></span><br><span class="line"><span class="comment">            value: 直接赋值即可，注意传值类型</span></span><br><span class="line"><span class="comment">            ref: 其他组件的id</span></span><br><span class="line"><span class="comment">    注意：若set方法中的参数是基本类型，用value直接赋值，若是其他类，要用ref取相应的id。</span></span><br><span class="line"><span class="comment">         在组件中一定要给属性注入的属性添加set方法！！！</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.bean.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;白小纯&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--3.对象类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;user2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--4.构造器属性注入 </span></span><br><span class="line"><span class="comment">      &lt;constructor-arg 进行DI配置</span></span><br><span class="line"><span class="comment">          value : 直接赋值</span></span><br><span class="line"><span class="comment">          ref : 所要引用对象的bean的id</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--多参数构造器的情况</span></span><br><span class="line"><span class="comment">            三种方式</span></span><br><span class="line"><span class="comment">                1.按构造器的参数默认顺序配置</span></span><br><span class="line"><span class="comment">                2.按构造器的参数的参数名定位赋值</span></span><br><span class="line"><span class="comment">                3. 按构造器的参数的索引值定位赋值，从0开始</span></span><br><span class="line"><span class="comment">以下的实现在上述实体类中并没有设置，从之前的文件复制修改的，了解即可</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.按构造器的参数默认顺序配置   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ggbone&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.按构造器的参数的参数名定位赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ggbone&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3. 按构造器的参数的索引值定位赋值，从0开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ggbone&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们写一个测试类进行测试，看看是否能成功获取对象并执行方法。</p><p>测试时的ioc容器对象创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    创建ioc容器</span></span><br><span class="line"><span class="comment">//    有四个实现类，最常用的是ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">推荐创建方式， new 实现类(String...),传入一个或多个ioc配置文件名称</span></span><br><span class="line"><span class="comment">配置文件的名称是根据编译后的target文件中的的classes进行查找的，由于resources下面直接创建了xml文件</span></span><br><span class="line"><span class="comment">，所以相对应的classes下直接有相应的xml文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-03.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取Bean对象</span></span><br><span class="line"><span class="comment">//方法1,只传入bean的id名，需要强转，不推荐</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)applicationContext.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"><span class="comment">//方法2，传入bean的id和相应的Class类</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line"><span class="comment">//方法3， 只传入要获取的类的Class</span></span><br><span class="line"><span class="comment">//要求：</span></span><br><span class="line"><span class="comment">//   使用该方法必须在配置文件里，有且只能有该类的一个Bean，不能有多个</span></span><br><span class="line"><span class="comment">//   若多个，则报异常 NoUniqueBeanDefinitionException</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line"><span class="comment">//此外，可以通过该类的父类的Class获取对象</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> applicationContext.getBean(Animal.class);</span><br></pre></td></tr></table></figure><p>推荐在test文件夹下面创建测试类，如下图所示。</p><p><img src="/../images/image-20241031184949948.png" alt="image-20241031184949948"></p><p>这里我们可以看到成功的获取了对象和实现了相应的方法</p><p><img src="/../images/image-20241031185027013.png" alt="image-20241031185027013"></p><h3 id="3-其他细节内容"><a href="#3-其他细节内容" class="headerlink" title="3.其他细节内容"></a>3.其他细节内容</h3><p>以下代码均是之前学习时的产物，没必要重新写了，就复制过来了</p><p>1.bean标签的属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    类似tomcat的servlet的生命周期</span></span><br><span class="line"><span class="comment">            init-method: 在该对象创建后就调用指定的对象的一个函数，必须是无参、public且返回值为void</span></span><br><span class="line"><span class="comment">            destory-mothod: 该对象销毁时调用的方法，要求同上</span></span><br><span class="line"><span class="comment">            注意：简而言之就是一旦管理这个bean的类被创建后就会调用init-method,类close()后就会调用destory-method。与通过getBean()获取对象无关，因为bean对象早就创建了，这只是引用创建的对象而已。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    scope属性指定该Bean每次被Ioc容器对象使用getBean()方法获取后是否是单例的</span></span><br><span class="line"><span class="comment">            prototype: 多例</span></span><br><span class="line"><span class="comment">            singleton: 单例， 默认值</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            容器管理范围:</span></span><br><span class="line"><span class="comment">                单例模式下的 Bean 由 Spring 容器管理其整个生命周期，包括创建和销毁。</span></span><br><span class="line"><span class="comment">                多例模式下的 Bean 由客户端代码管理其生命周期，Spring 容器仅负责创建。</span></span><br><span class="line"><span class="comment">            所以多例模式下的Bean在Ioc容器close()后不会被调用destroy-method</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;javaBean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.ioc04.JavaBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2.获取原始类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--.直接通过原始类赋值获取DataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.配置文件赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过配置文件赋值给原始类获取DataSource</span></span><br><span class="line"><span class="comment">      &lt;context:property-placeholder 引用配置文件 location=&quot;classpath:druid.properties&quot;指明配置文件在类路径下</span></span><br><span class="line"><span class="comment">      使用$&#123;变量名&#125;来获取配置文件中的属性值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:druid.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.url&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.配合注解进行包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--指定包下面进行注解扫描</span><br><span class="line">        base-package： 包名，该包以下的所有类和子包中的所有类都会被扫描</span><br><span class="line">--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.ldy&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="三、基于配置类的方式管理bean"><a href="#三、基于配置类的方式管理bean" class="headerlink" title="三、基于配置类的方式管理bean"></a>三、基于配置类的方式管理bean</h2><p>Spring从2.5版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化Spring的xml配置。</p><p>Spring通过注解实现自动装配：</p><ol><li>引入依赖</li><li>开启组件扫描</li><li>使用注解定义Bean</li><li>依赖注入</li></ol><h3 id="1-注解介绍"><a href="#1-注解介绍" class="headerlink" title="1.注解介绍"></a>1.注解介绍</h3><p>基本的类上注解</p><p><img src="/../images/image-20241031192752509.png" alt="image-20241031192752509"></p><p><strong>@ComponentScan用于批量注册bean。</strong></p><p>这个注解会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器容器中。</p><p><strong>@Autowired注入</strong><br>        单独使用@Autowired注解，默认根据类型装配（byType）</p><p>@Autowired注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须存在，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在就注入，不存在也不报错。</p><p><strong>@Qualifier搭配@Autowired使用</strong></p><p>若@Autowired注入的类有多个实现类，需要指定某个实体类时，在@Autowired注解下面添加@Qualifier(“指定实现类的id”)来指定注入的实现类。</p><p><strong>@Resource整合了@Autowired和@Qualifier一起的功能</strong></p><ol><li>指定@Resource中的name，则根据名称装配</li><li>未指定name时，则根据属性名装配</li><li>未指定name，属性名也不一致，则根据类型装配</li></ol><p>使用该注解需要导入如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@PropertySource配置文件引用</strong></p><p>示例:@PropertySource(value&#x3D;”classpath:jdbc.properties”),与xml的配置文件路径写法一致。</p><h3 id="2-实际操作"><a href="#2-实际操作" class="headerlink" title="2.实际操作"></a>2.实际操作</h3><p><strong>1.简单操作</strong></p><p>创建配置类</p><p><img src="/../images/image-20241031195230545.png" alt="image-20241031195230545"></p><p>给各个组件添加注解，以下是其中一个类</p><p><img src="/../images/image-20241031195322823.png" alt="image-20241031195322823"></p><p>给之前写的类添加上上述注解之后，用AnnotationConfigApplicationContext获取ApplicationContext类进行测试。</p><p><img src="/../images/image-20241031194955240.png" alt="image-20241031194955240"></p><p><strong>2.详细内容</strong></p><p>之前所学习时的配置类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用配置类而不使用xml进行ioc容器的配置</span></span><br><span class="line"><span class="comment">   @Configuration   ioc配置类</span></span><br><span class="line"><span class="comment">   @@ComponentScan   包扫描</span></span><br><span class="line"><span class="comment">   @PropertySource    配置文件引用</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.ldy&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value=&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfigure</span> &#123;</span><br><span class="line">    <span class="comment">//  bean由@Bean注解标注，并且对象类型为方法返回的类型，id默认为方法名</span></span><br><span class="line">    <span class="comment">//  配置文件的Di配置由参数（注解+参数声明）来获取配置参数，以便进行依赖注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;xxx.url&#125;&quot;)</span> String url, <span class="meta">@Value(&quot;$&#123;xxx.driverClassName&#125;&quot;)</span> String driverClassName,<span class="meta">@Value(&quot;$&#123;xxx.username&#125;&quot;)</span> String username, <span class="meta">@Value(&quot;$&#123;xxx.password&#125;&quot;)</span> String password)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//    配置类的Di中，参数作为方法参数被传入</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。用注解配置还是很方便的。</p>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring java ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术总结01-环境搭建</title>
      <link href="/2024/10/29/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9301-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/10/29/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9301-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring技术总结01-环境搭建"><a href="#Spring技术总结01-环境搭建" class="headerlink" title="Spring技术总结01-环境搭建"></a>Spring技术总结01-环境搭建</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Spring指的是Spring Framework，通常我们称之为Spring框架。Spring框架是一个分层的面向切面的Java应用程序的一站式解决框架，它是Spring技术栈的核心和基础，是为了解决企业级引用开发的复杂性而创建的。</p><p> Spring有两个核心模块：IoC和AOP。</p><p> Ioc：Inverse of Control的简写，为 控制反转，指把创建对象交给Spring进行管理。即不通过new 对象的方式在dao、service等Impl类中获取对象，而是通过xml文件或者配置类的方式统一管理所有对象，将所需对象注入到其他对象。其他</p><p> AOP：Aspect Oriented Programming 的简写，为 面向对象编程。AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP还解决一些系统层面上的问题，比如日志、事务、权限等。</p><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a><strong>1.创建项目</strong></h3><p>首先，使用Idea中maven这个中间件来创建一个项目。</p><p><img src="/../images/image-20241030183104957-17302943901662.png" alt="image-20241030183104957"></p><h3 id="2-检查Maven设置"><a href="#2-检查Maven设置" class="headerlink" title="2.检查Maven设置"></a><strong>2.检查Maven设置</strong></h3><p>创建完成之后，记得要查看Idea的settings中的Build,Execution,Deployment-&gt;Build Tools-&gt;Maven中的Maven home path,把其改为自己配置的maven文件夹路径，而不是idea默认自带的，然后检查User settings file 和local repository的路径是否正确，不正确要勾选Override进行修改。</p><p><img src="/../images/image-20241030183334305.png" alt="image-20241030183334305"></p><h3 id="3-导入基本依赖以及相关实用插件推荐"><a href="#3-导入基本依赖以及相关实用插件推荐" class="headerlink" title="3.导入基本依赖以及相关实用插件推荐"></a><strong>3.导入基本依赖以及相关实用插件推荐</strong></h3><p><strong>基本依赖项</strong></p><p>1.spring-context依赖。当spring-context依赖引入后，spring的基础依赖已经引入了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.junit5测试依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.11.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>插件推荐</strong></p><p>1.JBLJavaToWeb插件。方便创建web项目。</p><p><img src="/../images/image-20241030193153121.png" alt="image-20241030193153121"></p><p>在项目根文件夹上右键会出现JBLJavaToWeb选项，点击之后，会自动将项目改为web工程项目。</p><p><img src="/../images/image-20241030193425685.png" alt="image-20241030193425685"></p><p>即在src文件下添加webapps文件夹</p><p><img src="/../images/image-20241030194249420.png" alt="image-20241030194249420"></p><p>并在项目的pom.xml文件里设置packing标签内容为war</p><p><img src="/../images/image-20241030194424280.png" alt="image-20241030194424280"></p><p>2.maven-search插件。该插件可以搜索依赖，选择所需依赖的版本，复制依赖的导入语句，省去了去官网查询依赖的麻烦。</p><p><img src="/../images/image-20241030200033114.png" alt="image-20241030200033114"></p><p>使用方法，在Idea上方导航栏的Tools中的Maven Serach选项。</p>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring java ioc aop tx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线音乐播放器项目03</title>
      <link href="/2024/10/11/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE03/"/>
      <url>/2024/10/11/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE03/</url>
      
        <content type="html"><![CDATA[<h1 id="在线音乐播放器项目03"><a href="#在线音乐播放器项目03" class="headerlink" title="在线音乐播放器项目03"></a>在线音乐播放器项目03</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于网页移植，原本是想把学的音乐播放器移植到原来写的代码中，但经过该音乐播放器的html、css代码学习后，发现自己原来的页面代码写的依托，结构比较混乱，故我决定抛弃原来的页面，转而针对当前音乐播放器的页面进行更改和重新设计。</p><h3 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h3><h4 id="一-页面设计"><a href="#一-页面设计" class="headerlink" title="一.页面设计"></a>一.页面设计</h4><p>1.将原有的界面进行了扩展，增加了播放设置和音量调节功能，并且将其移动至页面下方。</p><p><img src="/../images/image-20241011205539766.png" alt="image-20241011205539766"></p><p>2.增加了侧边导航栏进行功能扩展。</p><p><img src="/../images/image-20241011205618172.png" alt="image-20241011205618172"></p><p>3.搜索功能的展现与音乐列表展开的实现原理一致，将其放在页面左边。同时实现了交互，异步通过后端爬虫获取歌曲数据。</p><p><img src="/../images/image-20241011205741029.png" alt="image-20241011205741029"></p><p><img src="/../images/image-20241011211226658.png" alt="image-20241011211226658"></p><h4 id="二、音乐信息爬取"><a href="#二、音乐信息爬取" class="headerlink" title="二、音乐信息爬取"></a>二、音乐信息爬取</h4><p>原本我想爬取音乐搜索器来进行音乐数据的爬取，以为它已经实现了网易云音乐数据的爬取，但它的内容是动态加载的，需要使用动态爬取的方式，效率低，而且我只能爬到搜索到的第一首歌曲的具体信息，其他的歌曲我看了源码没有找到可以获取的数据，此外，我的爬虫只能爬取英文歌曲和部分中文歌曲，查了很多信息，不知道为什么，一些中文歌曲在爬取时不能成功爬取，明明网址是对的，自己输入可以正常访问，考虑到了编码问题，但还是没发现问题出在哪里。</p><p>所以我打算重新设计爬虫，直接爬取网易云的，但目前爬虫教程都是python爬取网易云，所以我准备学习python的爬取方式再将思想移植到java爬虫里。</p><p>原来的想法代码展示。</p><p><img src="/../images/image-20241011210651630.png" alt="image-20241011210651630"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在实现音乐信息爬取以及相关交互bug的修复后，对于后面页面的功能扩展和页面新增的进度会变得缓慢，我想还是先学习更多的前后端·知识之后再来进行实现。哎，实现这个项目还是要挺多知识，感觉自己学了挺多，但做起来还是好多东西要学。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> 音乐播放器 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线音乐播放器项目02</title>
      <link href="/2024/10/01/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE02/"/>
      <url>/2024/10/01/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE02/</url>
      
        <content type="html"><![CDATA[<h1 id="在线音乐播放器项目02"><a href="#在线音乐播放器项目02" class="headerlink" title="在线音乐播放器项目02"></a>在线音乐播放器项目02</h1><h3 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h3><h5 id="1-初步构建了上方导航栏，以及实现了搜索联想功能-如下图所示。"><a href="#1-初步构建了上方导航栏，以及实现了搜索联想功能-如下图所示。" class="headerlink" title="1.初步构建了上方导航栏，以及实现了搜索联想功能,如下图所示。"></a>1.初步构建了上方导航栏，以及实现了搜索联想功能,如下图所示。</h5><p><img src="/../images/image-20241001003911303.png" alt="image-20241001003911303"></p><p>通过看之前的javaweb项目重新复习一遍了搜索联想功能的实现。</p><h5 id="2-设置了分页查询功能。"><a href="#2-设置了分页查询功能。" class="headerlink" title="2.设置了分页查询功能。"></a>2.设置了分页查询功能。</h5><p>这次的分页查询并没有像之前的web项目一样，通过每次点击相应的图标而发送请求到servlet中进行交互，而是通过vue的帮助，实现了一次获取数据即可实现分页查询功能，很是方便。</p><h5 id="3-重新设计了音乐播放器的显示"><a href="#3-重新设计了音乐播放器的显示" class="headerlink" title="3.重新设计了音乐播放器的显示"></a>3.重新设计了音乐播放器的显示</h5><p>由于html自带的audio标签的样式不是很好看，所以查找了各种信息，最终在B站找到了一个很不错的视频，通过该视频的学习，在另一个网页初步构建了新的音乐播放器，后续会完成该播放器其余内容后将其移植到当前的音乐播放器项目里。如下图所示。</p><p><img src="/../images/image-20241001004512225.png" alt="image-20241001004512225"></p><p>学习视频链接【HTML+CSS3+JS实现音乐播放器项目】<a href="https://www.bilibili.com/video/BV1tj411N7SH?vd_source=ad14811b0629f215912c584fbe9d9875%E8%BF%99%E4%B8%AA%E8%A7%86%E9%A2%91%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%94%B6%E8%8E%B7%E7%9B%B8%E5%BD%93%E5%A4%9A%EF%BC%8C%E8%AE%A9%E6%88%91%E5%AF%B9%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%9C%89%E4%BA%86%E6%96%B0%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E4%B8%8E%E8%A7%84%E8%8C%83%E3%80%82">https://www.bilibili.com/video/BV1tj411N7SH?vd_source=ad14811b0629f215912c584fbe9d9875这个视频可以说收获相当多，让我对网页布局有了新的认识和更好的写代码逻辑与规范。</a></p><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>我先把分页查询功能完善后，晚点再写吧。</p><p>2024&#x2F;10&#x2F;7</p><h5 id="一、自定义音乐播放器交互功能实现流程："><a href="#一、自定义音乐播放器交互功能实现流程：" class="headerlink" title="一、自定义音乐播放器交互功能实现流程："></a>一、自定义音乐播放器交互功能实现流程：</h5><p>1.先通过ajax将音乐数据从数据库中读取出来存入变量musiclist中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.加载音乐列表信息</span></span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/mvn01/test&quot;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        musiclist = data;</span><br><span class="line">        <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">       <span class="title function_">renderMusicList</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.在点击播放按钮后，除了要播放当前音乐外，还需要将页面背景和音乐信息卡片的内容进行更改，由于该功能具有复用性，所以需要新建加载函数来实现相应的内容更改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据信息，设置页面对应的标签内容</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;.name&quot;</span>).<span class="title function_">text</span>(data.<span class="property">name</span>);</span><br><span class="line">    $(<span class="string">&quot;.singer&quot;</span>).<span class="title function_">text</span>(data.<span class="property">singer</span>);</span><br><span class="line">    $(<span class="string">&quot;.time&quot;</span>).<span class="title function_">text</span>(data.<span class="property">time</span>);</span><br><span class="line">    $(<span class="string">&quot;.cover img&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, data.<span class="property">cover</span>);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, data.<span class="property">audio_url</span>);</span><br><span class="line">    $(<span class="string">&quot;.mask_bg&quot;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">        <span class="attr">background</span>: <span class="string">`url(&quot;<span class="subst">$&#123;data.cover&#125;</span>&quot;) no-repeat center center`</span>,</span><br><span class="line">        <span class="string">&quot;background-size&quot;</span> : <span class="string">&quot;cover&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>给播放按钮添加点击事件时需要考虑当前的播放状态，一开始的想法是判断当前的播放图标来更改音乐的播放与暂停，但在实现音乐的上一首和下一首的功能时，若当前是播放，会出现下一首显示图标暂停，下下一首显示播放，而实际上都是在播放的问题，因为audio在更换音乐源时，图标没有继续更改。所以为了方便，发现了可以用audio的paused属性<code>$(&quot;audio&quot;).get(0).paused</code> 可以告知音乐是否暂停，若暂停，则返回true。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给播放按钮添加点击事件</span></span><br><span class="line">$(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.判断当前播放状态</span></span><br><span class="line">    <span class="keyword">if</span>($(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="property">paused</span>)&#123;</span><br><span class="line">        <span class="comment">//修改播放状态</span></span><br><span class="line">        isplay = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//0.改变播放图标状态</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/暂停.png&quot;</span>);</span><br><span class="line">        <span class="comment">//1.音乐播放</span></span><br><span class="line"></span><br><span class="line">        $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">play</span>();</span><br><span class="line">        <span class="comment">//2.动态显示卡片信息</span></span><br><span class="line">        $(<span class="string">&quot;.player-info&quot;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">            <span class="attr">top</span>: <span class="string">&#x27;-100%&#x27;</span>,</span><br><span class="line">            <span class="attr">opacity</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;slow&quot;</span>);</span><br><span class="line">        <span class="comment">//3.封面旋转起来</span></span><br><span class="line">        $(<span class="string">&quot;.cover&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;animation-play-state&quot;</span>, <span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//修改播放状态</span></span><br><span class="line">        isplay = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//0.改变播放图标状态</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/播放.png&quot;</span>);</span><br><span class="line">        <span class="comment">//1.音乐暂停播放</span></span><br><span class="line">        $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">pause</span>();</span><br><span class="line">        <span class="comment">//2.动态显示卡片信息</span></span><br><span class="line">        $(<span class="string">&quot;.player-info&quot;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">                <span class="attr">top</span>: <span class="string">&#x27;0%&#x27;</span>,</span><br><span class="line">                <span class="attr">opacity</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;slow&quot;</span>);</span><br><span class="line">        <span class="comment">//3.封面旋转暂停</span></span><br><span class="line">        $(<span class="string">&quot;.cover&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;animation-play-state&quot;</span>, <span class="string">&quot;paused&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.播放后重新渲染音乐列表</span></span><br><span class="line">    <span class="title function_">renderMusicList</span>(musiclist);</span><br></pre></td></tr></table></figure><p>4.实现上一首和下一首播放时，要注意变量的范围，不能一直加也不能一直减，所以要对音乐索引的临界点进行判定。此外再调用render函数和触发播放按钮的点击事件来进行音乐的播放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给上一首按钮绑定事件</span></span><br><span class="line">$(<span class="string">&quot;#prevBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.当前播放音乐索引减一</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        currentIndex --;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//若是第一首，则跳转至最后一首</span></span><br><span class="line">        currentIndex = musiclist.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.调用render函数  重新渲染歌曲信息</span></span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//3.让音乐播放  触发播放按钮事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//给下一首按钮绑定事件</span></span><br><span class="line">$(<span class="string">&quot;#nextBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.当前播放音乐索引加一</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex &lt; musiclist.<span class="property">length</span> - <span class="number">1</span>)&#123;</span><br><span class="line">        currentIndex ++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//若是最后一首，则跳转至第一首</span></span><br><span class="line">        currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.调用render函数  重新渲染歌曲信息</span></span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//3.让音乐播放  触发播放按钮事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.实现音乐播放列表的显示时，我们需要动态的实时更新音乐列表，所以要创建一个可复用的函数renderMusicList()以便播放状态信息的实时更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据音乐列表创建li</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderMusicList</span>(<span class="params">list</span>)&#123;</span><br><span class="line">    <span class="comment">//先清空列表</span></span><br><span class="line">    $(<span class="string">&quot;.music-list&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line">    $.<span class="title function_">each</span>(list, <span class="keyword">function</span>(<span class="params">index, item</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> $li = $(<span class="string">`</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;<span class="subst">$&#123;currentIndex == index ? <span class="string">&quot;playing&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;span&gt;<span class="subst">$&#123;index+<span class="number">1</span> &lt; <span class="number">10</span>? <span class="string">&quot;0&quot;</span>+(index +<span class="number">1</span>) : index + <span class="number">1</span>&#125;</span>.<span class="subst">$&#123;item.name&#125;</span>-<span class="subst">$&#123;item.singer&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">                &lt;span data-index=&quot;<span class="subst">$&#123;index&#125;</span>&quot;&gt;&lt;img class=&quot;play-circle&quot; src=&quot;<span class="subst">$&#123;currentIndex == index &amp;&amp; !$(<span class="string">&quot;audio&quot;</span>).get(<span class="number">0</span>).paused ? <span class="string">&#x27;image/icon/暂停.png&#x27;</span>: <span class="string">&#x27;image/icon/播放.png&#x27;</span>&#125;</span>&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;/li&gt;</span></span><br><span class="line"><span class="string">        `</span>);</span><br><span class="line">        <span class="comment">//重新加载列表</span></span><br><span class="line">        $(<span class="string">&#x27;.music-list&#x27;</span>).<span class="title function_">append</span>($li);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数所用的地方有 列表图标的点击事件、音乐列表中的播放按钮点击事件、主界面播放按钮的点击事件。主界面播放按钮的点击事件用到的地方多，涵盖了音乐列表信息更新所要关联的地方，方便实现动态更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给音乐列表绑定事件</span></span><br><span class="line">$(<span class="string">&quot;#openModal&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;.modal&quot;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">            <span class="string">&quot;display&quot;</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_">renderMusicList</span>(musiclist);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//给音乐列表按钮添加点击事件</span></span><br><span class="line">$(<span class="string">&quot;.music-list&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;li span&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//修改当前音乐索引</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;data-index&#x27;</span>))&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        currentIndex = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;data-index&quot;</span>);</span><br><span class="line">        <span class="comment">//先设置标签内容</span></span><br><span class="line">        <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再触发播放功能</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>6.顺序播放、随机播放和单曲循环的实现。该功能应该位于音乐播放结束时实现，所以要监听audio的ended状态，由于在添加移除监听事件需要指定移除的函数，否则无效，所以不能用匿名函数来添加点击事件，所以只能创建相应的函数来进行监听事件的更改。每次点击播放设置图标时，会移除监听audio的上一个事件，再添加当前事件。目前还未实现在随机播放状态下点击下一首时实现随机播放的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给音乐播放设置按钮绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#setBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/随机播放.png&quot;</span>);</span><br><span class="line">        <span class="title class_">RadPlay</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/单曲循环.png&quot;</span>);</span><br><span class="line">        <span class="title class_">CirPlay</span>();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/顺序播放.png&quot;</span>);</span><br><span class="line">        $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="title class_">SeqPlay</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//顺序播放</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SeqPlay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, cirplay);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;ended&quot;</span>, seqplay)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">seqplay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    currentIndex = currentIndex &gt; musiclist.<span class="property">length</span> - <span class="number">1</span> ? <span class="number">0</span> : currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//顺序播放直接出发下一首事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机播放</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RadPlay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, seqplay);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;ended&quot;</span>, radplay);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">radplay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//随机获取一个音乐索引</span></span><br><span class="line">    <span class="keyword">var</span> origin = currentIndex;</span><br><span class="line">    <span class="keyword">while</span>(origin == currentIndex)</span><br><span class="line">        currentIndex = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">100</span>) % musiclist.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">//重新渲染音乐信息</span></span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//触发点击事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CirPlay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, radplay);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;ended&quot;</span>, cirplay);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cirplay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>我觉得网页最难懂的就是css了，样式太多了，设计页面好麻烦。我对前端内容不是很熟悉，所以在调整css样式方面可以说是相当难受，就是调整不到自己想要的显示效果，因为很多css属性我都是一点不清楚，问ai也是牛头不对马脚。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> 音乐播放器 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线音乐播放器搭建项目01</title>
      <link href="/2024/09/26/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE01/"/>
      <url>/2024/09/26/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE01/</url>
      
        <content type="html"><![CDATA[<h1 id="在线音乐播放器搭建项目01"><a href="#在线音乐播放器搭建项目01" class="headerlink" title="在线音乐播放器搭建项目01"></a>在线音乐播放器搭建项目01</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在学了html,  css, javascript, tomcat，jdbc，jsp等内容之后，闲来无事,又学了maven和vue、mybatis的基础内容，想搭建一个在线音乐播放器的网站，希望是类似于qq音乐和网易云音乐之类的网页音乐播放页面，虽然是不可能的，但还是想着试着自己做一下这个项目来巩固自己所学的内容。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>基于maven项目管理工具，同时遵循JavaEE的MVC设计模式搭建该项目。</p><h4 id="项目文件各部分内容说明："><a href="#项目文件各部分内容说明：" class="headerlink" title="项目文件各部分内容说明："></a>项目文件各部分内容说明：</h4><p><strong>数据库</strong>：先把音乐的相关数据存入到数据库maven当中的music表里，目前包含了四种字段，id, name（其实是文件存放位置）, img（图片存放位置） 和 singer。后期肯定是会添加新的列的，但暂时就放这四个字段。</p><p><strong>java</strong>:基于javaEE的三层架构创建相应文件。</p><p><img src="/../images/image-20240926002554656.png" alt="image-20240926002554656"></p><p><strong>resources</strong>:存放所需配置文件。</p><p><img src="/../images/image-20240926002656127.png" alt="image-20240926002656127"></p><p><strong>webapp</strong>: 存放除了java源码外的其他文件。</p><p><img src="/../images/image-20240926002408273.png" alt="image-20240926002408273"></p><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>由于对前端代码的不熟悉，在构建页面，调整css属性，写js相关代码上面花了不少时间（设置布局好头疼）。</p><p>在找合适的标签进行绑定点击事件时，我一共试了三个标签 <code>&lt;input&gt; &lt;a&gt; 和 &lt;button&gt;</code>,由于input的value与显示的内容一致，button的按钮外观不好看。所以选择了a标签，将其name属性来存放歌曲存放位置信息，这与其展示的文本不冲突，所以很nice。</p><p>一开始我并没有通过vue来渲染页面，而是直接以静态的代码形式布局网页，所以一开始的这段添加点击事件的代码就行不通了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给超链接添加点击事件，由于a标签是动态渲染的，所以js里面的这个方法不能添加到新渲染的a标签中</span></span><br><span class="line"><span class="comment">// var as = document.getElementsByClassName(&quot;music_a&quot;);</span></span><br><span class="line"><span class="comment">// for(var i = 0; i &lt; as.length; i++)&#123;</span></span><br><span class="line"><span class="comment">//     as[i].onclick = playMusic.bind(null, as[i]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>而是转变成了更为简便的把onclick事件直接添加到一个v-for标签下的a标签中即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="keyword">class</span>=<span class="string">&quot;music_a&quot;</span> v-<span class="attr">bind</span>:name=<span class="string">&quot;&#x27;/mvn01/&#x27;+music.name&quot;</span> onclick=<span class="string">&quot;playMusic(this)&quot;</span>&gt;&#123;&#123;music.<span class="property">name</span>.<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]&#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>如下图所示，目前仅通过vue和axios把数据库的信息传递到网页上面并渲染。目前数据库里面就两个音乐信息，所以看着还行，后面肯定要做分页或者一个可下拉式的列表来应对多个数据的情况。</p><p><img src="/../images/image-20240926003227508.png" alt="image-20240926003227508"></p><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><h4 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h4><p>美化当前页面，在当前页面上方设计一个横式选择条或者右方设计一个可展开的页面选择条，来选择其他内容的页面。</p><p>给播放器添加字幕功能。</p><p>展示音乐列表的外观实现。</p><p>设置音乐播放界面。类似于<img src="/../images/image-20240926010101221.png" alt="image-20240926010101221"></p><h4 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h4><p>做好各个页面间的数据交互。</p><h4 id="希望做到项目完成的时刻，加油！！！！！"><a href="#希望做到项目完成的时刻，加油！！！！！" class="headerlink" title="希望做到项目完成的时刻，加油！！！！！"></a>希望做到项目完成的时刻，加油！！！！！</h4>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> 音乐播放器 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵模式</title>
      <link href="/2024/07/30/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/07/30/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="哨兵模式概念"><a href="#哨兵模式概念" class="headerlink" title="哨兵模式概念"></a>哨兵模式概念</h1><p>Redis的哨兵模式（Sentinel）是一种高可用的部署方式，由一个或多个Sentinel实例组成的Sentinel系统可以监控和管理多个Redis实例。在哨兵模式下，有一个或多个哨兵进程监控Redis主服务器和备份服务器的状态，并在主服务器下线时自动切换到备份服务器，继续处理命令请求。<br>详解见链接<a href="http://t.csdnimg.cn/FY1Pq">http://t.csdnimg.cn/FY1Pq</a></p><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>首先在主机上配置个一主两从的redis服务器，这里我配置了3个redis配置文件，其中redis-6381.conf是主节点</p><p><img src="/../images/image-20240730085620963.png" alt="image-20240730085620963"></p><p>再配置至少一个sentinel.conf配置文件，里面只需要加入如下语句（可在命令行用 <code>vi &lt;文件地址&gt;</code> 进行直接编写）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;主节点名称，任意即可&gt;  &lt;主节点ip地址，例127.0.0.1&gt;  &lt;主节点端口号&gt;</span><br></pre></td></tr></table></figure><p>如下所示，conf文件第一行即为加入的语句，语句下面是使用过程中产生的日志</p><p><img src="/../images/image-20240730090039350.png" alt="image-20240730090039350"></p><p>然后在命令行分别启动这三个节点的服务器(例: <code>redis-server myredis/redis-6380.conf</code>) 以及启动哨兵模式 (例: <code>redis-sentinel redis_sentinel/sentinel2.conf</code>)</p><p>最后就可以成功看到命令行中sentinel已经成功监控主节点了</p><p><img src="/../images/image-20240730091105753.png" alt="image-20240730091105753"></p><p>再把端口号为6381的这个主节点服务器关闭(在客户端使用shutdown命令)，可以看到</p><p><img src="/../images/image-20240730091438684.png" alt="image-20240730091438684"></p><p>由最后一句知道，新的主节点转换为了6382，查看6381和6382的从属关系可知已经改变了。</p><p><img src="/../images/image-20240730091615627.png" alt="image-20240730091615627"></p><p>这时，再把原来的主节点6381重新启动，哨兵检测到6381的恢复并主动将其设置为6382的从节点，如下图所示:</p><p><img src="/../images/image-20240730091904396.png" alt="image-20240730091904396"></p><p>至此，哨兵模式的简单实现流程就完成了，更加具体的内容还是查看其他博主的帖子吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="/2024/07/09/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2024/07/09/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="主从复制概念"><a href="#主从复制概念" class="headerlink" title="主从复制概念"></a>主从复制概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower) ; 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p><p>默认情况下，每台Redis服务器都是主节点 ;且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><h2 id="Redis服务启动方式"><a href="#Redis服务启动方式" class="headerlink" title="Redis服务启动方式"></a>Redis服务启动方式</h2><h4 id="1-默认启动方式"><a href="#1-默认启动方式" class="headerlink" title="1.默认启动方式"></a>1.默认启动方式</h4><blockquote><p> 服务端：.&#x2F;redis-server </p><p>client端：.&#x2F;redis-cli </p><p>退出： .&#x2F;redis-cli shutdown</p></blockquote><h4 id="2-指定端口启动"><a href="#2-指定端口启动" class="headerlink" title="2.指定端口启动"></a>2.指定端口启动</h4><blockquote><p> 服务端：.&#x2F;redis-server –port 端口号 </p><p>client端：.&#x2F;redis-cli -p 端口号 </p><p>退出： .&#x2F;redis-cli -p 端口号 shutdown</p></blockquote><h4 id="3-指定端口ip连接"><a href="#3-指定端口ip连接" class="headerlink" title="3.指定端口ip连接"></a>3.指定端口ip连接</h4><blockquote><p>服务端：.&#x2F;redis-server –port 端口号</p><p>client端：.&#x2F;redis-cli -p 端口号 -h 127.0.0.1</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="1-获取当前redis的信息"><a href="#1-获取当前redis的信息" class="headerlink" title="1.获取当前redis的信息"></a>1.获取当前redis的信息</h4><p>注意默认端口为6379，且该端口默认为主节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server  //开启redis服务端, 默认port 6380 ip 127.0.0.1</span><br><span class="line"></span><br><span class="line">redis-cli  //连接到该redis服务端，默认port 6380 ip 127.0.0.1</span><br><span class="line"></span><br><span class="line">info replication  //查看当前redis的信息，含主从节点信息</span><br></pre></td></tr></table></figure><h4 id="2-获取子节点6380的信息"><a href="#2-获取子节点6380的信息" class="headerlink" title="2.获取子节点6380的信息"></a>2.获取子节点6380的信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server --port 6380  //开启端口为6380的服务端</span><br><span class="line"></span><br><span class="line">redis-cli -p 6380 (-h 127.0.0.1 若ip未改，默认可不写)  //redis的cli(客户端)指定端口与ip连接到指定的服务端</span><br><span class="line"></span><br><span class="line">info replication  //查看当前redis的信息，含主从节点信息</span><br></pre></td></tr></table></figure><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h4 id="1-复制端口号6379的redis配置文件到redis的执行目录"><a href="#1-复制端口号6379的redis配置文件到redis的执行目录" class="headerlink" title="1.复制端口号6379的redis配置文件到redis的执行目录"></a>1.复制端口号6379的redis配置文件到redis的执行目录</h4><p>查询redis的配置文件方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config get dir</span><br></pre></td></tr></table></figure><p>这个命令返回的是redis的安装目录，配置文件应位于该目录下，注意etc这个位置是其他文件存放位置</p><h4 id="2-复制配置文件到要启动的redis其他端口的目录下-然后执行以下命令"><a href="#2-复制配置文件到要启动的redis其他端口的目录下-然后执行以下命令" class="headerlink" title="2.复制配置文件到要启动的redis其他端口的目录下,然后执行以下命令"></a>2.复制配置文件到要启动的redis其他端口的目录下,然后执行以下命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.config redis-6380.config</span><br></pre></td></tr></table></figure><p>拷贝的配置文件名自己定，如redis-6380.config</p><h4 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h4><p>下载一个可以打开配置文件的编辑器，推荐subllime</p><p>然后打开配置文件，用ctrl+f查询下面的语句然后进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1. 修改端口号，一主多从模式，此教程中我默认是以6379为主，6380、6381为从</span><br><span class="line"></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 2.开启守护进程模式运行，默认是no，这个要搜</span><br><span class="line"></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 3. 修改pid文件名，我是以端口来区分的</span><br><span class="line"></span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line"></span><br><span class="line"># 4.拷贝多个 redis.conf 配置文件，并按照以上步骤修改配置文件</span><br></pre></td></tr></table></figure><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>因为不了解ubuntu系统，导致我实现主从复制花了2个小时才成功。</p><p>首先一定要先知道redis的服务启动方法，因为这个网上找的有些命令是错误的，导致我开启自定义端口的服务端一直有问题，本文所给命令是我经实践后成功的。</p><p>其次，redis.config这个配置文件我找了半天，才发现在其他文件位置里。同时，要打开配置文件推荐使用sublime。</p><p>最后，不一定要改在配置文件中配置主节点，可以在子节点使用 <code>slaveof 主节点id 主节点端口号</code> 命令来建立主从关系，但如果在配置文件中配置了，那么重启也就不会失效了。</p><h2 id="重大发现"><a href="#重大发现" class="headerlink" title="重大发现"></a>重大发现</h2><p>原来我的操作还是有很大问题，初步了解了linux的命令行操作过后，发现了一个重点，这是针对我电脑的ubuntu系统实现redis主从复制的关键。</p><p>依赖配置文件在服务器端启动redis的方式应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 配置文件地址(例如：myredis/redis-6380.conf)</span><br></pre></td></tr></table></figure><p>然后，重点来了，执行后，命令行提示我Permission Denied而无法启动redis,然后，我用root权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><p>之后再次输入同样的启动语句，虽然没显示redis启动界面，而且看似好像没有发生任何事一样，你依旧可以输入其他语句。</p><p>结果，当我再次打开终端输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380</span><br></pre></td></tr></table></figure><p>发现成功在客户端启动这个redis服务器，随后输入的info replication显示的正是我所配置的redis-6380.conf文件.</p><p>这个成功实现的方法网上找遍了解决方案都没有找到，居然被我误打误撞找到了原因所在。估计是我的这个root权限有点问题，没设置好的缘故。</p><p>然后，就是<strong>服务端：.&#x2F;redis-server –port 端口号</strong> 这个启动redis服务器的方式估计是操作在默认文件夹下的配置文件，那个配置文件并没有被我修改过，所以查看主从关系时发现没有主从节点。</p><p>所以还是要用<code>redis-server 配置文件地址(例如：myredis/redis-6380.conf)</code>这个方式来启动相应文件的redis服务器。</p><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h4 id="9-21日"><a href="#9-21日" class="headerlink" title="9.21日"></a>9.21日</h4><p>之前配置实现主从节点后我发现主从的配置文件都变成了所属者为root，估计是以为配置文件里面的某些设置导致了主从设置后将配置文件的所有者改为了root，此外文件的读写权限也变成了只读。而且使用从节点进行写操作时会失败。</p><p>修改文件所属者和读写权限只要依照下面两条命令执行即可，之后进行操作时，其所属者和读写权限并不会改变，所以还是不知道是什么原因导致我一开始实现主从复制后。权限改变的原因是什么。</p><p>更改文件所属者的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown username 配置文件的路径</span><br></pre></td></tr></table></figure><p>更改文件读写权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+rw 配置文件的路径</span><br></pre></td></tr></table></figure><p>经过发现，redis配置文件里面有个<code>replica-read-only yes</code>的语句，这个语句表明了当前节点若是从节点的话，只能读取数据，不能修改数据，所以要把yes改为no。</p><p>此外，在以普通用户执行<code>redis-server myredis/redis-6380.conf</code>这句命令启动我指定的redis配置文件的服务时，会提示我权限不够，这是因为在配置文件里的语句<code>dir 存放路径</code>没有配置好，导致访问了root权限才能访问的文件夹，这个语句是指定存放rdb文件的位置。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习01</title>
      <link href="/2024/07/07/redis01/"/>
      <url>/2024/07/07/redis01/</url>
      
        <content type="html"><![CDATA[<p><strong>我是通过vm虚拟机安装ubuntu系统来学习redis的。</strong></p><h3 id="一-redis的基本数据结构"><a href="#一-redis的基本数据结构" class="headerlink" title="一.redis的基本数据结构"></a>一.redis的基本数据结构</h3><p>redis有5种基础数据结构，分别是<strong>String、Hash、List、Set、SortedSet</strong>。除此之外还有HyperLogLog、Geo、Pub&#x2F;Sub, 算是高级的数据结构。</p><h4 id="01-String"><a href="#01-String" class="headerlink" title="01.String"></a>01.String</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name cmower</span><br><span class="line">OK</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;cmower&quot;</span><br><span class="line">&gt; exists name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>1）set 命令用来存储一个键值对，在本例中，name 为 key，cmower 为 值。</p><p>2）get 命令用来获取一个键的值。</p><p>3）exists 命令用来测试一个键值对是否存在，<code>(integer) 1</code> 表示存在，<code>(integer) 0</code> 表示不存在。</p><p>4）del 命令用来删除一个键值对，<code>(integer) 1</code> 表示执行成功，<code>(integer) 0</code> 表示执行失败。</p><p>5）当键值对删除后，再通过 get 命令获取时，结果就为 <code>(nil)</code> 。</p><p>6）keys 命令用来查找键。例：*b表示所有以b结尾的键、 cmower 若存在则返回cmower</p><h4 id="02-List"><a href="#02-List" class="headerlink" title="02.List"></a>02.List</h4><p>Redis 列表由多个节点组成，每个节点包含一个字符串元素。列表可以存储任意数量的元素，而且列表中的元素可以重复。由于列表是双向链表，因此可以从列表的头部或尾部进行操作，这为实现先进先出（FIFO）或后进先出（LIFO）队列提供了基础。</p><p>常用命令<br><code>LPUSH key element [element …]</code></p><ul><li><p>描述：将一个或多个值插入到列表的头部。</p></li><li><p>示例：LPUSH list1 value1 value2</p></li></ul><p><code>RPUSH key element [element …]</code></p><ul><li><p>描述：将一个或多个值插入到列表的尾部。</p></li><li><p>示例：RPUSH list1 value1 value2</p></li></ul><p><code>LPOP key</code></p><ul><li><p>描述：移除并返回列表的第一个元素。</p></li><li><p>示例：LPOP list1</p></li></ul><p><code>RPOP key</code></p><ul><li><p>描述：移除并返回列表的最后一个元素。</p></li><li><p>示例：RPOP list1</p></li></ul><p><code>LRANGE key start stop</code></p><ul><li><p>描述：返回列表中指定范围的元素。</p></li><li><p>示例：LRANGE list1 0 5，返回列表的前六个元素。</p></li></ul><p><code>LLEN key</code></p><ul><li><p>描述：返回列表的长度。</p></li><li><p>示例：LLEN list1</p></li></ul><p><code>LINDEX key index</code></p><ul><li><p>描述：返回列表中指定位置的元素。</p></li><li><p>示例：LINDEX list1 2</p></li></ul><p><code>LREM key count value</code></p><ul><li><p>描述：移除列表中等于 value 的元素。</p></li><li><p>示例：LREM list1 2 value1，从列表头部开始移除前两个等于 value1 的元素。</p></li></ul><p><code>LTRIM key start stop</code></p><ul><li><p>描述：对一个列表进行修剪(trim)，使其只保留指定区间内的元素。</p></li><li><p>示例：LTRIM list1 0 10</p></li></ul><h4 id="03-Set"><a href="#03-Set" class="headerlink" title="03.Set"></a>03.Set</h4><p>Redis 的 Set 集合数据 , 与 List 列表功能相似 , 唯一的区别是 Set 集合中的元素 是 <strong>不允许重复</strong>的 ;</p><p>该 Set 集合 是一个 无序集合 , 存储 String 类型数据 ;</p><p>Set 集合底层是由 Hash 表实现 的 , 本质是 字典结构 , 其 添加 , 删除 , 查找 元素的 时间复杂度 是 O(1) ;</p><p>Java 的 HashSet 集合 内部由 HashMap 实现 , 所有的 值 Value 都指向同一个实例对象 ;</p><p>Redis 的 Set 集合 内部也是由 Hash 实现 , 所有的 值 Value 都指向同一个值 ;</p><p>常用命令</p><p>添加和删除与list差不多一致 SADD, SREM</p><p><code>SMEMBERS key</code></p><ul><li>描述：获取key集合的所有元素</li><li>示例：SMEMBERS name</li></ul><p><code>SISMEMBER key value</code></p><ul><li>描述：判断key键中是否存在value值</li><li>示例：SISMEMBER name Alice. 存在返回1，不存在返回0</li></ul><p><code>SCARD key</code></p><ul><li><p>描述：获取集合元素的个数</p></li><li><p>示例：SCARD name. 返回name中元素的个数</p></li></ul><p><code>SINTER key1 key2</code></p><ul><li><p>描述：获取两个集合的交集</p></li><li><p>示例：SINTER course1 course2</p></li></ul><p><code>SUNION key1 key2</code></p><ul><li><p>描述：获取两个集合的并集</p></li><li><p>示例：SUNION course1 course2</p></li></ul><p><code>SDIFF key1 key2</code></p><ul><li><p>描述：获取两个结合的差集</p></li><li><p>示例：SDIFF course1 course2</p></li></ul><p><code>SMOVE key1 key2 value</code></p><ul><li><p>描述：将key集合中的value值移动到key2集合中，key1中的value消失，key2中出现key1中消失的value</p></li><li><p>示例：SMOVE course1 course2 math. 若course1中不含math，则返回0；若含，则返回1</p></li></ul><h4 id="04-Hash"><a href="#04-Hash" class="headerlink" title="04.Hash"></a>04.Hash</h4><p>哈希类型是指Redis键值对中的<strong>值本身又是一个键值对结构</strong>，形如value&#x3D;[{field1，value1}，…{fieldN，valueN}]，</p><p>Hash主要就是对一个对象的多重属性(如人的姓名，性别，年龄)的存储</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/d17466ab22014931a1565c8046259903.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>同样是存储字符串，Hash 与String 的主要区别？</p><ol><li>把所有相关的值聚集到一个key 中，节省内存空间</li><li>只使用一个key，减少key 冲突</li><li>当需要批量获取值的时候，只需要使用一个命令，减少内存&#x2F;IO&#x2F;CPU 的消耗</li></ol><p><strong>常用命令</strong></p><p><code>HSET key field value</code></p><ul><li>描述：将哈希表key中的域field的值设置为value</li><li>示例：HSET person name ldy</li></ul><p><code>HGET key field</code></p><ul><li>描述：获取哈希表key中的域field的值</li><li>示例：HGET person name</li></ul><p><code>MHSET key field1 value1 field2 value2 ......</code></p><ul><li>描述：同时将多个field-value(字段-值)对设置到哈希表key中</li><li>示例：MHSET person name ldy age 15 sex male</li></ul><p><code>MHGET key field1 field2 ......</code></p><ul><li>描述：同时获取多个哈希表key中字段的值</li><li>示例：MHGET person name age sex</li></ul><p><code>HGETALL key</code></p><ul><li>描述：获取哈希表key中所有字段和值</li><li>示例：HGETALL person</li></ul><p><code>HDEL key field1 [field2、field3、... ]</code></p><ul><li>描述：删除哈希表key中的一个或多个指定字段，不存在的字段将被忽略,返回值为删除的字段个数</li><li>示例：HDEL person name age</li></ul><p><code>HLEN key</code></p><ul><li>描述：获取哈希表中字段的数量，当key不存在时返回0</li><li>示例：HLEN person</li></ul><p><code>HEXISTS key field</code></p><ul><li>描述：查看哈希表是否含有指定字段，有返回1，无返回或者key不存在返回0</li><li>示例：HEXISTS person age</li></ul><p><code>HKEYS key</code></p><ul><li>描述：获取哈希表中所有的字段</li><li>示例：HKEYS person</li></ul><p><code>HVALUES key</code></p><ul><li>描述：获取哈希表中所有字段的属性</li><li>示例：HVALUES person</li></ul><p><code>HINCRBY key field 数值</code></p><ul><li>描述：为哈希表中的字段值加上指定的增量</li><li>示例：HINCRBY person age 10</li><li>注意：增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。对一个储存字符串值的字段执行 HINCRBY 命令将造成一个错误。</li></ul><p><code>HSETNX key field1 value1</code></p><ul><li>描述：为哈希表中不存在的字段赋值</li><li>示例： HSETNX person name ldh age 33</li><li>注意：如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0</li></ul><h4 id="05-SortedSet"><a href="#05-SortedSet" class="headerlink" title="05.SortedSet"></a>05.SortedSet</h4><p>Sorted Sets 与 Sets 类似，是一种集合类型，集合中<strong>不会出现重复的数据（member）</strong>。区别在于 Sorted Sets 元素由两部分组成，分别是 member 和 score。</p><p>member 会关联一个 double 类型的分数（score），sorted sets 默认会根据这个 score 对 member 进行从小到大的排序，如果 member 关联的分数 score 相同，则按照字符串的字典顺序排序。</p><p><img src="D:\MyBlog\img\redis\60daf3de60c4d07fa4eaecac6002acb7.png" alt="60daf3de60c4d07fa4eaecac6002acb7"></p><p>常用命令</p><p><code>ZADD key score1 member1 [socre2 member2、... ...]</code></p><p><code>ZCARD key</code></p><p><code>ZRANGE key start stop [WITHSCORES]</code></p><p><code>ZREVRANGE key start stop [WITHSCORES]</code></p><p><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p><p><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></p><p><code>ZCOUNT key min max</code></p><p><code>ZINCRBY key increment member</code></p><p><code>ZRANK key member</code></p><p><code>ZREVRANK key member</code></p><p><code>ZREM key member [member ...]</code></p><p><code>ZREMRANGEBYRANK key start stop</code></p><p><code>ZREMRANGEBYSCORE key min max</code></p><p><code>ZSCORE key member</code></p><p>详见网址<a href="https://blog.csdn.net/aitangyong/article/details/51967362">redis数据类型SortedSet的常用命令-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EL表达式</title>
      <link href="/2024/05/24/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/05/24/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="  EL表达式"></a><center>  <strong>EL表达式</strong><center></h1><blockquote><h3 id="1-EL表达式概述"><a href="#1-EL表达式概述" class="headerlink" title="1. EL表达式概述"></a><strong>1. EL表达式概述</strong></h3></blockquote><ul><li>EL（Express Language）表达式可以嵌入在JSP页面内部，减少JSP脚本的编写，EL出现的目的是要替代JSP页面中脚本的编写。通俗讲就是通过使用EL表达式来减少java代码的编写。</li></ul><blockquote><h3 id="2-EL从域中取出数据"><a href="#2-EL从域中取出数据" class="headerlink" title="2. EL从域中取出数据"></a><strong>2. EL从域中取出数据</strong></h3></blockquote><ul><li><p>JSP脚本：&lt;%&#x3D;request.getAttribute(name)%&gt;</p></li><li><p>EL表达式替代上面的脚本：${requestScope.name}</p></li><li><p>EL最主要的作用是获得四大域中的数据，格式为<u>${EL表达式}</u></p></li><li><p>EL获得pageContext域中的值：$(pageScope.key);</p></li><li><p>EL获得request域中的值：$(requestScope.key);</p></li><li><p>EL获得session域中的值：$(sessionScope.key);</p></li><li><p>EL获得application域中的值：$(applicationScope.key);</p></li><li><p>EL从四个域中获得某个值:  <u><strong>$(key</strong>)</u></p></li></ul><p> <u><strong>$(key</strong>)</u>该方法和pageContext.findAttribute()一样,同样是依次从pageContext域，request域，session域，application域中 获取属性，在某个域中获取后将不再向后寻找。</p><p><strong>示例：</strong></p><ul><li><p>EL获得普通字符串</p><p><code>$&#123;str&#125;</code></p></li><li><p>EL获得User对象的值</p></li><li><p>EL获得List<String>的值</p></li><li><p>EL获得List<User>的值</p></li><li><p>EL获得Map&lt;String,String&gt;的值</p></li><li><p>EL获得Map&lt;String,User&gt;的值</p></li><li><p>EL获得Map&lt;String, List<User>&gt;的值</p></li></ul><p>​</p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EL </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇博客</title>
      <link href="/2024/05/23/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/23/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是我的第一篇博客，什么也没有诶w(ﾟДﾟ)w！！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/22/hello-world/"/>
      <url>/2024/05/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
