<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>黑马点评项目总结</title>
      <link href="/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2025/03/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h1><p>八股介绍：之后再补吧。。。。。词穷了</p><p>这个项目主要是基于redis相关内容进行展开的，主要实现了用户登录、抢票、点赞、评论、关注等类似社交软件的功能。</p><h1 id="二、短信登录"><a href="#二、短信登录" class="headerlink" title="二、短信登录"></a>二、短信登录</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>短信登录逻辑是用户填入手机号和短信验证码来校验用户信息。此外，该登录功能还包含了注册，即未注册过的手机号进行登录时，将会默认注册为一个新用户。</p><h2 id="2-验证码的获取"><a href="#2-验证码的获取" class="headerlink" title="2.验证码的获取"></a>2.验证码的获取</h2><h3 id="验证码缓存"><a href="#验证码缓存" class="headerlink" title="验证码缓存"></a>验证码缓存</h3><p>用户发起获取短信验证码请求时，后端会先随机生成一个6位数验证码，以<code>login:phone:填入的手机号</code>为key，将验证码存入redis中。随后调用短信相关的api，给对应的手机号发送验证码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;非法手机号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将验证码存入redis，以手机号码为key, 过期时间600秒</span></span><br><span class="line">    redisTemplate.opsForValue().set(RedisConstant.LOGIN_PHONE_KEY + phone, code, <span class="number">600</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送验证码成功&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-登录校验"><a href="#3-登录校验" class="headerlink" title="3.登录校验"></a>3.登录校验</h2><h3 id="用户信息缓存"><a href="#用户信息缓存" class="headerlink" title="用户信息缓存"></a>用户信息缓存</h3><p>用户校验成功后，后端会利用UUID随机生成一个token值，并以<code>login:user:token值</code>为key，保存用户的相关消息到redis中。前端接收返回的token值并带入请求头中，以便访问其他页面时校验用户身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.根据手机号查询redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> redisTemplate.opsForValue().get(RedisConstant.LOGIN_PHONE_KEY + phone);</span><br><span class="line">    <span class="comment">//2.校验验证码</span></span><br><span class="line">    <span class="keyword">if</span>(code == <span class="literal">null</span> || !code.equals(loginForm.getCode()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span>  <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.保存信息到redis</span></span><br><span class="line">    <span class="comment">//4.1随机生成token,做为访问redis的key，同时返回前端存储该token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstant.LOGIN_USER_KEY + token;</span><br><span class="line">    <span class="comment">//4.2将UserDTO对象转换为Map存储</span></span><br><span class="line"></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">    BeanUtils.copyProperties(user, userDTO);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">//设置过期时间</span></span><br><span class="line">    redisTemplate.expire(tokenKey, RedisConstant.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-登录拦截"><a href="#4-登录拦截" class="headerlink" title="4.登录拦截"></a>4.登录拦截</h2><p>拦截器配置类如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//token刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(</span><br><span class="line">                <span class="string">&quot;/**&quot;</span></span><br><span class="line">        ).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（1）token刷新拦截器"><a href="#（1）token刷新拦截器" class="headerlink" title="（1）token刷新拦截器"></a>（1）token刷新拦截器</h3><p>该拦截器目的是刷新用户token的有效期，并不具有拦截功能，真正实现拦截功能的是登录拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.从请求头的authorization中获取token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="comment">//2.根据key 获取用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">    <span class="keyword">if</span>(entries.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若用户信息存在，则添加到threadlocal</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(entries, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">    UserHolder.saveUser(userDTO);</span><br><span class="line">    <span class="comment">//4.刷新用户token</span></span><br><span class="line">    stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）登录拦截器"><a href="#（2）登录拦截器" class="headerlink" title="（2）登录拦截器"></a>（2）登录拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h3><h4 id="为什么需要有两个拦截器"><a href="#为什么需要有两个拦截器" class="headerlink" title="为什么需要有两个拦截器"></a>为什么需要有两个拦截器</h4><p>**答:**因为不是每个页面都会拦截，例如首页，非登录用户也可以进行访问。若token刷新功能设置在登录拦截器中，那么用户访问非登录拦截页面时，token也就无法刷新，所以只有一个拦截器的话，token刷新是存在问题的。</p><p><strong>解决方法：</strong>设置一个全放行的全局拦截器，并把登录拦截器的功能移植到这个全局拦截器中，若存在token，则会刷新token,并将用户信息存入<strong>ThreadLocal</strong>中。在访问登录拦截器所拦截的页面时，登录拦截器只需要判断<strong>ThreadLocal</strong>中是否存在用户信息即可。这种情况下，token刷新拦截器的优先级高于登录拦截器。</p><h2 id="5-功能改进"><a href="#5-功能改进" class="headerlink" title="5.功能改进"></a>5.功能改进</h2><h3 id="（1）验证码发送功能"><a href="#（1）验证码发送功能" class="headerlink" title="（1）验证码发送功能"></a>（1）验证码发送功能</h3><p>待扩展，基于阿里云的短信api。</p><h3 id="（2）jwt登录校验"><a href="#（2）jwt登录校验" class="headerlink" title="（2）jwt登录校验"></a>（2）jwt登录校验</h3><p>不使用redis缓存，而使用jwt进行用户信息校验。</p><h1 id="三、商户查询缓存"><a href="#三、商户查询缓存" class="headerlink" title="三、商户查询缓存"></a>三、商户查询缓存</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><p>缓存穿透指的是客户端请求在缓存和数据库中都不存在的数据，导致请求直接打到数据库。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="（1）-缓存空对象"><a href="#（1）-缓存空对象" class="headerlink" title="（1）.缓存空对象"></a>（1）.缓存空对象</h4><ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致（空对象存在时间内，新增了该id对应的商户信息）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用读缓存方法 -- 解决缓存穿透</span></span><br><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.先查redis缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.若redis中存在则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(str, type);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.若redis中没有，则访问数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3.1数据库中不存在，空值写入redis，防止缓存穿透</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, expireTime, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2.若数据库中存在，则存入redis中, 缓存时间为30分钟</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), expireTime, unit);</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点详解</p><p><strong>1.方法泛型</strong></p><p>方法泛型的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ReturnType <span class="title function_">methodName</span><span class="params">(T param1, T param2, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，泛型T类型根据方法参数而定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">((String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line"><span class="comment">//方法体  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ID</code>类型</strong>：在调用<code>queryPassThrough</code>方法时，第二个参数的类型决定了<code>ID</code>的具体类型。</li><li><strong><code>R</code>类型</strong>：在调用<code>queryPassThrough</code>方法时，第三个参数<code>Class&lt;R&gt;</code>的类型决定了<code>R</code>的具体类型。</li></ul><p>上述方法中使用了泛型<code>&lt;ID, R&gt;</code>，其中<code>ID</code>表示传入的ID类型，<code>R</code>表示返回结果的类型。这使得方法可以处理不同类型的ID和返回值，增强了代码的通用性。</p><p>简单示例:将从Redis获取对象并进行类型转换的代码进行了封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; R <span class="title function_">getBean</span><span class="params">(String key, Class&lt;R&gt; type)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JSONUtil.toBean(s, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用封装方法</span></span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> Cache.getBean(key, Shop.class);</span><br><span class="line"><span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用封装方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="keyword">if</span>(StrUtil.isEmpty(s))&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(s, Shop.class);</span><br></pre></td></tr></table></figure><p><strong>2.函数式接口</strong></p><p><code>Function&lt;ID, R&gt;</code> 是一个函数式接口，定义了一个方法 <code>apply</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(ID id)</span>;</span><br></pre></td></tr></table></figure><p>这个方法接收一个类型为 <code>ID</code> 的参数，并返回一个类型为 <code>R</code> 的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, <span class="number">1200L</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>上述代码的this::getById是一个方法引用，用作apply方法的实现。</p><p><strong>3.方法引用</strong></p><p>方法引用是 Java 8 引入的一种特性，它允许你直接引用已有的方法或构造函数，而无需显式地定义一个 Lambda 表达式。方法引用可以看作是 Lambda 表达式的语法糖，它使得代码更加简洁、易读，并且能够直接利用已有的方法逻辑。</p><p><strong>方法引用与 Lambda 表达式的区别</strong></p><ul><li><p><strong>Lambda 表达式</strong>：是一种匿名函数，可以定义新的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; absFunction = x -&gt; Math.abs(x);</span><br></pre></td></tr></table></figure></li><li><p><strong>方法引用</strong>：直接引用已有的方法，避免重复定义逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; absFunction = Math::abs;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong></p><p><code>Function&lt;S, T&gt;</code> 这种函数式接口可以使用方法引用，但方法引用必须满足以下条件：</p><ul><li>方法的参数类型必须与 <code>S</code> 匹配。</li><li>方法的返回类型必须与 <code>T</code> 匹配。</li></ul><p>只有当方法的签名的参数与 <code>Function&lt;S, T&gt;</code> 的 <code>apply</code> 方法的签名参数一致时，才能使用方法引用。</p><p>方法的签名（Method Signature）指的是方法的名称和参数列表。</p><h4 id="（2）布隆过滤"><a href="#（2）布隆过滤" class="headerlink" title="（2）布隆过滤"></a>（2）布隆过滤</h4><ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul><h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><p>缓存雪崩指的是在同一时间段内大量的缓存key同时失效或者redis服务突然宕机，导致大量请求直接打到数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的key添加随机的TTL</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加<strong>降级限流</strong>策略（<strong>限流</strong>：缓存未命中时，数据库的访问量也不会超过<strong>业务</strong>限流量，<strong>降级</strong>：缓存未命中时，返回默认值）</li><li>给业务添加多级缓存</li></ul><h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><p>缓存击穿指的是一个被高并发访问并且缓存重建业务较耗时的key突然失效了，导致大量请求直接打到数据库上。</p><p><img src="/../images/1653328022622-17433473940211.png" alt="1653328022622"></p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><h3 id="（1）互斥锁"><a href="#（1）互斥锁" class="headerlink" title="（1）互斥锁"></a>（1）互斥锁</h3><h3 id="（2）逻辑过期"><a href="#（2）逻辑过期" class="headerlink" title="（2）逻辑过期"></a>（2）逻辑过期</h3><h1 id="四、优惠券秒杀"><a href="#四、优惠券秒杀" class="headerlink" title="四、优惠券秒杀"></a>四、优惠券秒杀</h1><h1 id="五、附近商户"><a href="#五、附近商户" class="headerlink" title="五、附近商户"></a>五、附近商户</h1><h1 id="六、达人探店"><a href="#六、达人探店" class="headerlink" title="六、达人探店"></a>六、达人探店</h1><h1 id="七、好友关注"><a href="#七、好友关注" class="headerlink" title="七、好友关注"></a>七、好友关注</h1><h1 id="八、UV统计"><a href="#八、UV统计" class="headerlink" title="八、UV统计"></a>八、UV统计</h1><h1 id="九、用户签到"><a href="#九、用户签到" class="headerlink" title="九、用户签到"></a>九、用户签到</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="/2025/03/25/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/25/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="挑战一"><a href="#挑战一" class="headerlink" title="挑战一"></a>挑战一</h3><p>1.创建多级目录</p><p><img src="/../images/image-20250325184118204.png" alt="image-20250325184118204"></p><p>2.通配符</p><p>（1）cp</p><p>（2）mv</p><p>3.touch</p><p>4.rm</p><p>5.ls</p><p>tip:</p><p><code>cd</code> 或者 <code>cd ~</code>回到家目录</p><p><code>cd -</code> 回到上次操作所在目录</p><p><code>grep ^$ 文件路径</code>  查询空行，正则表达式：^行首，$行尾</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis最佳实践</title>
      <link href="/2025/03/22/Redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/03/22/Redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-键值设计"><a href="#1-键值设计" class="headerlink" title="1.键值设计"></a>1.键值设计</h2><h4 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h4><p>key的最佳实践约定</p><p>1.遵循基本格式：**[业务名称]:[数据名]:[id]**</p><p><img src="/../images/image-20250322180037311.png" alt="image-20250322180037311"></p><p>2.长度不超过44字节</p><p>3.不包含特殊字符</p><p>优点</p><ol><li>可读性强</li><li>避免key冲突</li><li>方便管理</li><li>更节省内存：key是string类型，底层编码包含int,embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。raw模式下，内存空间不是连续的，而是会采用指针形式指向其他空间。</li></ol><h4 id="拒绝BigKey"><a href="#拒绝BigKey" class="headerlink" title="拒绝BigKey"></a>拒绝BigKey</h4><p>什么是BigKey</p><ol><li>key本身的数据量过大，比如一个key的值就占了5MB。</li><li>key中的成员数过多，比如一个ZSET类型的key,它的成员数量为10000个。</li><li>key中成员的数据量过大，比如一个Hash类型的key,它的成员数量虽然只有1000个，但这些value的总大小为100MB。</li></ol><p>推荐值：</p><ul><li>单个key的value小于10kb</li><li>对于集合类型的key，建议元素数量小于1000</li></ul><p><img src="/../images/image-20250323222905155.png" alt="image-20250323222905155"></p><h4 id="选择合理的数据结构"><a href="#选择合理的数据结构" class="headerlink" title="选择合理的数据结构"></a>选择合理的数据结构</h4><p><img src="/../images/image-20250323223329263.png" alt="image-20250323223329263"></p><h2 id="2-批处理优化"><a href="#2-批处理优化" class="headerlink" title="2.批处理优化"></a>2.批处理优化</h2><h4 id="单个命令的执行流程"><a href="#单个命令的执行流程" class="headerlink" title="单个命令的执行流程"></a>单个命令的执行流程</h4><p>一次命令响应时间&#x3D;一次往返的网络传输所耗的时间 + 1次redis执行命令耗时</p><p><img src="/../images/image-20250323225424880.png" alt="image-20250323225424880"></p><p>问题：一次命令响应时间耗费时长主要由<strong>网络传输耗时</strong>造成。这样导致N次命令的响应时间&#x3D;N次往返的网络传输耗时+N次redis执行命令耗时。</p><p><img src="/../images/image-20250323225704228.png" alt="image-20250323225704228"></p><p>如果我们在处理某个业务流程时，需要多次循环往redis中存取数据时，会相当耗时，所以我们可以视情况而优化流程。比如使用MSET和Pipeline，来一次性通过网络发送全部的数据，而不是一次一次的发送。这就是批处理。</p><h4 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h4><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据。例如</p><ul><li>mset</li><li>hmset</li></ul><p>代码演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:不要在一次批处理中传输太多命令，否则单次命令占用的带宽太多，会导致网络阻塞</p><h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理时，建议使用Pipeline功能。</p><p>代码演示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>注意：Mxxx方法执行时间比Pipeline要快。因为Mxxx方法是redis原生的命令，是有原子性的，而Pipeline则是非原子性执行命令的，所以执行所有的命令期间可能会插入其他请求发送过来的命令，导致耗时慢些，不过问题不大。</p><h4 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h4><p>集群处理暂时先不总结了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>批处理方案</p><ol><li>原生的M操作</li><li>Pipeline批处理</li></ol><p>注意事项</p><ol><li>批处理时不建议一次携带太多命令</li><li>Pipeline的多个命令之间不具备原子性</li></ol><h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><h4 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评笔记</title>
      <link href="/2025/03/07/Redis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/07/Redis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缓存机制"><a href="#1-缓存机制" class="headerlink" title="1.缓存机制"></a>1.缓存机制</h2><p>数据一致性：先修改数据库再删除redis缓存。先删缓再删数据发生线程安全的问题更大，因为数据库修改数据耗时长，可能删了缓存后在数据库信息修改还没好之前，又读取了该信息并缓存了。</p><h2 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h2><p>客户端访问数据库中不存在的数据，缓存永远不生效，可能会被恶意攻击数据库导致瘫痪。<br>方法1.缓存空对象  2.布隆过滤</p><h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h2><p>指的是同一时间段内，redis中大量的缓存的key同时失效或者redis服务器宕机了，导致有大量请求到达数据库，带来巨大压力<br>解决方法：1.给TTL添加随机值 2.利用redis集群 3.给缓存业务添加降级限流策略（微服务内容）4.添加多级缓存</p><h2 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4.缓存击穿"></a>4.缓存击穿</h2><p>指的是某一个被高并发访问并且该缓存重建业务较复杂的key突然失效了，导致大量请求到达数据库，带来巨大冲击。<br>解决方法：1.添加互斥锁到redis中 2.逻辑过期</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h5 id="通用的redis缓存工具"><a href="#通用的redis缓存工具" class="headerlink" title="通用的redis缓存工具"></a><strong>通用的redis缓存工具</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 缓存工具类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//通用写入缓存方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, expireTime, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通用写入缓存方法 -- 逻辑过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithExpire</span><span class="params">(String key, Object value, Long expireTime, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个逻辑过期对象通用类</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(expireTime)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用读缓存方法 -- 解决缓存穿透</span></span><br><span class="line">    <span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">//1.先查redis缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.若redis中存在则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(str))&#123;</span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(str, type);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.若redis中没有，则访问数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.1数据库中不存在，空值写入redis，防止缓存穿透</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, expireTime, unit);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2.若数据库中存在，则存入redis中, 缓存时间为30分钟</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), expireTime, unit);</span><br><span class="line">        <span class="comment">//4.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用获取对象 -- 解决缓存击穿 -- 逻辑过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryWithLogicExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; function, String lockPrefix, Long prolongTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">//1.先查redis缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">strJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.若未命中，则直接返回null, 因为逻辑过期场景下，redis中的数据是提前写好的，没有就不需要查数据库了</span></span><br><span class="line">        <span class="keyword">if</span>(!StrUtil.isNotBlank(strJson))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.若redis命中，则判断是否逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//因为redisObject是一个通用类，所以data类型是Object,这种情况下需要先强转为JSONObject,再使用JSONUtil.toBean()</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="comment">//4.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="comment">//4.1未过期，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2已过期，需缓存重建</span></span><br><span class="line">        <span class="comment">//5.缓存重建</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> tryLock(lockPrefix+id);</span><br><span class="line">        <span class="comment">//5.2判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">            <span class="comment">//5.3成功</span></span><br><span class="line">            <span class="comment">//5.4二次判断redis当中此时是否已经更新过过期时间了</span></span><br><span class="line">            strJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            redisData = JSONUtil.toBean(strJson, RedisData.class);</span><br><span class="line">            expireTime = redisData.getExpireTime();</span><br><span class="line">            <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">                data = (JSONObject)redisData.getData();</span><br><span class="line">                <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.5开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(()-&gt;</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.6查询数据库</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> function.apply(id);</span><br><span class="line">                setWithExpire(key, r, prolongTime, unit);</span><br><span class="line">                <span class="comment">//5.7释放锁</span></span><br><span class="line">                releaseLock(lockPrefix+id);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.7返回过期的店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(data, type);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取互斥锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//尝试设置redis内容,若设置成功则表明获取到了锁，若失败，则说明已经有人拿到了这个锁</span></span><br><span class="line">        <span class="comment">//设置过期时间是怕获取到锁的线程发生问题时独占锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放互斥锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的通用方法写的太神了，很好的利用到了泛型和消费者机制，把原本写在serviceImpl里的方法直接提取出来了，以shop模块的查询功能为例，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//解决缓存穿透方案</span></span><br><span class="line">    <span class="comment">//Result result = queryByIdByPassThrough();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决缓存击穿方案--互斥锁，包含了解决缓存穿透</span></span><br><span class="line">    <span class="comment">//Shop shop = queryWithMutex(id);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决缓存击穿方案2--逻辑过期</span></span><br><span class="line">    <span class="comment">//Shop shop = queryWithLogicExpire(id);</span></span><br><span class="line"><span class="comment">//将以上方法提炼到通用方法，使用通用方法结果如下</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithLogicExpire(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, LOCK_SHOP_KEY, <span class="number">20L</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺id不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 查看方法参数的快捷键是<strong>ctrl+P</strong>,我现在才知道啊。。。。。</p><h5 id="全局唯一id方法"><a href="#全局唯一id方法" class="headerlink" title="全局唯一id方法"></a><strong>全局唯一id方法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//开始时间戳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//2025年3月8号做为起始时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1741464196</span>;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">dateSeconds</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> dateSeconds - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2.生成序列号</span></span><br><span class="line">        <span class="comment">//2.1获取当前时间，精确到天，做为当天自增长key的一部分</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2自增长</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;incr:&quot;</span> + keyPrefix + date);</span><br><span class="line">        <span class="comment">//3.拼接并返回， 时间戳（每秒都不一样）在前32位，自增长id在后32位，这样子可以支持每秒产生最多2^32次个不同的id,当然，这一天最多只能产生2^32次个id</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优惠券秒杀机制"><a href="#优惠券秒杀机制" class="headerlink" title="优惠券秒杀机制"></a><strong>优惠券秒杀机制</strong></h5><p>这里很好的用到了锁和事务的内容</p><p>1.乐观锁，即每次访问数据库时再次校验数据库内容是否发生变更，在尚庭公寓项目里是利用了version字段来实现，而这里因为是对优惠券的库存操作，每次库存减一对应版本号加一，所以可用让库存充当版本号的作用，即每次更新库存时，都加上之前获取到的库存值判断。</p><p>但又因为这样子并发情况又会出问题。假设两个线程一开始获取的库存数都是100，线程一先修改列库存，变成99，此时线程二取修改，发现库存不对，就失败，导致明明有库存，但获取失败的情况。</p><p>所以判断条件改为了stock &gt; 0。</p><p>2.悲观锁，解决一人一单问题，一人一单用的是查询操作，所以无法使用乐观锁。锁的对象是常量池中的字符串，而不能是每次访问都会new的对象（这样子的话，锁完全没用）</p><p>3.事务失效需要交给代理，所以需要获取代理对象来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询秒杀券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="keyword">if</span>(voucher == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀券不存在!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断秒杀券是否开始</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断秒杀券是否结束</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//给用户id加锁，intern是指锁的对象是常量池中的字符串</span></span><br><span class="line">    <span class="comment">//因为每次toString创建的都是新对象，加锁没有用，所以需要intern()方法</span></span><br><span class="line">    <span class="comment">//同时，锁需要在事务提交之后才能释放，保证线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">//因为事务生效实际上是由代理对象执行的，所以this.createVoucherOrder实际上并不会开启线程，所以需要获取事务的原始对象的代理对象</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span>  <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId, Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1获取订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order:&quot;</span>);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    <span class="comment">//6.2用户id</span></span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    <span class="comment">//6.3代金券id</span></span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5.分布式锁"></a>5.分布式锁</h2><p>上面的锁只能锁单个服务器，当面临多个集群部署时，没办法锁住全部的服务器，所以需要使用分布式锁来解决。</p><p>而redis恰好可以实现分布式锁（当多个集群公用一个redis时）。</p><p>下面是自定义分布式锁工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//uuid用于区分进程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">keyPrefix</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long expireSecond)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线程id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(keyPrefix + name, uuid+id, expireSecond, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//防止b是null时拆箱出错</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取redis锁中的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(keyPrefix + name);</span><br><span class="line">        <span class="comment">//判断锁中的uuid+线程id是否与当前线程一致   uuid用于标识不同进程， 线程id用于标识同一进程下的不同id.因为不同进程的线程id可能相同</span></span><br><span class="line">        <span class="comment">//比较是为了防止当前线程阻塞且锁过期时，第二个线程获取锁后，当前线程又复活了，防止当前线程删除第二个线程的锁。</span></span><br><span class="line">        <span class="keyword">if</span>(val.equals(uuid + Thread.currentThread().toString()))&#123;</span><br><span class="line">            stringRedisTemplate.delete(keyPrefix + name);</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而上面代码依然会有线程安全的问题，因为<strong>unlock（）</strong>方法获取redis锁中的值和释放锁是两步操作，极端情况下，可能获取到锁中的值是当前线程的，但在删除锁时遭遇阻塞，可能期间就已经过期，并且还被其他线程获取到锁了，当该线程最终继续执行删除时，可能就把别的线程的锁给释放了。这就是<strong>原子性</strong>问题了。</p><h2 id="6-Lua脚本"><a href="#6-Lua脚本" class="headerlink" title="6.Lua脚本"></a>6.Lua脚本</h2><p>使用lua语言写脚本可以保证原子性（上面查询redis中的锁和释放锁不是一起进行的，仍然会有线程安全问题，应该保证查询和释放一起进行），Lua本身不具备原子性，而是因为redis执行命令是单线程的，会<strong>把lua脚本做为一个命令执行</strong></p><p>1.<strong>无参脚本</strong></p><p>可以在redis中直接写</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval <span class="string">&quot;return redis.call(&#x27;命令/例如get&#x27;, &#x27;name&#x27; ,&#x27;ldy&#x27;)&quot;</span><span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数解释</p><p>eval: redis中执行lua脚本的命令</p><p>return: 返回结果</p><p>redis.call(‘命令’， ‘key值’， ‘value值’) 参数个数 （参数…)</p><p>2.<strong>有参脚本</strong></p><p>这里KEYSP和ARGV数组（必须大写）用于接收后面的参数</p><p><strong>注意</strong>， 索引是从1开始的</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; eval <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> <span class="number">1</span> name hei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;hei&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编写释放锁脚本"><a href="#编写释放锁脚本" class="headerlink" title="编写释放锁脚本"></a>编写释放锁脚本</h3><p>无参，写死了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;lock:order:5&quot;</span></span><br><span class="line"><span class="comment">-- 当前线程标识</span></span><br><span class="line"><span class="keyword">local</span> threadid = <span class="string">&quot;faefjeapff-33&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 获取锁中的线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, key)</span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(id == threadid) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>传参，通过外部传参给KEYS和ARGV</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取锁中的线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(id == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更简写的方式</span></span><br><span class="line"><span class="comment">-- 比较线程标识</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="java调用lua脚本"><a href="#java调用lua脚本" class="headerlink" title="java调用lua脚本"></a>java调用lua脚本</h3><p>1.下载插件<strong>EmmyLua</strong></p><p><img src="/../images/image-20250312161100974.png" alt="image-20250312161100974"></p><p>2.编写lua脚本</p><p><img src="/../images/image-20250312161135922.png" alt="image-20250312161135922"></p><p><img src="/../images/image-20250312161229537.png" alt="image-20250312161229537"></p><p>3.调用lua脚本</p><p><strong>tip</strong>, ctrl + h 查看类的继承&#x2F;实现关系，可以看到，我这里按了ctrl+h后，显示了RedisScript类的继承类，直接使用实现类。</p><p><img src="/../images/image-20250312161713668.png" alt="image-20250312161713668"></p><p>执行lua脚本由<strong>RedisTemplate</strong>的<strong>execute</strong>方法实现</p><p>实战代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> &#123;</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//uuid用于区分进程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">keyPrefix</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"><span class="comment">//这里把脚本当作定值预先加载了，避免每次获取锁都要重新读取脚本内容而浪费时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">//new ClassPathResource()即获取resource目录下的文件信息</span></span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long expireSecond)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线程id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(keyPrefix + name, uuid+id, expireSecond, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//防止b是null时拆箱出错</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*使用lua脚本</span></span><br><span class="line"><span class="comment">        Collections用于把一个对象转化为一个集合， 因为这里要求keys是一个集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(keyPrefix + name),</span><br><span class="line">                uuid + Thread.currentThread().getId()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-秒杀优化"><a href="#7-秒杀优化" class="headerlink" title="7.秒杀优化"></a>7.秒杀优化</h2><p>之前的秒杀机制大部分操作都直接会用到数据库，在性能方面比较差。</p><p><img src="/../images/image-20250313202012520.png" alt="image-20250313202012520"></p><p>优化思路：</p><ol><li>新增秒杀券的同时，将优惠券信息保存到Redi中。</li><li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功。</li><li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列。</li><li>开启线程任务，不断从阻塞队列中获取数据，实现异步下单。</li></ol><p>1.基于redis进行库存和一人一单校验</p><p><img src="/../images/image-20250313202241375.png" alt="image-20250313202241375"></p><p>库存：秒杀优惠券在新增时就将库存加入redis中。</p><p>一人一单：使用set类型存储对应优惠券订单的用户。使用<strong>sismember</strong>命令判断用户id是否已存在于set集合中。</p><p>编写lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--获取用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--获取优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 获取库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&quot;seckill:stock:&quot;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 获取订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&quot;seckill:order:&quot;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.判断库存呢是否充足</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 库存不足返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.判断是否已经下单</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 已下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.将当前userId存入优惠券set集合</span></span><br><span class="line">redis.call(<span class="string">&quot;sadd&quot;</span>, orderKey, userId)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>重写seckillVoucher方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            UserHolder.getUser().getId().toString(),</span><br><span class="line">            voucherId.toString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(execute != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1不为0返回异常信息</span></span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足!&quot;</span>) : Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.创建订单,异步下单</span></span><br><span class="line">    <span class="comment">//3.1 获取订单id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(SECKILL_ORDER_KEY);</span><br><span class="line">    <span class="comment">//3.2将用户id, 优惠券id和 订单id存入阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用消息队列异步创建订单</p><p>使用java自带的阻塞队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;VoucherOrder&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在类初始化完成后就开启子线程实时获取阻塞队列中的元素</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">VoucherHanler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherHanler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取订单，阻塞队列没有元素则会一直阻塞等待</span></span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">            <span class="comment">//2.创建订单</span></span><br><span class="line">            handleVoucherOrder(order);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户、优惠券id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//2.获取锁对象</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//3.获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="comment">//4.判断锁是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        <span class="comment">//获取锁失败，输出日志</span></span><br><span class="line">        log.error(<span class="string">&quot;发送异常，没获取到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        proxy.createVoucherOrder(order);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理对象才能开启事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder order)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> order.getVoucherId();</span><br><span class="line">    <span class="comment">//5.一人一单逻辑</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户已经下过单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.扣减库存,需要再次校验库存是否充足，保证线程安全</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.save(order);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子线程不能创建代理对象，所以该由主线程创建并赋值给全局代理对象供子线程使用</span></span><br><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        userId.toString(),</span><br><span class="line">        voucherId.toString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(execute != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1不为0返回异常信息</span></span><br><span class="line">        <span class="keyword">return</span> execute == <span class="number">1</span> ? Result.fail(<span class="string">&quot;库存不足!&quot;</span>) : Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.创建订单,异步下单</span></span><br><span class="line">    <span class="comment">//3.1 获取订单id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(SECKILL_ORDER_KEY);</span><br><span class="line">    <span class="comment">//3.2将用户id, 优惠券id和 订单id存入阻塞队列</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    blockingQueue.add(order);</span><br><span class="line">    <span class="comment">//3.3返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-消息队列"><a href="#8-消息队列" class="headerlink" title="8.消息队列"></a>8.消息队列</h2><h3 id="Redis实现消息队列"><a href="#Redis实现消息队列" class="headerlink" title="Redis实现消息队列"></a>Redis实现消息队列</h3><p><img src="/../images/image-20250314175932374.png" alt="image-20250314175932374"></p><h4 id="1-基于List实现"><a href="#1-基于List实现" class="headerlink" title="1.基于List实现"></a>1.基于List实现</h4><h4 id="2-基于PubSub实现"><a href="#2-基于PubSub实现" class="headerlink" title="2.基于PubSub实现"></a>2.基于PubSub实现</h4><h4 id="3-基于stream实现"><a href="#3-基于stream实现" class="headerlink" title="3.基于stream实现"></a>3.基于stream实现</h4><p><strong>单消费者</strong></p><p>XADD </p><p>XREAD</p><p><strong>消费者组</strong></p><h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMq</title>
      <link href="/2025/02/26/RabbitMq/"/>
      <url>/2025/02/26/RabbitMq/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMq消息队列"><a href="#RabbitMq消息队列" class="headerlink" title="RabbitMq消息队列"></a>RabbitMq消息队列</h1><p>总结参考黑马教程<a href="https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc">day06-MQ基础 - 飞书云文档</a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：</p><p><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><h3 id="使用背景："><a href="#使用背景：" class="headerlink" title="使用背景："></a>使用背景：</h3><h4 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h4><p>在微服务项目中，我们使用的OpenFeign都是<strong>同步调用</strong>，可以理解为阻塞，只有当前任务执行完毕才能往下执行，同步调用存在以下问题：</p><p><strong>第一</strong>，<strong>拓展性差</strong></p><p>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？</p><p>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？</p><p><img src="/../images/image-20250226170410101.png" alt="image-20250226170410101"></p><p>由此可见，服务会越来越臃肿。</p><p><strong>第二</strong>，<strong>性能下降</strong></p><p>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和。</p><p><img src="/../images/image-20250226170342094.png" alt="image-20250226170342094"></p><p><strong>第三，级联失败</strong></p><p>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</p><p>这其实就是同步调用的<strong>级联失败</strong>问题。</p><p>比方说一个订单支付业务，用户支付成功后还会获得积分，但积分服务出现了问题，导致整个事务回滚，用户的钱又退回去了，这怎么行呢，毕竟拿来的钱哪有还回去的道理。因此，不能因为个别业务问题而导致整个事务的回滚。</p><h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>至于如何解决上述问题，这就用到了消息队列的异步调用了。</p><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者(Publisher)：投递消息的人，就是原来的调用方</li><li>消息Broker(Exchange、Queue)：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者(Consumer)：接收和处理消息的人，就是原来的服务提供方</li></ul><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p><img src="/../images/image-20250226171254619.png" alt="image-20250226171254619"></p><p>这样，发送消息的人和接收消息的人就完全解耦了。发送消息的人只需要发消息，至于接收者怎么接收、是否接收成功都与发送者无关了。</p><p>通过消息队列，可以改变服务的架构，如下支付业务所示</p><p><img src="/../images/image-20250226171542545.png" alt="image-20250226171542545"></p><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>并且不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，<strong>解除了耦合</strong>，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li><strong>耦合度更低</strong></li><li><strong>性能更好</strong></li><li><strong>业务拓展性强</strong></li><li><strong>故障隔离，避免级联失败</strong></li></ul><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h2><h3 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1.基础用法"></a>1.基础用法</h3><p> 1.<strong>安装</strong></p><p>基于Docker来安装RabbitMQ，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \  </span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \   </span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hm-net\</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>安装完成后，我们访问 <a href="http://192.168.10.101:15672（注意根据自己的虚拟机访问ip调整）即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。">http://192.168.10.101:15672（注意根据自己的虚拟机访问ip调整）即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</a></p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p>RabbitMq的基本架构如图所示。</p><p><img src="/../images/image-20250226172318386.png" alt="image-20250226172318386"></p><p>其中包含几个概念：</p><ul><li>**<code>publisher</code>**：生产者，也就是发送消息的一方</li><li>**<code>consumer</code>**：消费者，也就是消费消息的一方</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>RabbitMQ管理控制台看黑马教程<a href="https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc">day06-MQ基础 - 飞书云文档</a></p><p>交换机exchange根据routekey路由消息到指定的队列queue。</p><p><img src="/../images/direct.png" alt="direct"></p><h3 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h3><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。</p><p>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：<strong>SpringAMQP</strong>。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：</p><p><a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系 (在配置类中使用@Bean声明或者在监听器注解@RabbitListener中声明)</li><li>基于注解的监听器模式，异步接收消息  (使用@RabbitListerner注解)</li><li>封装了RabbitTemplate工具，用于发送消息 (使用时直接注入即可)</li></ul><p>队列、交换机、绑定关系的声明方法有两种，如下所示</p><p>1.基于配置类，以Direct交换机为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;direct.queue&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueToDirect1</span><span class="params">(DirectExchange directExchange, Queue directQueue )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.基于监听器注解@RabbitListener的bindings属性</p><p><img src="/../images/image-20250226173122373.png" alt="image-20250226173122373"></p><h2 id="3-WorkQueue（工作队列）"><a href="#3-WorkQueue（工作队列）" class="headerlink" title="3.WorkQueue（工作队列）"></a>3.WorkQueue（工作队列）</h2><p>简单来说就是多个消费者绑定到一个队列，共同消费队列里的消息。</p><ul><li><strong>默认情况下</strong>，消息是<strong>轮询（Round-Robin）</strong>分配给各个消费者的。也就是说，消息会依次分配给每个消费者，而不是提前平均分配。每个消费者依次从队列中获取消息进行处理。</li><li><strong>能者多劳</strong>：在某些情况下，你可能希望消费者根据自己的处理能力来消费消息，而不是简单地轮询分配。这时可以通过配置来实现“能者多劳”的效果。在 RabbitMQ 中，可以通过设置 <code>prefetch</code> 参数来控制每个消费者一次最多可以获取多少条消息。如果某个消费者处理速度较快，它可以更快地处理完当前的消息并获取新的消息，从而实现“能者多劳”的效果。配置消息如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>总结</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="4-交换机"><a href="#4-交换机" class="headerlink" title="4.交换机"></a>4.交换机</h2><p>交换机的作用：</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列中</li></ul><p><strong>注意</strong>，交换机不能存储消息，若路由失败，则消息丢失</p><h4 id="1-Fanout交换机"><a href="#1-Fanout交换机" class="headerlink" title="1.Fanout交换机"></a>1.Fanout交换机</h4><p>作用：<strong>广播</strong>，将消息路由给所有与该交换机绑定的队列中。</p><p><img src="/../images/fanout.png" alt="fanout"></p><h4 id="2-Direct交换机"><a href="#2-Direct交换机" class="headerlink" title="2.Direct交换机"></a>2.Direct交换机</h4><p>作用：<strong>定向</strong>，根据消息的RoutingKey判断路由给哪个（些）队列。</p><p>消息发送时需指定<strong>routingkey（路由key）</strong>。direct交换机会将信息路由到具有相同的路由key的队列中。一个队列可以设置多个路由key，每个队列路由key可以相同，若相同则接收时都会接收到消息。</p><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li><p>Fanout交换机将消息路由给每一个与之绑定的队列</p></li><li><p>Direct交换机根据RoutingKey判断路由给哪个队列</p></li><li><p>如果多个队列具有相同的RoutingKey,则效果和Fanout类似</p><p><img src="/../images/direct-17405632704672.png" alt="direct"></p></li></ul><h4 id="3-Topic交换机"><a href="#3-Topic交换机" class="headerlink" title="3.Topic交换机"></a>3.Topic交换机</h4><p>作用:<strong>加强版定向</strong>，可以让队列在绑定routingkey时使用通配符。</p><p>通配符规则：</p><ul><li><code>#</code>：匹配0个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p><ul><li><code>china.news </code>代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>那么：</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Direct交换机是路由完全匹配规则，Topic交换机则是模式匹配（支持通配符）</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="消息队列高级篇"><a href="#消息队列高级篇" class="headerlink" title="消息队列高级篇"></a>消息队列高级篇</h2><h3 id="1-发送者可靠性"><a href="#1-发送者可靠性" class="headerlink" title="1.发送者可靠性"></a>1.发送者可靠性</h3><p>1.生产者重试机制</p><p>2生产者确认机制</p><h3 id="2-MQ的可靠性"><a href="#2-MQ的可靠性" class="headerlink" title="2.MQ的可靠性"></a>2.MQ的可靠性</h3><p>1.数据持久化</p><p>2.Lazy-Queue惰性队列</p><h3 id="3-消费者可靠性"><a href="#3-消费者可靠性" class="headerlink" title="3.消费者可靠性"></a>3.消费者可靠性</h3><p>1.消费者确认机制</p><p>2.失败重试机制</p><p>3.失败处理策略</p><p>消息处理失败后重新投递到处理消息失败的交换机当中，专门处理</p><p>4.业务幂等</p><p>解决消息重复处理问题</p><h3 id="3-延迟消息"><a href="#3-延迟消息" class="headerlink" title="3.延迟消息"></a>3.延迟消息</h3><h4 id="1-死信交换机和延迟消息"><a href="#1-死信交换机和延迟消息" class="headerlink" title="1.死信交换机和延迟消息"></a>1.死信交换机和延迟消息</h4><p>1.死信交换机</p><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>通过给队列添加<code>dead-letter-exchange</code>属性指定的交换机就是死信交换机。当该队列的消息成为死信后，即会把消息投递到这个指定的交换机当中。死信交换机配置如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlxExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;dlx.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;normal.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxqueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;dlx.queue&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;normal.queue&quot;</span>).deadLetterExchange(<span class="string">&quot;dlx.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">dlxBinding</span><span class="params">(Queue dlxqueue, DirectExchange dlxExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlxqueue).to(dlxExchange).with(<span class="string">&quot;dlx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">normalBinding</span><span class="params">(Queue normalQueue, DirectExchange normalExchange)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(<span class="string">&quot;dlx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20250226185117798.png" alt="image-20250226185117798"></p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><p>2.延迟消息</p><p>延迟消息是在publisher发送消息到交换机时给消息设置有效期expiration。则当正常队列里的消息没有被消费且过期时，会投递到死信交换机当中。使用场景比如订单限时支付，订单创建时就把消息（附带上过期时间）投递给正常交换机，同时不给正常队列设置消费者，到达过期时间则会投递到死信交换机，交给删除订单的listener处理。</p><h4 id="2-DelayExchange插件"><a href="#2-DelayExchange插件" class="headerlink" title="2.DelayExchange插件"></a>2.DelayExchange插件</h4><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。</p><p>官方文档说明：</p><p><a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p><p>插件下载地址：</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-06-19T09:22:59+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/mq-plugins/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mq-plugins&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。若不是，则根据自己定义的挂载目录上传。</p><p>接下来进入插件目录后执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>1.声明延迟交换机</p><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.发送延迟消息</p><p>发送消息时，必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rabbitmq 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习</title>
      <link href="/2025/02/14/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/02/14/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>内容参考黑马文档<a href="https://b11et3un53m.feishu.cn/wiki/MWQIw4Zvhil0I5ktPHwcoqZdnec">day02-Docker - 飞书云文档</a></p><h2 id="镜像定义"><a href="#镜像定义" class="headerlink" title="镜像定义"></a>镜像定义</h2><p>什么是镜像：将应用所需的函数库、依赖、配置等与应用一起打包得到的就是镜像。</p><p>简单来说类似于网上下的学习版游戏压缩包。</p><p>以下是镜像查询命令显示的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server01 tar]# docker images</span><br><span class="line">REPOSITORY                     TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.1ms.run/library/nginx   latest    97662d24417b   7 days ago    192MB</span><br><span class="line">docker.1ms.run/library/mysql   latest    c013d3763e14   3 weeks ago   797MB</span><br></pre></td></tr></table></figure><p>参数解释：</p><ol><li><strong><code>REPOSITORY</code>（仓库）</strong>：<ul><li>镜像的仓库名称，类似于软件包的来源。</li><li>例如：<ul><li><code>docker.1ms.run/library/nginx</code>：表示从<code>docker.1ms.run</code>镜像源拉取的<code>nginx</code>镜像。</li><li><code>nginx</code>：如果直接写<code>nginx</code>，则默认从Docker Hub官方仓库(可以修改镜像源)拉取。</li></ul></li><li>仓库名称可以包含镜像源的地址（如<code>docker.1ms.run/library</code>），也可以是简单的镜像名（如<code>nginx</code>）。</li></ul></li><li><strong><code>TAG</code>（标签）</strong>：<ul><li>镜像的版本标识符。</li><li>例如：<ul><li><code>latest</code>：表示最新版本。</li><li><code>5.7</code>、<code>8.0</code>：表示特定版本的镜像。</li></ul></li><li>如果不指定标签，默认为<code>latest</code>。</li></ul></li><li><strong><code>IMAGE ID</code>（镜像ID）</strong>：<ul><li>镜像的唯一标识符，是一个64位的哈希值。</li><li>每个镜像都有一个唯一的<code>IMAGE ID</code>，即使仓库和标签相同，<code>IMAGE ID</code>也可能不同，因为不同镜像源分层结构或配置可能不同。</li><li>示例：<code>97662d24417b</code>。</li></ul></li><li><strong><code>CREATED</code>（创建时间）</strong>：<ul><li>镜像的创建时间，表示该镜像从源仓库拉取或构建的时间。</li><li>示例：<code>7 days ago</code>表示镜像创建于7天前。</li></ul></li><li><strong><code>SIZE</code>（大小）</strong>：<ul><li>镜像的大小，表示镜像占用的磁盘空间。</li><li>示例：<code>192MB</code>表示<code>nginx</code>镜像大小为192MB，<code>797MB</code>表示<code>mysql</code>镜像大小为797MB。</li></ul></li></ol><h2 id="容器定义"><a href="#容器定义" class="headerlink" title="容器定义"></a>容器定义</h2><p>Docker会在运行镜像时创建一个隔离环境，称为容器（container）。</p><p>容器类似于学习版游戏解压后的文件，可以通过这个文件来进行运行游戏（实现所需功能），可以解压多个，每个解压后的文件互不干扰。</p><p>使用<code>docker run</code>命令即可创建容器，具体参数及解释在下面的常用命令里面。</p><p><strong>特点</strong>：</p><ul><li><strong>可运行</strong>：容器是镜像的运行实例，可以启动、停止、重启、删除等。</li><li><strong>隔离性</strong>：容器之间相互隔离，互不影响，即使多个容器运行在同一台宿主机上。</li><li><strong>临时性</strong>：容器的生命周期是临时的，删除容器后，其运行状态和数据会被清除（除非配置了数据卷）。</li><li><strong>轻量级</strong>：容器共享宿主机的内核，启动速度非常快（通常在秒级）。</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1-镜像操作"><a href="#1-镜像操作" class="headerlink" title="1. 镜像操作"></a>1. <strong>镜像操作</strong></h3><p><code>docker images</code> </p><p>查看本地已有的镜像，image翻译过来是镜像</p><p><code>docker pull</code></p><p>拉取镜像到本地，例如<code>docker pull mysql:8.0</code>,不带<code>:版本号</code>则拉取最新版本。若镜像源有问题，可以手动设置镜像源，例如<code>docker pull docker.1ms.run/library/mysql</code>，其中的docker.1ms.run就是目前可用的国内镜像源，也可以把镜像源修改到仓库，这样子docker pull优先访问设置的镜像源。</p><p><code>docker push</code></p><p>将本地镜像推送到镜像仓库</p><p><code>docker save</code></p><p>将镜像导出为一个tar文件，例如<code>docker save -o nginx.tar nginx:latest</code>。</p><p><code>docker load</code></p><p>加载导出的tar文件为镜像，例如<code>docker load -i nginx.tar</code></p><p><code>docker rmi</code></p><p>删除本地镜像，例如<code>docker rmi mysql:latest</code></p><h3 id="2-容器操作"><a href="#2-容器操作" class="headerlink" title="2.容器操作"></a>2.容器操作</h3><p><code>docker run</code> </p><p><strong>创建并运行</strong>容器，若容器不存在则会自动从镜像仓库pull到本地来，但因为自动是从官方地址pull，会很慢甚至出问题，所以需要换源，网上搜最新镜像源即可，我之前换了还是报错是因为cv下来的文件内容的数组最后多了一个逗号。。。。。</p><p>例如快速安装mysql</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以将<strong>宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ``=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><p><code>docker start</code> 启动本地容器，注意区分<code>docker run</code>，<code>docker run</code>每次执行都会创建一个新的容器。</p><p>启动已停止的容器</p><p><code>docker stop</code></p><p>停止正在运行的容器</p><p><code>docker ps</code></p><p>查看正在运行的容器。加上<code>-a</code>参数可以查看所有容器</p><p><code>docker logs</code></p><p>查看容器的运行日志</p><p><code>docker exec</code></p><p>进入正在运行的容器，例如<code>docker exec -it [container] bash</code>。这条命令会进入到容器的命令行，类似又一个linux系统，可以看到相关的文件。</p><h3 id="3-其他操作"><a href="#3-其他操作" class="headerlink" title="3.其他操作"></a>3.其他操作</h3><ul><li>**<code>docker inspect</code>**：查看容器或镜像的详细信息。</li><li>**<code>docker rm</code>**：删除容器。</li><li>**<code>docker restart</code>**：重新启动容器。</li></ul><p><strong>注意</strong>：具体需要什么参数可以使用 –help进行查阅，例如 <code>docker save --help</code> 可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 解释： [OPTIONS]表示可选项，可选项使用规则如下方解释；IMAGE [IMAGE...] 表示一个或多个镜像名称</span><br><span class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...] </span><br><span class="line"></span><br><span class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line"></span><br><span class="line">Aliases: //命令的别名</span><br><span class="line">  docker image save, docker save</span><br><span class="line"></span><br><span class="line">Options: // 可选项</span><br><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span><br><span class="line">//这段话表示指定tar文件存放路径，&#x27;-o&#x27;是‘--output’的缩写，string代表文件路径，使用规则是&#x27;-o 文件地址/文件名.tar&#x27;  </span><br><span class="line">//如果保存到当前目录，可以直接写文件名，如 -o my-image.tar。</span><br><span class="line">//如果保存到其他路径，可以写完整路径，如 -o /path/to/my-image.tar。</span><br></pre></td></tr></table></figure><h3 id="4-命令别名设置"><a href="#4-命令别名设置" class="headerlink" title="4.命令别名设置"></a>4.命令别名设置</h3><p>在路径为<code>/root/.bashrc</code>的文件里面可以设置命令的别名，方便在命令行调用常用命令。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27; //设置容器进程以规定格式查看的快捷命令，这里规定的格式比默认的格式更加清爽</span><br><span class="line">alias dis=&#x27;docker images&#x27; //查看所有镜像</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。大家思考几个问题：</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul><h3 id="1-什么是数据卷"><a href="#1-什么是数据卷" class="headerlink" title="1.什么是数据卷"></a>1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机</strong>目录之间映射的桥梁。</p><p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。</p><p>以挂载本地目录为例</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%8D%B7-%E5%AE%BF%E4%B8%BB%E4%B8%8E%E5%AE%B9%E5%99%A8.drawio.png" alt="数据卷-宿主与容器.drawio"></p><p>如上图所示，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机自定义的本地的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。</p><p>此时，我们操作宿主机的<code>/root/nginx/nginx.conf</code>就是在操作容器内的<code>/etc/nginx/nginx.conf</code>目录。</p><h3 id="2-数据卷的常见命令"><a href="#2-数据卷的常见命令" class="headerlink" title="2.数据卷的常见命令"></a>2.数据卷的常见命令</h3><table><thead><tr><th>docker volume create</th><th>创建数据卷</th></tr></thead><tbody><tr><td>docker volume ls</td><td>查看所有数据卷</td></tr><tr><td>docker volume rm</td><td>删除指定数据卷</td></tr><tr><td>docker volume inspect</td><td>查看某个数据卷的详情</td></tr><tr><td>docker volume prune</td><td>清除数据卷</td></tr></tbody></table><p>注意docker volume ls只能查到<code>/var/lib/docker/volumes</code>目录下的数据卷。</p><h3 id="3-如何挂载数据卷"><a href="#3-如何挂载数据卷" class="headerlink" title="3.如何挂载数据卷"></a>3.如何挂载数据卷</h3><p><strong>注意</strong>：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h4 id="1-默认挂载位置"><a href="#1-默认挂载位置" class="headerlink" title="1.默认挂载位置"></a>1.默认挂载位置</h4><p>具体演示（摘自黑马文档）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><p>如上述案例，在docker run命令中加入了 <code>-v html:/usr/share/nginx/html</code>,此时对应的宿主机为<code>/var/lib/docker/volumes/html/_data</code>。</p><p>因为命令中的宿主机存放目录没有 <code>./</code> 或者 <code>/</code>为开头，则会将其认定为数据卷名，文件默认在<code>/var/lib/docker/volumes/</code>下创建<code>数据卷名/_data</code>目录，里面存放具体对应的数据。</p><h4 id="2-挂载本地目录"><a href="#2-挂载本地目录" class="headerlink" title="2.挂载本地目录"></a>2.挂载本地目录</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><p>具体演示（摘自黑马文档）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.删除原来的MySQL容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行新mysql容器，挂载本地目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span></span><br><span class="line"><span class="built_in">ls</span> -l mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">总用量 4</span><br><span class="line">drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf</span><br><span class="line">drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data</span><br><span class="line">drwxr-xr-x. 2 root    root   23 5月  19 15:11 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span></span><br><span class="line"><span class="built_in">ls</span> -l data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查看MySQL容器内数据</span></span><br><span class="line"><span class="comment"># 5.1.进入MySQL</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123</span><br><span class="line"><span class="comment"># 5.2.查看编码表</span></span><br><span class="line">show variables like <span class="string">&quot;%char%&quot;</span>;</span><br><span class="line"><span class="comment"># 5.3.结果，发现编码是utf8mb4没有问题</span></span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| Variable_name            | Value                          |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                        |</span><br><span class="line">| character_set_connection | utf8mb4                        |</span><br><span class="line">| character_set_database   | utf8mb4                        |</span><br><span class="line">| character_set_filesystem | binary                         |</span><br><span class="line">| character_set_results    | utf8mb4                        |</span><br><span class="line">| character_set_server     | utf8mb4                        |</span><br><span class="line">| character_set_system     | utf8mb3                        |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看数据</span></span><br><span class="line"><span class="comment"># 6.1.查看数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="comment"># 结果，hmall是黑马商城数据库</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| hmall              |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment"># 6.2.切换到hmall数据库</span></span><br><span class="line">use hmall;</span><br><span class="line"><span class="comment"># 6.3.查看表</span></span><br><span class="line">show tables;</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_hmall |</span><br><span class="line">+-----------------+</span><br><span class="line">| address         |</span><br><span class="line">| cart            |</span><br><span class="line">| item            |</span><br><span class="line">| order           |</span><br><span class="line">| order_detail    |</span><br><span class="line">| order_logistics |</span><br><span class="line">| pay_order       |</span><br><span class="line">| user            |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="comment"># 6.4.查看address表数据</span></span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| <span class="built_in">id</span> | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  |</span><br><span class="line">| 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  |</span><br><span class="line">| 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  |</span><br><span class="line">| 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><strong>全部摘自黑马文档，太详细了</strong></p><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢？</p><h3 id="1-镜像结构"><a href="#1-镜像结构" class="headerlink" title="1.镜像结构"></a>1.镜像结构</h3><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MTFmMDUyMzUyNTAxNGUxODgzYjAwMWE0ZTQ5NWUyZWRfUzV2WU5BM3VvYXpRM3hWQUR6bDhMemdjTW94S2lKQ25fVG9rZW46SE1Fa2JYTVJ5b1ZDWTl4azdLZWMzUXF1bk9kXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA" alt="img"></p><h3 id="2-Dockerfile"><a href="#2-Dockerfile" class="headerlink" title="2.Dockerfile"></a>2.Dockerfile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>同学们思考一下：以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>是不是简单多了。</p><h3 id="3-构建镜像"><a href="#3-构建镜像" class="headerlink" title="3.构建镜像"></a>3.构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。</p><p>在课前资料中，我们准备好了一个demo项目及对应的Dockerfile：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MjhiYWJlODdhZDhiOWVjNzVmNzI2NWQ0NzRjZWJlMzBfZGVIeXIzTEljRHVaYVkxSDNtNTQ2dHN1VXdreW8wU1hfVG9rZW46SWFYWGJSeXJ1b2ZzeXF4a1h5M2N1SkJpbnVmXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA" alt="img"></p><p>首先，我们将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YWVhN2E1YWI1MmY2ZTJkMGU2MDVkY2EzNDJjOGJkNzNfdE1iQmNtVUVMMTd2d1ZGMjhZMWZ2a1gxSGRuZFRWcTJfVG9rZW46RGFOeGJ3Tjg0bzdtRWx4N3A0OGNRU1NTbnJlXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA" alt="img"></p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<ul><li><pre><code class="Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">![img](https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MTdhZWY2ZjI3OTAxMDcwNmZjNGYwNDRmM2M3ZDQzNmZfUDUxZG5lTGlNYTlsQmV5THNUbjdkUXhNdTdVeGJRem1fVG9rZW46R0RqMmJzeDFzb0Q0eXV4N3hLWmNXcHoxbmhlXzE3Mzk1MzQ5OTk6MTczOTUzODU5OV9WNA)</span><br><span class="line"></span><br><span class="line">查看镜像列表：</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line"># 查看镜像列表：</span><br><span class="line">docker images</span><br><span class="line"># 结果</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">docker-demo   1.0       d6ab0b9e64b9   27 minutes ago   327MB</span><br><span class="line">nginx         latest    605c77e624dd   16 months ago    141MB</span><br><span class="line">mysql         latest    3218b38490ce   17 months ago    516MB</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>然后尝试运行该镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run -d --name <span class="built_in">dd</span> -p 8080:8080 docker-demo:1.0</span><br><span class="line"><span class="comment"># 2.查看容器</span></span><br><span class="line">dps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES</span><br><span class="line">78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   <span class="built_in">dd</span></span><br><span class="line">f63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.访问</span></span><br><span class="line">curl localhost:8080/hello/count</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>在docker中，不同容器之间可以互相访问，前提是<strong>加入到同一个网络</strong>中。</p><p>容器在<code>docker run</code>时若没有指定网络，则会默认加入到一个固定的网络中，每次容器启动时，该网络都会分配给容器一个ip。因为该网络无法通过容器名访问，必须通过该网络分配给容器的ip地址进行访问，而容器ip是动态变化的，所以当我们写死项目访问其他中间件的ip时肯定会出问题。而在<strong>自定义网络</strong>中，则可以<strong>通过容器名或别名访问到该容器，无需指定ip地址</strong>。</p><p>在java项目中，往往需要访问其它各种中间件，例如MySQL、Redis等,那么容器之间是否可以相互访问呢？</p><p>首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.用基本命令，寻找Networks.bridge.IPAddress属性</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 也可以使用format过滤结果</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mysql</span><br><span class="line"><span class="comment"># 得到IP地址如下：</span></span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后通过命令进入dd容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在容器内，通过ping命令测试网络</span></span><br><span class="line">ping 172.17.0.2</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms</span><br></pre></td></tr></table></figure><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定（即每次启动容器时，其ip都会发生变化），如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><p>教学演示：自定义网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><p>OK，现在无需记住IP地址也可以实现容器互联了。</p><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h3 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1.基本语法"></a>3.3.1.基本语法</h3><p>docker-compose.yml文件的基本语法可以参考官方文档：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span> <span class="string">//实际指的网络名是hmall</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span> <span class="string">//代称，虽然上面指定的网络是new，但创建出来后其实是下面的hmall</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span> <span class="string">//实际自定义的网络名</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p><p>黑马商城部署文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p><p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><p>教学演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network hmall    Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container hmall  Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE</span><br><span class="line">hmall               root-hmall          latest              32eebee16acd        362MB</span><br><span class="line">mysql               mysql               latest              3218b38490ce        516MB</span><br><span class="line">nginx               nginx               latest              605c77e624dd        141MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS</span><br><span class="line">hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp</span><br><span class="line">mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2025/02/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2025/02/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>指的是把内存中的数据写入磁盘中。因为redis是基于内存进行数据存储的，当服务器关闭或者重启时，内存中的数据会丢失，所以需要通过持久化机制，来把数据定期自动或者按需手动保存到磁盘中，以便服务器启动时恢复数据。<br>实现方法分为如下两种</p><h3 id="1-RDB-Redis-DataBase"><a href="#1-RDB-Redis-DataBase" class="headerlink" title="1.RDB(Redis DataBase)"></a>1.RDB(Redis DataBase)</h3><p>是什么：在指定的时间间隔内，执行数据集的时间点快照，快照文件就是RDB文件（例如dump.rdb）。当Redis重启时，会加载这个<code>.rdb</code>文件，直接将文件中的数据加载到内存中。</p><h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><p>位于redis.conf配置文件的snapshot模块中</p><ol><li><code>save  &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]</code>  大概位于第440行<br>用于配置使时间间隔和数据修改次数，及每个一段固定时间查看当前redis修改数据的次数，超过了设定的i修改次数则进行快照。</li><li><code>dir 文件位置</code>(例如 &#x2F;root&#x2F;myredis&#x2F;dumpfiles) 大概位于第510行<br>用于设置rdb文件存放的位置</li><li><code>dbfilename 文件名</code>（例如dump6379.rdb） 大概位于第487行<br>用于设置rdb文件的名字</li><li>stop-writes-on-bgsave-error</li><li>rdbcompression</li><li>rdbchecksum</li><li>rdb-del-sync-files</li></ol><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>1.配置文件中的默认快照</p><p>根据配置文件中的save进行自动快照操作。</p><p>2.主从复制</p><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><h5 id="1-save"><a href="#1-save" class="headerlink" title="1.save"></a>1.save</h5><ul><li><strong>功能</strong>：<code>SAVE</code> 命令用于在主线程中同步生成 RDB 文件，将当前 Redis 数据库的数据快照保存到磁盘上。</li><li><strong>执行过程</strong>：执行 <code>SAVE</code> 命令时，Redis 会阻塞主线程，直到 RDB 文件创建完成。在此期间，Redis 无法处理其他客户端的任何请求。</li><li><strong>适用场景</strong>：由于其阻塞特性，<code>SAVE</code> 命令通常不适用于生产环境，尤其是在数据量较大时，可能会导致长时间的阻塞。</li></ul><h5 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2.bgsave"></a>2.bgsave</h5><ul><li><strong>功能</strong>：<code>BGSAVE</code> 命令用于异步生成 RDB 文件。它通过创建一个子进程来执行数据快照操作，而主线程继续处理客户端请求。</li><li><strong>执行过程</strong>：<ul><li>主进程调用 <code>fork()</code> 创建一个子进程。</li><li>子进程负责将内存中的数据写入到磁盘上的临时文件中。</li><li>写入完成后，子进程会用新生成的临时文件替换旧的 RDB 文件。</li><li>主进程在整个过程中几乎不受影响，只有在 <code>fork()</code> 阶段会有短暂的阻塞。</li></ul></li><li><strong>适用场景</strong>：<code>BGSAVE</code> 是推荐的持久化命令，尤其适用于生产环境。它可以在不影响 Redis 正常服务的情况下，完成数据的持久化操作。</li></ul><h5 id="3-特殊命令"><a href="#3-特殊命令" class="headerlink" title="3.特殊命令"></a>3.特殊命令</h5><ul><li>执行flushall&#x2F;flushdb命令也会产生dump.rdb文件，但里面是空的，无意义。</li><li>执行shutdown且没有设置开启AOF持久化也会产生dump.rdb文件。</li></ul><h3 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2.AOF(Append Only File)"></a>2.AOF(Append Only File)</h3><p>是什么：AOF是Redis的一种持久化机制，它通过将Redis执行的写操作命令以追加的方式记录到一个日志文件（通常是<code>appendonly.aof</code>）中来实现数据的持久化。在Redis重启时，会加载AOF文件，重新执行其中记录的命令，从而恢复数据。</p><h4 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h4><p>位于redis.conf配置文件的append only模块中</p><ol><li><p><code>appendonly yes/no</code></p><p>用于设置是否启用AOF,默认只启用RDB，不启用AOF。</p></li><li><p><code>dir 文件位置</code></p><p>用于指定<code>.aof</code>文件所在目录的存放的位置。</p></li><li><p><code>appenddirname 目录名</code></p><p>用于指定aof文件所在的目录</p><p>区分：</p><ul><li><p>redis7版本开始，.aof文件存放路径等于<code>dir下的文件位置/appenddirname目录名/xxx.aof</code></p></li><li><p>redis6版本时，.aof文件存放位置仅等于<code>dir下的文件位置/xxx.aof</code></p></li></ul></li><li><p><code>appendfilename 文件名</code></p><p>指定.aof的文件名称</p></li></ol><p><img src="/../images/image-20250205002000869.png" alt="image-20250205002000869"></p><h4 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h4><p>AOF的写回策略决定了Redis何时将内存中的命令写入到AOF文件中。Redis提供了三种写回策略，分别通过配置文件中的<code>appendfsync</code>参数来设置：</p><ol><li><strong><code>appendfsync always</code></strong><ul><li><strong>描述</strong>：每次写操作都会立即同步到AOF文件中。</li><li><strong>优点</strong>：数据安全性最高，即使Redis崩溃，也不会丢失任何数据。</li><li><strong>缺点</strong>：性能开销较大，因为每次写操作都会触发一次磁盘同步操作，可能会降低Redis的性能。</li></ul></li><li><strong><code>appendfsync everysec</code></strong><ul><li><strong>描述</strong>：每秒同步一次AOF文件。这是默认的写回策略。</li><li><strong>优点</strong>：在性能和数据安全性之间取得了较好的平衡。即使发生故障，最多只会丢失1秒内的数据。</li><li><strong>缺点</strong>：在极端情况下（如系统崩溃），可能会丢失1秒内的数据。</li></ul></li><li><strong><code>appendfsync no</code></strong><ul><li><strong>描述</strong>：不主动同步AOF文件，由操作系统决定何时同步。</li><li><strong>优点</strong>：性能开销最小，因为Redis不会主动触发磁盘同步操作。</li><li><strong>缺点</strong>：数据安全性最低，如果操作系统崩溃或Redis进程被意外终止，可能会丢失较多数据。</li></ul></li></ol><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>AOF文件会随着Redis的写操作不断增加，文件大小可能会变得很大。为了优化AOF文件的大小，Redis提供了AOF重写机制，通过生成一个新的AOF文件来替换旧的AOF文件，从而减小文件大小并提高性能。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li><strong>触发条件</strong>：<ul><li><strong>自动触发</strong>：可以通过配置文件中的<code>auto-aof-rewrite-percentage</code>和<code>auto-aof-rewrite-min-size</code>参数来设置自动触发条件。<ul><li><code>auto-aof-rewrite-percentage</code>：表示AOF文件大小增长的百分比。例如，设置为<code>100</code>，表示当AOF文件大小增长超过100%时，会触发重写。</li><li><code>auto-aof-rewrite-min-size</code>：表示AOF文件的最小大小。例如，设置为<code>64mb</code>，表示只有当AOF文件大小超过64MB时，才会触发重写。</li></ul></li><li><strong>手动触发</strong>：可以通过命令<code>BGREWRITEAOF</code>手动触发AOF重写。</li></ul></li><li><strong>重写过程</strong>：<ul><li>当触发AOF重写时，Redis会启动一个子进程来执行重写操作。</li><li>子进程会读取当前内存中的数据，并生成一个新的AOF文件，该文件只包含恢复当前数据集所需的最小命令集合。</li><li>在重写过程中，主进程会继续处理客户端的请求，并将新的写操作命令追加到一个临时缓冲区中。</li><li>当子进程完成重写后，主进程会将临时缓冲区中的命令追加到新的AOF文件中，然后用新的AOF文件替换旧的AOF文件。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>减小文件大小</strong>：通过生成一个新的AOF文件，只保留恢复当前数据集所需的最小命令集合，从而减小文件大小。</li><li><strong>提高性能</strong>：新的AOF文件更紧凑，加载速度更快，同时减少了磁盘空间的占用。</li></ul></li><li><strong>注意事项</strong>：<ul><li>AOF重写不会阻塞主进程，因为重写操作是由子进程完成的，主进程可以继续处理客户端的请求。</li><li>在重写过程中，主进程会将新的写操作命令追加到临时缓冲区中，以确保数据的完整性。</li></ul></li></ol><h3 id="3-RDB-AOF混合持久化"><a href="#3-RDB-AOF混合持久化" class="headerlink" title="3.RDB-AOF混合持久化"></a>3.RDB-AOF混合持久化</h3><h4 id="一、两种持久化方式优先级"><a href="#一、两种持久化方式优先级" class="headerlink" title="一、两种持久化方式优先级"></a><strong>一、两种持久化方式优先级</strong></h4><ul><li>当同时开启RDB和AOF两种持久化方式时，AOF的优先级高于RDB。若AOF文件存在并无损，则只加载AOF文件。</li></ul><h4 id="二、混合持久化开启"><a href="#二、混合持久化开启" class="headerlink" title="二、混合持久化开启"></a><strong>二、混合持久化开启</strong></h4><ol><li><p>​<strong>开启方式</strong></p><p>配置文件append only模块 <code>aof-use-rdb-preamble yes</code></p></li><li><p><strong>混合持久方式的数据执行流程</strong></p><p>（1）Redis启动时，会检查是否存在AOF文件（<code>appendonly.aof</code>）。如果存在且配置了混合持久化（<code>aof-use-rdb-preamble yes</code>），Redis会先加载AOF文件。</p><p>（2）检查AOF文件是否包含RDB快照</p><ul><li>如果AOF文件中包含RDB快照（即混合持久化模式），Redis会<strong>先加载RDB快照部分</strong>，快速恢复大部分数据。</li><li>然后，Redis会继续加载AOF文件中自RDB快照之后的<strong>增量日志</strong>，依次执行这些日志中的写操作，以恢复到最新的数据状态。</li><li><img src="/../images/image-20250205195353569.png" alt="混合持久化下的aof文件"></li></ul><p>（3）如果AOF文件不存在或损坏</p><ul><li>如果AOF文件不存在或损坏，Redis会尝试加载RDB文件（<code>dump.rdb</code>）。</li><li>如果RDB文件也不存在或损坏，Redis将无法恢复数据，启动时会报错。</li></ul><p>（4）数据恢复完成</p><p>完成上述步骤后，Redis的数据恢复过程结束，服务开始正常运行。</p></li></ol><p><img src="/../images/redis%E6%8C%81%E4%B9%85%E5%8C%96.png" alt="redis持久化"></p><h2 id="4-纯缓存模式"><a href="#4-纯缓存模式" class="headerlink" title="4.纯缓存模式"></a>4.纯缓存模式</h2><p><strong>定义</strong><br>纯缓存模式是指同时关闭RDB和AOF持久化功能，将Redis仅作为内存缓存使用，不进行任何数据持久化操作。</p><p><strong>1.关闭RDB</strong></p><p><code>save &quot;&quot;</code> 禁用rdb持久化模式下，仍然可以手动执行<code>save</code>、<code>bgsave</code>命令生成rdb文件</p><p><strong>2.关闭AOF</strong></p><p><code>appendonly no</code> 仍然可以手动执行<code>bgrewriteaof</code>生成aof文件</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尚庭公寓</title>
      <link href="/2024/12/26/%E5%B0%9A%E5%BA%AD%E5%85%AC%E5%AF%93/"/>
      <url>/2024/12/26/%E5%B0%9A%E5%BA%AD%E5%85%AC%E5%AF%93/</url>
      
        <content type="html"><![CDATA[<p>本文总结了尚庭公寓项目中遇到的技术知识点。</p><h2 id="1-项目目录结构设计"><a href="#1-项目目录结构设计" class="headerlink" title="1.项目目录结构设计"></a>1.项目目录结构设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lease</span><br><span class="line">├── common（公共模块——工具类、公用配置等）</span><br><span class="line">│   ├── pom.xml （包含公共模块编写所需的全部依赖）</span><br><span class="line">│   └── src</span><br><span class="line">├── model（数据模型——与数据库相对应地实体类）</span><br><span class="line">│   ├── pom.xml （包含数据模型编写所需的全部依赖）</span><br><span class="line">│   └── src</span><br><span class="line">├── web（Web模块）</span><br><span class="line">│   ├── pom.xml （包含common和model这个两个模块的依赖，以及该模块下所需的其他依赖）</span><br><span class="line">│   ├── web-admin（后台管理系统Web模块——包含mapper、service、controller）</span><br><span class="line">│   │   ├── pom.xml （做为web模块的子类项目）</span><br><span class="line">│   │   └── src</span><br><span class="line">│   └── web-app（移动端Web模块——包含mapper、service、controller）</span><br><span class="line">│       ├── pom.xml</span><br><span class="line">│       └── src</span><br><span class="line">└── pom.xml （统一管理子模块所有的依赖版本号）</span><br></pre></td></tr></table></figure><p>根模块的pom.xml文件中对相关依赖的版本号进行统一管理。</p><p>common、model和web模块均以lease根模块为父级项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ldy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lease<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而common和model模块做为公共模块，提供给web模块进行依赖调用</p><p>web模块的pom.xml文件如下所示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ldy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ldy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各个模块所需的依赖清晰规划好，可以减少依赖的冗余和减少重复配置</p><h2 id="2-实体类和接口的定义要点"><a href="#2-实体类和接口的定义要点" class="headerlink" title="2.实体类和接口的定义要点"></a>2.实体类和接口的定义要点</h2><ul><li><p>实体类中的公共字段（例如<code>id</code>、<code>create_time</code>、<code>update_time</code>、<code>is_deleted</code>）抽取到一个基类，进行统一管理，然后让各实体类继承该基类。</p></li><li><p>实体类中的状态字段（例如<code>status</code>）或类型字段（例如<code>type</code>），全部使用枚举类型。</p></li><li><blockquote><p>状态（类型）字段，在数据库中通常用一个数字表示一个状态（类型）。例如：订单状态（1:待支付，2:待发货，3:待收货，4:已收货，5:已完结）。若实体类中对应的字段也用数字类型，例如<code>int</code>，那么程序中就会有大量的如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">order.setStatus(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (order.getStatus() == <span class="number">1</span>) &#123;</span><br><span class="line">order.setStatus(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码后期维护起来会十分麻烦，所以本项目中所有的此类字段均使用枚举类型。例如上述订单状态可定义为以下枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    CANCEL(<span class="number">0</span>, <span class="string">&quot;已取消&quot;</span>),</span><br><span class="line">    WAIT_PAY(<span class="number">1</span>, <span class="string">&quot;待支付&quot;</span>),</span><br><span class="line">    WAIT_TRANSFER(<span class="number">2</span>, <span class="string">&quot;待发货&quot;</span>),</span><br><span class="line">    WAIT_RECEIPT(<span class="number">3</span>, <span class="string">&quot;待收货&quot;</span>),</span><br><span class="line">    RECEIVE(<span class="number">4</span>, <span class="string">&quot;已收货&quot;</span>),</span><br><span class="line">    COMPLETE(<span class="number">5</span>, <span class="string">&quot;已完结&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单实体类中的状态字段定义为<code>Status</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Integer id;</span><br><span class="line"> <span class="keyword">private</span> Integer userId;</span><br><span class="line"> <span class="keyword">private</span> Status status;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样上述代码便可调整为如下效果，后期维护起来会容易许多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order.setStatus(Status.WAIT_PAY);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>所有的实体类均实现了<code>Serializable</code>接口，方便对实体对象进行缓存。</p><p>因为实现Serializable接口的类可以被序列化，即将对象的状态转换为字节流，以便于存储和传输。在该项目中，是为了让实体类对象缓存到redis当中，当需要从缓存中读取对象时，可以通过反序列化恢复对象状态。</p></li><li><p>所有的<code>Mapper</code>接口均没有使用<code>@Mapper</code>注解，而是使用配置类中的<code>@MapperScan</code>注解统一扫描。</p></li><li><p>vo（View Object）：用于封装或定义接口接收及返回的数据的结构。</p></li><li><p>统一接口返回的数据结构：为方便前端对接口数据进行处理，统一接口返回数据结构是一个良好的习惯。</p><p>以下是该项目所有接口统一返回的数据结构</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正常&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以下是与上述结构相对应的Java类</p><ul><li><p>Result</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回消息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">null</span>)</span><br><span class="line">            result.setData(data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T body, ResultCodeEnum resultCodeEnum)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = build(body);</span><br><span class="line">        result.setCode(resultCodeEnum.getCode());</span><br><span class="line">        result.setMessage(resultCodeEnum.getMessage());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(data, ResultCodeEnum.SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">fail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="literal">null</span>, ResultCodeEnum.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">fail</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = build(<span class="literal">null</span>);</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ResultCodeEnum</p><p>为方便管理，可将返回码<code>code</code>和返回消息<code>message</code>封装到枚举类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCodeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">201</span>, <span class="string">&quot;失败&quot;</span>),</span><br><span class="line">    PARAM_ERROR(<span class="number">202</span>, <span class="string">&quot;参数不正确&quot;</span>),</span><br><span class="line">    SERVICE_ERROR(<span class="number">203</span>, <span class="string">&quot;服务异常&quot;</span>),</span><br><span class="line">    DATA_ERROR(<span class="number">204</span>, <span class="string">&quot;数据异常&quot;</span>),</span><br><span class="line">    ILLEGAL_REQUEST(<span class="number">205</span>, <span class="string">&quot;非法请求&quot;</span>),</span><br><span class="line">    REPEAT_SUBMIT(<span class="number">206</span>, <span class="string">&quot;重复提交&quot;</span>),</span><br><span class="line">    DELETE_ERROR(<span class="number">207</span>, <span class="string">&quot;请先删除子集&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ADMIN_ACCOUNT_EXIST_ERROR(<span class="number">301</span>, <span class="string">&quot;账号已存在&quot;</span>),</span><br><span class="line">    ADMIN_CAPTCHA_CODE_ERROR(<span class="number">302</span>, <span class="string">&quot;验证码错误&quot;</span>),</span><br><span class="line">    ADMIN_CAPTCHA_CODE_EXPIRED(<span class="number">303</span>, <span class="string">&quot;验证码已过期&quot;</span>),</span><br><span class="line">    ADMIN_CAPTCHA_CODE_NOT_FOUND(<span class="number">304</span>, <span class="string">&quot;未输入验证码&quot;</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ADMIN_LOGIN_AUTH(<span class="number">305</span>, <span class="string">&quot;未登陆&quot;</span>),</span><br><span class="line">    ADMIN_ACCOUNT_NOT_EXIST_ERROR(<span class="number">306</span>, <span class="string">&quot;账号不存在&quot;</span>),</span><br><span class="line">    ADMIN_ACCOUNT_ERROR(<span class="number">307</span>, <span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line">    ADMIN_ACCOUNT_DISABLED_ERROR(<span class="number">308</span>, <span class="string">&quot;该用户已被禁用&quot;</span>),</span><br><span class="line">    ADMIN_ACCESS_FORBIDDEN(<span class="number">309</span>, <span class="string">&quot;无访问权限&quot;</span>),</span><br><span class="line"></span><br><span class="line">    APP_LOGIN_AUTH(<span class="number">501</span>, <span class="string">&quot;未登陆&quot;</span>),</span><br><span class="line">    APP_LOGIN_PHONE_EMPTY(<span class="number">502</span>, <span class="string">&quot;手机号码为空&quot;</span>),</span><br><span class="line">    APP_LOGIN_CODE_EMPTY(<span class="number">503</span>, <span class="string">&quot;验证码为空&quot;</span>),</span><br><span class="line">    APP_SEND_SMS_TOO_OFTEN(<span class="number">504</span>, <span class="string">&quot;验证法发送过于频繁&quot;</span>),</span><br><span class="line">    APP_LOGIN_CODE_EXPIRED(<span class="number">505</span>, <span class="string">&quot;验证码已过期&quot;</span>),</span><br><span class="line">    APP_LOGIN_CODE_ERROR(<span class="number">506</span>, <span class="string">&quot;验证码错误&quot;</span>),</span><br><span class="line">    APP_ACCOUNT_DISABLED_ERROR(<span class="number">507</span>, <span class="string">&quot;该用户已被禁用&quot;</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TOKEN_EXPIRED(<span class="number">601</span>, <span class="string">&quot;token过期&quot;</span>),</span><br><span class="line">    TOKEN_INVALID(<span class="number">602</span>, <span class="string">&quot;token非法&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    ResultCodeEnum(Integer code, String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>枚举类的知识点</strong></p><p>枚举常量的初始化<br>每个枚举常量（如 SUCCESS, FAIL, PARAM_ERROR 等）在声明时会调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResultCodeEnum(Integer code, String message) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数，并传入相应的参数。例如：<br>SUCCESS(200, “成功”)：<br>调用 ResultCodeEnum(200, “成功”)，将 code 设为 200，message 设为 “成功”。<br>FAIL(201, “失败”)：<br>调用 ResultCodeEnum(201, “失败”)，将 code 设为 201，message 设为 “失败”。</p><p><strong>注意：</strong></p><p>由于<code>Result</code>和<code>ResultCodeEnum</code>中使用<code>@Data</code>、<code>@Getter</code>注解，因此需要再<strong>common模块</strong>中引入<code>lombok</code>依赖。</p></li></ul><h2 id="3-逻辑删除功能"><a href="#3-逻辑删除功能" class="headerlink" title="3.逻辑删除功能"></a>3.逻辑删除功能</h2><p>由于数据库中所有表均采用逻辑删除策略，所以查询数据时均需要增加过滤条件<code>is_deleted=0</code>。</p><p>上述操作虽不难实现，但是每个查询接口都要考虑到，也显得有些繁琐。为简化上述操作，可以使用Mybatis-Plus提供的逻辑删除功能，它可以自动为查询操作增加<code>is_deleted=0</code>过滤条件，并将删除操作转为更新语句。具体配置如下，详细信息可参考<a href="https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">官方文档</a>。</p><ul><li><p>步骤一：在<code>application.yml</code>中增加如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">flag</span> <span class="comment"># 全局逻辑删除的实体字段名(配置后可以忽略不配置步骤二)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li><li><p>步骤二：在实体类中的删除标识字段上增加<code>@TableLogic</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;主键&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;逻辑删除&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="meta">@TableField(&quot;is_deleted&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>逻辑删除功能只对Mybatis-Plus自动注入的sql起效，也就是说，对于手动在<code>Mapper.xml</code>文件配置的sql不会生效，需要单独考虑。</p></li></ul><p>该项目中因为is_deleted字段取值符合默认值，且所有实体类均继承BaseEntity，所以可以跳过步骤一，只需在isDeleted属性上添加<code>@TableLogic</code>注解即可。</p><h2 id="4-特定字段的忽略和自动填充"><a href="#4-特定字段的忽略和自动填充" class="headerlink" title="4.特定字段的忽略和自动填充"></a>4.特定字段的忽略和自动填充</h2><ul><li><p>特定字段的忽略<br>通常情况下接口响应的Json对象中并不需要<code>create_time</code>、<code>update_time</code>、<code>is_deleted</code>等字段，这时只需在实体类中的相应字段添加<code>@JsonIgnore</code>注解，该字段就会在序列化时被忽略。</p><p>具体配置如下，详细信息可参考Jackson<a href="https://github.com/FasterXML/jackson-annotations#annotations-for-ignoring-properties">官方文档</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;主键&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;create_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;update_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;逻辑删除&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(&quot;is_deleted&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动填充特定字段<br>保存或更新数据时，前端通常不会传入<code>isDeleted</code>、<code>createTime</code>、<code>updateTime</code>这三个字段，因此我们需要手动赋值。但是数据库中几乎每张表都有上述字段，所以手动去赋值就显得有些繁琐。为简化上述操作，我们可采取以下措施。</p><p><code>is_deleted</code>字段：可在数据库中设置该字段的默认值为0。</p><p><code>create_time</code>和<code>update_time</code>：可使用mybatis-plus的自动填充功能，所谓自动填充，就是通过统一配置，在插入或更新数据时，自动为某些字段赋值，具体配置如下，详细信息可参考<a href="https://baomidou.com/pages/4c6bcf/">官方文档</a>。</p><p>为相关字段配置触发填充的时机，例如<code>create_time</code>需要在插入数据时填充，而<code>update_time</code>需要在插入和更新数据时填充。具体配置如下，观察<code>@TableField</code>注解中的<code>fill</code>属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;主键&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;逻辑删除&quot;)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="meta">@TableField(&quot;is_deleted&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置自动填充的内容，具体配置如下</p><p>在<strong>common模块</strong>下创建<code>com.atguigu.lease.common.mybatisplus.MybatisMetaObjectHandler</code>类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//插入操作时，更新时间也要赋值</span></span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@TableField(fill &#x3D; …) 和 MetaObjectHandler 的关系</strong><br>@TableField(fill &#x3D; …) 注解和 MetaObjectHandler 类是协同工作的，但它们各自有不同的作用。为了确保自动填充功能正常生效，两者需要配合使用。</p><ol><li>@TableField(fill &#x3D; …) 注解的作用<br>指定自动填充规则：<br>在实体类字段上使用 @TableField(fill &#x3D; FieldFill.INSERT) 或 @TableField(fill &#x3D; FieldFill.INSERT_UPDATE) 等注解，明确指定了该字段在插入或更新操作时需要自动填充。<br>告知 MyBatis Plus：<br>这些注解告诉 MyBatis Plus 框架哪些字段需要在特定的操作（如插入或更新）时进行自动填充。</li><li>MetaObjectHandler 类的作用<br>实现具体的填充逻辑：<br>MetaObjectHandler 接口的实现类（如 MybatisMetaObjectHandler）定义了如何为这些字段赋值。<br>insertFill 和 updateFill 方法中具体实现了在插入和更新操作时为字段赋值的逻辑。</li><li>两者的关系<br>必须配合使用：<br>注解：@TableField(fill &#x3D; …) 注解用于标记哪些字段需要自动填充。<br>处理器：MetaObjectHandler 实现类提供了具体的填充逻辑。<br>如果只设置了注解而没有实现 MetaObjectHandler，则自动填充不会生效；反之，如果只实现了 MetaObjectHandler 而没有设置注解，框架也不会知道哪些字段需要自动填充。</li></ol><p>总之就是fill指定哪些字段<strong>可以</strong>在MetaObjectHandler 类的特定方法里进行填充，至于是否一定填充，则看是否在该特定方法里对该字段进行赋值。</p><p>因为该项目原先<code>update_time</code>是只记录更新的，但我觉得<code>update_time</code>应该在插入时也要赋初值，所以我进行了<code>fill=FieldFill.INSERT_UPDATE</code>的改动，但因为当时在MetaObjectHandler 类中的insertFill方法中没有添加如下对update_time字段赋值的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作时，更新时间也要赋值</span></span><br><span class="line"><span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure><p>导致插入时，<code>update_time</code>字段仍然没有自动填充，我想了挺久才定位到这个原因。</p></li></ul><h2 id="5-枚举类型转换"><a href="#5-枚举类型转换" class="headerlink" title="5.枚举类型转换"></a>5.枚举类型转换</h2><p>由于数据库中的状态值通常以数值类型表示，但我们在定义实体类的时候因为为了方便知道各个状态数值对应的状态而使用枚举类型表示。</p><p>以实体类的<strong>LabelInfo</strong>中的<strong>type</strong>为例，由于这个<strong>type</strong>字段在数据库、实体类、前后端交互的过程中有多种不同的形式，因此在请求和响应的过程中，<strong>type</strong>字段会涉及到多次类型转换。：</p><ul><li><p><strong>数据库中</strong></p><p>数据库中的<strong>type</strong>字段为<code>tinyint</code>类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-------------+--------------+</span><br><span class="line">| Field       | Type         |</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| id          | bigint       |</span><br><span class="line">| type        | tinyint      |</span><br><span class="line">| name        | varchar(255) |</span><br><span class="line">| create_time | timestamp    |</span><br><span class="line">| update_time | timestamp    |</span><br><span class="line">| is_deleted  | tinyint      |</span><br><span class="line">+-------------+--------------+</span><br></pre></td></tr></table></figure></li><li><p><strong>实体类</strong></p><p>实体类中的<strong>type</strong>字段为<code>ItemType</code>枚举类型</p><p><code>LabelInfo</code>实体类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Schema(description = &quot;标签信息表&quot;)</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;label_info&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LabelInfo</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;类型&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;type&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ItemType type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;标签名称&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemType</code>枚举类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ItemType</span> &#123;</span><br><span class="line"></span><br><span class="line">    APARTMENT(<span class="number">1</span>, <span class="string">&quot;公寓&quot;</span>),</span><br><span class="line">    ROOM(<span class="number">2</span>, <span class="string">&quot;房间&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ItemType(Integer code, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>前后端交互中</strong></p><p>前后端交互所传递的数据中<strong>type</strong>字段为<strong>数字</strong>（1&#x2F;2）。</p><p><img src="/../images/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%92%8C%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="请求参数和响应结果"></p></li></ul><p>具体转换过程如下图所示：</p><ul><li><p><strong>请求流程：</strong><br><img src="/../images/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0.drawio.png" alt="枚举类型转换过程-请求参数.drawio"></p><p>说明</p><ul><li>SpringMVC中的<code>WebDataBinder</code>组件负责将HTTP的请求参数绑定到Controller方法的参数（请求体的JSON字符串类型转换则交给<code>HTTPMessageConverter</code>组件），并实现参数类型的转换。</li><li>Mybatis中的<code>TypeHandler</code>用于处理Java中的实体对象与数据库之间的数据类型转换。</li></ul></li><li><p><strong>响应流程</strong><br><img src="/../images/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-%E5%93%8D%E5%BA%94%E4%BD%93.drawio.png" alt="枚举类型转换过程-响应体.drawio"></p><p><strong>说明</strong></p><ul><li>SpringMVC中的<code>HTTPMessageConverter</code>组件负责将<strong>Controller方法的返回值（Java对象）</strong>转换为HTTP响应体中的JSON字符串。</li><li>或者将<strong>请求体中的JSON字符串</strong>转换为Controller方法中的参数（Java对象），如下图所示。<br><img src="/../images/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-%E8%AF%B7%E6%B1%82%E4%BD%93.drawio.png" alt="枚举类型转换过程-请求体.drawio"></li></ul></li></ul><p>下面介绍一下每个环节的类型转换原理</p><ul><li><p><strong>WebDataBinder枚举类型转换</strong></p><p><code>WebDataBinder</code>依赖于<a href="https://docs.spring.io/spring-framework/reference/core/validation/convert.html"><code>Converter</code></a>实现类型转换，若Controller方法声明的<code>@RequestParam</code>参数的类型不是<code>String</code>，<code>WebDataBinder</code>就会自动进行数据类型转换。SpringMVC提供了常用类型的转换器，例如<code>String</code>到<code>Integer</code>、<code>String</code>到<code>Date</code>，<code>String</code>到<code>Boolean</code>等等，其中也包括<code>String</code>到枚举类型，但是<code>String</code>到枚举类型的默认转换规则是根据实例名称（”APARTMENT”）转换为枚举对象实例（ItemType.APARTMENT）。若想实现<code>code</code>属性到枚举对象实例的转换，需要自定义<code>Converter</code>，代码如下，具体内容可参考<a href="https://docs.spring.io/spring-framework/reference/core/validation/convert.html#core-convert-Converter-API">官方文档</a>。</p><ul><li><p>在<strong>web-admin模块</strong>自定义<code>com.atguigu.lease.web.admin.custom.converter.StringToItemTypeConverter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToItemTypeConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, ItemType&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/*这里的code参数就是前端传过来需要进行类型转换的值</span></span><br><span class="line"><span class="comment">    所以这里转换器定义并添加FormatterRegistry后，主类下的所有Controller中的接收参数只要是ItemType类型，默认前端传过来的值都是他的code值*/</span></span><br><span class="line">    <span class="keyword">public</span> ItemType <span class="title function_">convert</span><span class="params">(String code)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ItemType value : ItemType.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.getCode().equals(Integer.valueOf(code))) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;code非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册上述的<code>StringToItemTypeConverter</code>，在<strong>web-admin模块</strong>创建<code>com.atguigu.lease.web.admin.custom.config.WebMvcConfiguration</code>，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringToItemTypeConverter stringToItemTypeConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        registry.addConverter(<span class="built_in">this</span>.stringToItemTypeConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是我们有很多的枚举类型都需要考虑类型转换这个问题，按照上述思路，我们需要为每个枚举类型都定义一个Converter，并且每个Converter的转换逻辑（code值–&gt;枚举类）都完全相同，针对这种情况，我们使用<a href="https://docs.spring.io/spring-framework/reference/core/validation/convert.html#core-convert-ConverterFactory-SPI"><code>ConverterFactory</code></a>接口更为合适，这个接口可以将同一个转换逻辑应用到一个接口的所有实现类，因此我们可以定义一个<code>BaseEnum</code>接口，然后令所有的枚举类都实现该接口，然后就可以自定义<code>ConverterFactory</code>，集中编写各枚举类的转换逻辑了。具体实现如下：</p><ul><li><p>在<strong>model模块</strong>定义<code>com.atguigu.lease.model.enums.BaseEnum</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseEnum</span> &#123;</span><br><span class="line">    Integer <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>令所有<code>com.atguigu.lease.model.enums</code>包下的枚举类都实现<code>BaseEnun</code>接口</p></li><li><p>在<strong>web-admin模块</strong>自定义<code>com.atguigu.lease.web.admin.custom.converter.StringToBaseEnumConverterFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBaseEnumConverterFactory</span> <span class="keyword">implements</span> <span class="title class_">ConverterFactory</span>&lt;String, BaseEnum&gt; &#123;</span><br><span class="line">    <span class="comment">//因为Converter&lt;String（前端所传数据类型）, T（后端所接受的数据类型）&gt;是一个接口，所以还要进行内部类的convert方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">BaseEnum</span>&gt; Converter&lt;String, T&gt; <span class="title function_">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> T <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line"><span class="comment">//遍历目标枚举类型的所有枚举值，将其code值和source值进行比较</span></span><br><span class="line">                <span class="keyword">for</span> (T enumConstant : targetType.getEnumConstants()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (enumConstant.getCode().equals(Integer.valueOf(source))) &#123;</span><br><span class="line">                        <span class="keyword">return</span> enumConstant;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;非法的枚举值:&quot;</span> + source);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册上述的<code>ConverterFactory</code>，在<strong>web-admin模块</strong>创建<code>com.atguigu.lease.web.admin.custom.config.WebMvcConfiguration</code>，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringToBaseEnumConverterFactory stringToBaseEnumConverterFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        registry.addConverterFactory(<span class="built_in">this</span>.stringToBaseEnumConverterFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>本项目最终采用的是<code>ConverterFactory</code>方案，因此<code>StringToItemTypeConverter</code>相关代码可以直接删除。</p></li></ul></li><li><p><strong>TypeHandler枚举类型转换</strong></p><p>Mybatis预置的<code>TypeHandler</code>可以处理常用的数据类型转换，例如<code>String</code>、<code>Integer</code>、<code>Date</code>等等，其中也包含枚举类型，但是枚举类型的默认转换规则是枚举对象实例（ItemType.APARTMENT）和实例名称（”APARTMENT”）相互映射。若想实现<code>code</code>属性到枚举对象实例的相互映射，需要自定义<code>TypeHandler</code>。</p><p>不过MybatisPlus提供了一个<a href="https://baomidou.com/pages/8390a4/">通用的处理枚举类型的TypeHandler</a>。其使用十分简单，只需在<code>ItemType</code>枚举类的<code>code</code>属性上增加一个注解<code>@EnumValue</code>，Mybatis-Plus便可完成从<code>ItemType</code>对象到<code>code</code>属性之间的相互映射，具体配置如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ItemType</span> &#123;</span><br><span class="line"></span><br><span class="line">    APARTMENT(<span class="number">1</span>, <span class="string">&quot;公寓&quot;</span>),</span><br><span class="line">    ROOM(<span class="number">2</span>, <span class="string">&quot;房间&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ItemType(Integer code, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>HTTPMessageConverter枚举类型转换</strong></p><p><code>HttpMessageConverter</code>依赖于Json序列化框架（默认使用Jackson）。其对枚举类型的默认处理规则也是枚举对象实例（ItemType.APARTMENT）和实例名称（”APARTMENT”）相互映射。不过其提供了一个注解<code>@JsonValue</code>，同样只需在<code>ItemType</code>枚举类的<code>code</code>属性上增加一个注解<code>@JsonValue</code>，Jackson便可完成从<code>ItemType</code>对象到<code>code</code>属性之间的互相映射。具体配置如下，详细信息可参考Jackson<a href="https://fasterxml.github.io/jackson-annotations/javadoc/2.8/com/fasterxml/jackson/annotation/JsonValue.html">官方文档</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ItemType</span> &#123;</span><br><span class="line"></span><br><span class="line">    APARTMENT(<span class="number">1</span>, <span class="string">&quot;公寓&quot;</span>),</span><br><span class="line">    ROOM(<span class="number">2</span>, <span class="string">&quot;房间&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">  <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ItemType(Integer code, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-图片上传管理"><a href="#6-图片上传管理" class="headerlink" title="6.图片上传管理"></a>6.图片上传管理</h2><p>由于公寓、房间等实体均包含图片信息，所以在新增或修改公寓、房间信息时，需要上传图片，因此我们需要实现一个上传图片的接口。</p><p><strong>1. 图片上传流程</strong></p><p>下图展示了新增房间或公寓时，上传图片的流程。</p><p><img src="/../images/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88.drawio.png" alt="图片存储方案.drawio"></p><p>可以看出图片上传接口接收的是图片文件，返回的Minio对象的URL。</p><p><strong>2. 图片上传接口开发</strong></p><p>下面为该接口的具体实现</p><ul><li><p><strong>配置Minio Client</strong></p><ul><li><p>引入Minio Maven依赖</p><p>在<strong>common模块</strong>的<code>pom.xml</code>文件增加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Minio相关参数</p><p>在<code>application.yml</code>中配置Minio的<code>endpoint</code>、<code>accessKey</code>、<code>secretKey</code>、<code>bucketName</code>等参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minio:</span></span><br><span class="line">  <span class="attr">endpoint:</span> <span class="string">http://&lt;hostname&gt;:&lt;port&gt;</span></span><br><span class="line">  <span class="attr">access-key:</span> <span class="string">&lt;access-key&gt;</span></span><br><span class="line">  <span class="attr">secret-key:</span> <span class="string">&lt;secret-key&gt;</span></span><br><span class="line">  <span class="attr">bucket-name:</span> <span class="string">&lt;bucket-name&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上述<code>&lt;hostname&gt;</code>、<code>&lt;port&gt;</code>等信息需根据实际情况进行修改。</p></li><li><p>在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.minio.MinioProperties</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;minio&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.minio.MinioConfiguration</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MinioProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MinioProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MinioClient <span class="title function_">minioClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MinioClient.builder().endpoint(properties.getEndpoint()).credentials(properties.getAccessKey(), properties.getSecretKey()).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>开发图片上传接口</strong></p><ul><li><p>编写Controller层逻辑</p><p>在<code>FileUploadController</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tag(name = &quot;文件管理&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/file&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FileService fileService;</span><br><span class="line">    <span class="meta">@Operation(summary = &quot;上传文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> fileService.upload(file);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(url);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><code>MultipartFile</code>是Spring框架中用于处理文件上传的类，它包含了上传文件的信息（如文件名、文件内容等）。</p></li><li><p>编写Service层逻辑</p><ul><li><p>在<code>FileService</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>FileServiceImpl</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MinioClient minioClient;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MinioProperties minioProperties;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> minioClient.bucketExists(BucketExistsArgs.builder().bucket(minioProperties.getBucketName()).build());</span><br><span class="line">        <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">            <span class="comment">//若该桶不存在，则创建桶并设置访问权限</span></span><br><span class="line">            minioClient.makeBucket(MakeBucketArgs.builder().bucket(minioProperties.getBucketName()).build());</span><br><span class="line">            minioClient.setBucketPolicy(SetBucketPolicyArgs.builder().</span><br><span class="line">                    bucket(minioProperties.getBucketName()).</span><br><span class="line">                    config(createBucketPolicyConfig(minioProperties.getBucketName())).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件命名为 日期+UUID+文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()) +</span><br><span class="line">            <span class="string">&quot;/&quot;</span> + UUID.randomUUID() + <span class="string">&quot;-&quot;</span> + file.getOriginalFilename();</span><br><span class="line">        minioClient.putObject(</span><br><span class="line">                PutObjectArgs.builder()</span><br><span class="line">                        .bucket(minioProperties.getBucketName())</span><br><span class="line">                        .stream(file.getInputStream(), file.getSize(), -<span class="number">1</span>)</span><br><span class="line">                        .object(filename)</span><br><span class="line">                        .contentType(file.getContentType())</span><br><span class="line">                        .build()</span><br><span class="line">                );</span><br><span class="line">    <span class="comment">//返回图片的url</span></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;/&quot;</span>, minioProperties.getEndpoint(), minioProperties.getBucketName(), filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">createBucketPolicyConfig</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">              &quot;Statement&quot; : [ &#123;</span></span><br><span class="line"><span class="string">                &quot;Action&quot; : &quot;s3:GetObject&quot;,</span></span><br><span class="line"><span class="string">                &quot;Effect&quot; : &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">                &quot;Principal&quot; : &quot;*&quot;,</span></span><br><span class="line"><span class="string">                &quot;Resource&quot; : &quot;arn:aws:s3:::%s/*&quot;</span></span><br><span class="line"><span class="string">              &#125; ],</span></span><br><span class="line"><span class="string">              &quot;Version&quot; : &quot;2012-10-17&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.formatted(bucketName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>上述<code>createBucketPolicyConfig</code>方法的作用是生成用于描述指定bucket访问权限的JSON字符串。最终生成的字符串格式如下，其表示，允许(<code>Allow</code>)所有人(<code>*</code>)获取(<code>s3:GetObject</code>)指定桶(<code>&lt;bucket-name&gt;</code>)的内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Action&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;s3:GetObject&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Effect&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Principal&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Resource&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;arn:aws:s3:::&lt;bucket-name&gt;/*&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>由于公寓、房间的图片为公开信息，所以将其设置为所有人可访问。</p></li></ul></li></ul></li></ul><h2 id="7-全局异常处理"><a href="#7-全局异常处理" class="headerlink" title="7.全局异常处理"></a>7.全局异常处理</h2><p>在处理信息时，若遇到有问题的数据，可以手动抛出异常，配置全局异常处理器对该异常进行捕获并返回相应的响应结果，只需要自定义一个异常类，并构造接收合适参数的构造器即可。</p><p>为灵活设置响应信息，可自定义异常类，如下</p><p>在<strong>common模块</strong>创建<code>com.atguigu.lease.common.exception.LeaseException</code>类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常状态码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过状态码和错误消息创建异常对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaseException</span><span class="params">(String message, Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据响应结果枚举对象创建异常对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCodeEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaseException</span><span class="params">(ResultCodeEnum resultCodeEnum)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(resultCodeEnum.getMessage());</span><br><span class="line">        <span class="built_in">this</span>.code = resultCodeEnum.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LeaseException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;, message=&quot;</span> + <span class="built_in">this</span>.getMessage() +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局异常处理器设置于<strong>common模块</strong>的<code>com.atguigu.lease.common.exception.GlobalExceptionHandler</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exception</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.fail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(LeaseException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">LeaseException</span><span class="params">(LeaseException e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.build(e.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为Result新增一个构造方法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">    Result&lt;T&gt; result = build(<span class="literal">null</span>);</span><br><span class="line">    result.setCode(code);</span><br><span class="line">    result.setMessage(message);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在认为有问题，可以直接返回结果时，即可通过抛出异常（注意带上结构枚举参数或者msg值+code值）让全局异常处理器返回响应结果，不需要再经由controller返回。</p><h2 id="8-登陆管理"><a href="#8-登陆管理" class="headerlink" title="8.登陆管理"></a>8.登陆管理</h2><p>以后台管理的登录为例，跟移动端差不多，就少了个短信验证功能。</p><h4 id="8-1-背景知识"><a href="#8-1-背景知识" class="headerlink" title="8.1 背景知识"></a>8.1 背景知识</h4><p><strong>1. 认证方案概述</strong></p><p>有两种常见的认证方案，分别是基于<strong>Session</strong>的认证和基于<strong>Token</strong>的认证，下面逐一进行介绍</p><ul><li><p><strong>基于Session</strong></p><p>基于Session的认证流程如下图所示</p><p><img src="/../images/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8ESession.drawio.png"></p><p>该方案的特点</p><ul><li>登录用户信息保存在服务端内存中，若访问量增加，单台节点压力会较大</li><li>随用户规模增大，若后台升级为集群，则需要解决集群中各服务器登录状态共享的问题。</li></ul></li><li><p><strong>基于Token</strong></p><p>基于Token的认证流程如下图所示</p><p><img src="/../images/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EToken.drawio.png"></p><p>该方案的特点</p><ul><li>登录状态保存在客户端，服务器没有存储开销</li><li>客户端发起的每个请求自身均携带登录状态，所以即使后台为集群，也不会面临登录状态共享的问题。</li></ul></li></ul><p><strong>2. Token详解</strong></p><p>本项目采用基于Token的登录方案，下面详细介绍Token这一概念。</p><p>我们所说的Token，通常指<strong>JWT</strong>（JSON Web TOKEN）。JWT是一种轻量级的安全传输方式，用于在两个实体之间传递信息，通常用于身份验证和信息传递。</p><p>JWT是一个字符串，如下图所示，该字符串由三部分组成，三部分由<code>.</code>分隔。三个部分分别被称为</p><ul><li><code>header</code>（头部）</li><li><code>payload</code>（负载）</li><li><code>signature</code>（签名）</li></ul><p><img src="/../images/JWT.png"></p><p>各部分的作用如下</p><ul><li><p><strong>Header（头部）</strong></p><p>Header部分是由一个JSON对象经过<code>base64url</code>编码得到的，这个JSON对象用于保存JWT 的类型（<code>typ</code>）、签名算法（<code>alg</code>）等元信息，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Payload（负载）</strong></p><p>也称为 Claims（声明），也是由一个JSON对象经过<code>base64url</code>编码得到的，用于保存要传递的具体信息。JWT规范定义了7个官方字段，如下：</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除此之外，我们还可以自定义任何字段，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Signature（签名）</strong></p><p>由头部、负载和秘钥一起经过（header中指定的签名算法）计算得到的一个字符串，用于防止消息被篡改。</p></li></ul><h4 id="8-2-登录流程"><a href="#8-2-登录流程" class="headerlink" title="8.2 登录流程"></a>8.2 登录流程</h4><p>后台管理系统的登录流程如下图所示</p><p><img src="/../images/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.drawio.png"></p><p>根据上述登录流程，可分析出，登录管理共需三个接口，分别是<strong>获取图形验证码</strong>、<strong>登录</strong>、<strong>获取登录用户个人信息</strong>，除此之外，我们还需为所有受保护的接口增加验证JWT合法性的逻辑，这一功能可通过<code>HandlerInterceptor</code>来实现。</p><h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><h5 id="1-获取图形验证码"><a href="#1-获取图形验证码" class="headerlink" title="1.获取图形验证码"></a><strong>1.获取图形验证码</strong></h5><ul><li><p><strong>查看响应的数据结构</strong></p><p>查看<strong>web-admin模块</strong>下的<code>com.atguigu.lease.web.admin.vo.login.CaptchaVo</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;图像验证码&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description=&quot;验证码图片信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description=&quot;验证码key&quot;)</span> <span class="comment">//校验时，会通过key在redis中查找答案，再和填入值进行比较</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置所需依赖</strong></p><ul><li><p><strong>验证码生成工具</strong></p><p>本项目使用开源的验证码生成工具<strong>EasyCaptcha</strong>，其支持多种类型的验证码，例如gif、中文、算术等，并且简单易用，具体内容可参考其<a href="https://gitee.com/ele-admin/EasyCaptcha">官方文档</a>。</p><p>在<strong>common模块</strong>的pom.xml文件中增加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.whvcse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easy-captcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Redis</strong></p><p>在<strong>common模块</strong>的pom.xml中增加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中增加如下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">&lt;hostname&gt;</span></span><br><span class="line">      <span class="attr">port:</span> <span class="string">&lt;port&gt;</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上述<code>hostname</code>和<code>port</code>需根据实际情况进行修改</p></li></ul></li><li><p><strong>编写Controller层逻辑</strong></p><p>在<code>LoginController</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;获取图形验证码&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;login/captcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;CaptchaVo&gt; <span class="title function_">getCaptcha</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CaptchaVo</span> <span class="variable">captcha</span> <span class="operator">=</span> service.getCaptcha();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(captcha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写Service层逻辑</strong></p><ul><li><p>在<code>LoginService</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CaptchaVo <span class="title function_">getCaptcha</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>LoginServiceImpl</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CaptchaVo <span class="title function_">getCaptcha</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SpecCaptcha</span> <span class="variable">specCaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpecCaptcha</span>(<span class="number">130</span>, <span class="number">48</span>, <span class="number">4</span>); <span class="comment">//长、宽、位数</span></span><br><span class="line">    specCaptcha.setCharType(Captcha.TYPE_DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> specCaptcha.text().toLowerCase(); <span class="comment">//验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstant.ADMIN_LOGIN_PREFIX + UUID.randomUUID(); </span><br><span class="line">    <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> specCaptcha.toBase64(); </span><br><span class="line">    redisTemplate.opsForValue().set(key, code, RedisConstant.ADMIN_LOGIN_CAPTCHA_TTL_SEC, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CaptchaVo</span>(image, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>知识点</strong>：</p><ul><li><p>本项目Reids中的key需遵循以下命名规范：<strong>项目名:功能模块名:其他</strong>，例如<code>admin:login:123456</code></p></li><li><p><code>spring-boot-starter-data-redis</code>已经完成了<code>StringRedisTemplate</code>的自动配置，我们直接注入即可。</p></li><li><p>为方便管理，可以将Reids相关的一些值定义为常量，例如key的前缀、TTL时长，内容如下。这些常量统一定义在<strong>common模块</strong>下的<code>com.atguigu.lease.common.constant.RedisConstant</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ADMIN_LOGIN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;admin:login:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ADMIN_LOGIN_CAPTCHA_TTL_SEC</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_LOGIN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;app:login:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">APP_LOGIN_CODE_RESEND_TIME_SEC</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">APP_LOGIN_CODE_TTL_SEC</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_ROOM_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;app:room:&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h5 id="2-登录接口"><a href="#2-登录接口" class="headerlink" title="2. 登录接口"></a>2. 登录接口</h5><ul><li><p><strong>登录校验逻辑</strong></p><p>用户登录的校验逻辑分为三个主要步骤，分别是<strong>校验验证码</strong>，<strong>校验用户状态</strong>和<strong>校验密码</strong>，具体逻辑如下</p><ul><li>前端发送<code>username</code>、<code>password</code>、<code>captchaKey</code>、<code>captchaCode</code>请求登录。</li><li>判断<code>captchaCode</code>是否为空，若为空，则直接响应<code>验证码为空</code>；若不为空进行下一步判断。</li><li>根据<code>captchaKey</code>从Redis中查询之前保存的<code>code</code>，若查询出来的<code>code</code>为空，则直接响应<code>验证码已过期</code>；若不为空进行下一步判断。</li><li>比较<code>captchaCode</code>和<code>code</code>，若不相同，则直接响应<code>验证码不正确</code>；若相同则进行下一步判断。</li><li>根据<code>username</code>查询数据库，若查询结果为空，则直接响应<code>账号不存在</code>；若不为空则进行下一步判断。</li><li>查看用户状态，判断是否被禁用，若禁用，则直接响应<code>账号被禁</code>；若未被禁用，则进行下一步判断。</li><li>比对<code>password</code>和数据库中查询的密码，若不一致，则直接响应<code>账号或密码错误</code>，若一致则进行入最后一步。</li><li>创建JWT，并响应给浏览器。</li></ul></li><li><p><strong>配置所需依赖</strong></p><p>登录接口需要为登录成功的用户创建并返回JWT，本项目使用开源的JWT工具<strong>Java-JWT</strong>，配置如下，具体内容可参考<a href="https://github.com/jwtk/jjwt/tree/0.11.2">官方文档</a>。</p><ul><li><p><strong>引入Maven依赖</strong></p><p>在<strong>common模块</strong>的pom.xml文件中增加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建JWT工具类</strong></p><p>在<strong>common模块</strong>下创建<code>com.atguigu.lease.common.utils.JwtUtil</code>工具类，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">tokenExpiration</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SecretKey</span> <span class="variable">tokenSignKey</span> <span class="operator">=</span> Keys.hmacShaKeyFor(<span class="string">&quot;M0PKKI6pYGVWWfDZw90a0lTpGYX1d4AQ&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createToken</span><span class="params">(Long userId, String username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder().</span><br><span class="line">                setSubject(<span class="string">&quot;USER_INFO&quot;</span>).</span><br><span class="line">                setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + tokenExpiration)).</span><br><span class="line">                claim(<span class="string">&quot;userId&quot;</span>, userId).</span><br><span class="line">                claim(<span class="string">&quot;username&quot;</span>, username).</span><br><span class="line">                signWith(tokenSignKey).</span><br><span class="line">                compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>，claim(自定义添加字段)用于向 JWT 中添加用户信息，因为本项目中在认证通过后需要获取用户的数据，通过jwt的解析，用户id和用户名username得到后可以满足该项目移动端的接口需求。</p></li><li><p><strong>编写HandlerInterceptor拦截器</strong></p><p>我们需要为所有受保护的接口增加校验JWT合法性的逻辑。具体实现如下</p><ul><li><p>在<code>JwtUtil</code>中增加<code>parseToken</code>方法，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseToken</span><span class="params">(String token)</span>&#123;</span><br><span class="line">    <span class="comment">//判断token是否为null</span></span><br><span class="line">    <span class="keyword">if</span>(token == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LeaseException</span>(ResultCodeEnum.ADMIN_LOGIN_AUTH);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回Claims(含有负载信息)给拦截器使用，若token存在问题则会直接抛出异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">JwtParser</span> <span class="variable">jwtParser</span> <span class="operator">=</span> Jwts.parserBuilder().setSigningKey(tokenSingKey).build();</span><br><span class="line">        <span class="keyword">return</span> jwtParser.parseClaimsJws(token).getBody();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ExpiredJwtException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LeaseException</span>(ResultCodeEnum.TOKEN_EXPIRED);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (JwtException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LeaseException</span>(ResultCodeEnum.TOKEN_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写HandlerInterceptor</strong></p><p>在<strong>web-admin模块</strong>中创建<code>com.atguigu.lease.web.admin.custom.interceptor.AuthenticationInterceptor</code>类，内容如下，有关<code>HanderInterceptor</code>的相关内容，可参考<a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet/handlermapping-interceptor.html">官方文档</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseToken(token);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> claims.get(<span class="string">&quot;username&quot;</span>, String.class);</span><br><span class="line">        LoginUserHolder.setLoginUser(<span class="keyword">new</span> <span class="title class_">LoginUser</span>(userId, username));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LoginUserHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>我们约定，前端登录后，后续请求都将JWT，放置于HTTP请求的Header中，其Header的key为<code>access-token</code>。</p></li><li><p><strong>注册HandlerInterceptor</strong></p><p>在<strong>web-admin模块</strong>的<code>com.atguigu.lease.web.admin.custom.config.WebMvcConfiguration</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationInterceptor authenticationInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"> registry.addInterceptor(<span class="built_in">this</span>.authenticationInterceptor).addPathPatterns(<span class="string">&quot;/admin/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/admin/login/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="3-获取登录用户个人信息"><a href="#3-获取登录用户个人信息" class="headerlink" title="3. 获取登录用户个人信息"></a>3. 获取登录用户个人信息</h5><ul><li><p><strong>查看请求和响应的数据结构</strong></p><ul><li><p><strong>响应的数据结构</strong></p><p>查看<strong>web-admin模块</strong>下的<code>com.atguigu.lease.web.admin.vo.system.user.SystemUserInfoVo</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Schema(description = &quot;员工基本信息&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemUserInfoVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户头像&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>请求的数据结构</strong></p><p>按理说，前端若想获取当前登录用户的个人信息，需要传递当前用户的<code>id</code>到后端进行查询。但是由于请求中携带的JWT中就包含了当前登录用户的<code>id</code>，故请求个人信息时，就无需再传递<code>id</code>。</p></li></ul></li><li><p><strong>编写ThreadLocal工具类</strong></p><p>理论上我们可以在Controller方法中，使用<code>@RequestHeader</code>获取JWT，然后在进行解析，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;获取登陆用户个人信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;SystemUserInfoVo&gt; <span class="title function_">info</span><span class="params">(<span class="meta">@RequestHeader(&quot;access-token&quot;)</span> String token)</span> &#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseToken(token);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">    <span class="type">SystemUserInfoVo</span> <span class="variable">userInfo</span> <span class="operator">=</span> service.getLoginUserInfo(userId);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的逻辑没有任何问题，但是这样做，JWT会被重复解析两次（一次在拦截器中，一次在该方法中）。为避免重复解析，通常会在拦截器将Token解析完毕后，将结果保存至<strong>ThreadLocal</strong>中，这样一来，我们便可以在整个请求的处理流程中进行访问了。</p><blockquote><p><strong>ThreadLocal概述</strong></p><p>ThreadLocal的主要作用是为每个使用它的线程提供一个独立的变量副本，使每个线程都可以操作自己的变量，而不会互相干扰，其用法如下图所示。</p><p><img src="/../images/ThreadLocal.drawio.png"></p></blockquote><p>在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.login.LoginUserHolder</code>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;LoginUser&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setLoginUser</span><span class="params">(LoginUser loginUser)</span> &#123;</span><br><span class="line">        threadLocal.set(loginUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoginUser <span class="title function_">getLoginUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在<strong>common模块</strong>中创建<code>com.atguigu.lease.common.login.LoginUser</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>AuthenticationInterceptor</code>拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseToken(token);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> claims.get(<span class="string">&quot;username&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//将结果保存到ThreadLocal中</span></span><br><span class="line">        LoginUserHolder.setLoginUser(<span class="keyword">new</span> <span class="title class_">LoginUser</span>(userId, username));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Controller层逻辑</strong></p><p>在<code>LoginController</code>中增加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;获取登陆用户个人信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;SystemUserInfoVo&gt; <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SystemUserInfoVo</span> <span class="variable">userInfo</span> <span class="operator">=</span> service.getLoginUserInfo(LoginUserHolder.getLoginUser().getUserId());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-Mybatis插件分页注意事项"><a href="#9-Mybatis插件分页注意事项" class="headerlink" title="9.Mybatis插件分页注意事项"></a>9.Mybatis插件分页注意事项</h2><p>使用Mybatis-Plus的分页插件进行分页查询时，如果结果需要使用<code>&lt;collection&gt;</code>进行映射，只能使用**<a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#nested-select-for-collection">嵌套查询（Nested Select for Collection）</a><strong>，而不能使用</strong><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#nested-results-for-collection">嵌套结果映射（Nested Results for Collection）</a>**。</p><p><strong>嵌套查询</strong>和<strong>嵌套结果映射</strong>是Collection映射的两种方式，下面通过一个案例进行介绍</p><p>例如有<code>room_info</code>和<code>graph_info</code>两张表，其关系为一对多，如下</p><p><img src="/../images/mybatis-%E4%B8%80%E5%AF%B9%E5%A4%9A.drawio.png"></p><p>现需要查询房间列表及其图片信息，期望返回的结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="number">201</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rent&quot;</span><span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;graphList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="number">202</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rent&quot;</span><span class="punctuation">:</span> <span class="number">3000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;graphList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;roomId&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>为得到上述结果，可使用以下两种方式</p><ul><li><p><strong>嵌套结果映射</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectRoomPage&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;RoomPageMap&quot;</span>&gt;</span></span><br><span class="line">    select ri.id room_id,</span><br><span class="line">           ri.number,</span><br><span class="line">           ri.rent,</span><br><span class="line">       gi.id graph_id,</span><br><span class="line">           gi.url,</span><br><span class="line">           gi.room_id</span><br><span class="line">    from room_info ri</span><br><span class="line">   left join graph_info gi on ri.id=gi.room_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;RoomPageMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;RoomInfoVo&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;room_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;graphInfoList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;GraphInfo&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;graph_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式的执行原理如下图所示</p><p><img src="/../images/mybatis-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84.drawio.png"></p></li><li><p><strong>嵌套查询</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectRoomPage&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;RoomPageMap&quot;</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">           number,</span><br><span class="line">           rent</span><br><span class="line">    from room_info</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;RoomPageMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;RoomInfoVo&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;graphInfoList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;GraphInfo&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectGraphByRoomId&quot;</span>  <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectGraphByRoomId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;GraphInfo&quot;</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">           url,</span><br><span class="line">       room_id</span><br><span class="line">    from graph_info</span><br><span class="line">    where room_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法使用两个独立的查询语句来获取一对多关系的数据。首先，Mybatis会执行主查询来获取<code>room_info</code>列表，然后对于每个<code>room_info</code>，Mybatis都会执行一次子查询来获取其对应的<code>graph_info</code>。</p><p><img src="/../images/mybatis-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2.drawio.png"></p></li></ul><p>若现在使用MybatisPlus的分页插件进行分页查询，假如查询的内容是第<strong>1</strong>页，每页<strong>2</strong>条记录，则上述两种方式的查询结果分别是</p><ul><li><p><strong>嵌套结果映射</strong></p><p><img src="/../images/mybatis-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84.drawio.png"></p></li><li><p><strong>嵌套查询</strong></p><p><img src="/../images/mybatis-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2.drawio.png"></p></li></ul><p>总结起来就是，<strong>嵌套结果映射</strong>是对最后的数据表进行limit，而最后的数据表的多条数据会合并成一个对象，导致最终得到的结果并没有设置的size一样多，所以分页逻辑是存在问题的。而<strong>嵌套查询</strong>会先对主查询（不包含映射对象的列表属性对应的字段）进行limit，然后在子查询中查询并添加集合字段，这样映射出来的结果是正确的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SprinBoot Redis MinIO Linux Knife4j Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis+MybatisPlus总结</title>
      <link href="/2024/12/06/Mybatis-MybatisPlus%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/06/Mybatis-MybatisPlus%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>一、Mybatis简介</p><p>mybatis类似于jdbcTemplate,它是一个封装了java对数据库操作的一个依赖，相比于jdbcTemplate，感觉可用性更好。</p><p>二、实战</p>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis mybatisplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot3学习</title>
      <link href="/2024/11/23/SpringBoot3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/23/SpringBoot3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h2><p>springboot框架简化了SSM框架。之前使用SSM框架时，我们需要导入大量的依赖，和配置许多配置类及其相应的注解，太过于繁琐，不好记，而springboot极大的减轻了这些操作，把这些操作都封装了起来，提高开发效率。</p><h2 id="二、快速启动"><a href="#二、快速启动" class="headerlink" title="二、快速启动"></a>二、快速启动</h2><h3 id="2-1-创建Maven工程"><a href="#2-1-创建Maven工程" class="headerlink" title="2.1 创建Maven工程"></a>2.1 创建Maven工程</h3><p>重新创建一个Maven工程，要求无父工程。</p><h3 id="2-2-继承-spring-boot-starter-parent"><a href="#2-2-继承-spring-boot-starter-parent" class="headerlink" title="2.2 继承 spring-boot-starter-parent"></a>2.2 继承 spring-boot-starter-parent</h3><p>在项目的pom文件中添加如下的继承语句。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--继承springboot父工程--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-添加web启动依赖-spring-boot-starter-web"><a href="#2-3-添加web启动依赖-spring-boot-starter-web" class="headerlink" title="2.3 添加web启动依赖 spring-boot-starter-web"></a>2.3 添加web启动依赖 spring-boot-starter-web</h3><p>整合了spring-webmvc,servlet,jackson等依赖</p><p>不需要指定版本号，上面的父工程已经帮我们指定好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入web启动器依赖即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-创建一个Main类"><a href="#2-4-创建一个Main类" class="headerlink" title="2.4 创建一个Main类"></a>2.4 创建一个Main类</h3><p>@SpringBootApplication是启动类的注解</p><p>而SpringApplication.run(Main.class, args)是固定的启动类配置语句。</p><p>SpringBoot不需要我们在IDEA里配置tomcat，它已经封装好了，当我们运行main方法时，tomcat就会自己启动。而且它还会自己创建ioc容器和进行包扫描，扫描范围为当前Main类所在的包下的所有类，包括了包下包的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查看@SpringBootApplication源码可知有如下注解功能</span></span><br><span class="line"><span class="comment">    1.@SpringBootConfiguration 声明配置类</span></span><br><span class="line"><span class="comment">    2.@EnableAutoConfiguration 自动加载其他配置类</span></span><br><span class="line"><span class="comment">    3.@ComponentScan 包扫描，默认是当前所在的包</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//启动类注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//自动创建ioc容器，启动tomcat服务软件</span></span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-创建HelloController类"><a href="#2-5-创建HelloController类" class="headerlink" title="2.5 创建HelloController类"></a>2.5 创建HelloController类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Springboot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-启动运行"><a href="#2-6-启动运行" class="headerlink" title="2.6 启动运行"></a>2.6 启动运行</h3><p>网址开头默认是localhost:8080</p><p><img src="/../images/image-20241123133343605.png" alt="image-20241123133343605"></p><p>由快速入门可见，springboot相比于SSM实在是太过于方便了，省去了许多麻烦的配置。</p><h2 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h2><h3 id="3-1-统一配置管理概述"><a href="#3-1-统一配置管理概述" class="headerlink" title="3.1 统一配置管理概述"></a>3.1 统一配置管理概述</h3><p>SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中！</p><p>配置文件应该放置在SpringBoot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p><p><img src="/../images/image-20241123145118773.png" alt="image-20241123145118773"></p><h3 id="3-2-快速案例"><a href="#3-2-快速案例" class="headerlink" title="3.2 快速案例"></a>3.2 快速案例</h3><p>springboot规定了读取的配置文件名称，application.properties是其中之一，所以我们在resources文件夹下创建application.properties文件即可，它会自动读取该配置文件。</p><p>1.application.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用springboot提供的配置类来修改参数，key是固定的，有需要则查阅官方文档</span><br><span class="line"># server.port指定了服务器开启的端口号</span><br><span class="line">server.port=80</span><br><span class="line"># server.servlet.context-path指定虚拟目录</span><br><span class="line">server.servlet.context-path=/sb</span><br><span class="line"></span><br><span class="line"># 自定义配置key=value</span><br><span class="line">ldy.name=ldy</span><br><span class="line">ldy.age=19</span><br></pre></td></tr></table></figure><p>2.controller层设置访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ldy.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ldy.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Springboot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;ldy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ldy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name=&quot;</span>+name+<span class="string">&quot;,age=&quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.启动并访问</p><p><img src="/../images/image-20241123144831465.png" alt="image-20241123144831465"></p><h3 id="3-3-yml-ymal-配置文件"><a href="#3-3-yml-ymal-配置文件" class="headerlink" title="3.3 yml(ymal)配置文件"></a>3.3 yml(ymal)配置文件</h3><p>传统的properties因为key不能重复，所以对key使用多层次的命名方法 如 server.servlet.context-path.每次写都要加上许多相同的前缀，如 server。</p><p>yml相比于properties化繁为简显得更加有层次。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法如下,要求每一层进行一次缩进，然后赋值时需要 :空格value,不能忘记冒号后面先加个空格</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/sb</span></span><br><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ldy</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">19</span></span><br></pre></td></tr></table></figure><p>此外，yaml还支持集合赋值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ggbone</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">11</span></span><br><span class="line">    <span class="attr">hbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eat</span></span><br></pre></td></tr></table></figure><h3 id="3-4配置文件读取"><a href="#3-4配置文件读取" class="headerlink" title="3.4配置文件读取"></a>3.4配置文件读取</h3><p>之前在SSM框架的学习中，学会了使用@Value注解，而在springboot中有着更加简便使用的**@ConfigurationProperties**注解。可以进行批量配置以及读取集合。以下是快速案例。</p><p>1.User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 读取配置文件的方式1：@Value</span></span><br><span class="line"><span class="comment">*   1.直接在属性上添加@Value</span></span><br><span class="line"><span class="comment">*   2.@Value(key的全名)</span></span><br><span class="line"><span class="comment">*   3.不能读取集合并赋值</span></span><br><span class="line"><span class="comment">* 方式2：@ConfigurationProperties</span></span><br><span class="line"><span class="comment">*   优点：1.添加在类上，批量配置</span></span><br><span class="line"><span class="comment">*        2.可以给集合赋值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ldy.user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;ldy.user.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;ldy.user.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;ldy.user.hbs&#125;&quot;) //报错，不能读取集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.启动并访问</p><p><img src="/../images/image-20241123153008538.png" alt="image-20241123153008538"></p><h3 id="3-5多环境配置和激活"><a href="#3-5多环境配置和激活" class="headerlink" title="3.5多环境配置和激活"></a>3.5多环境配置和激活</h3><p>当我们把所有配置信息都塞到application.yaml配置文件时，该文件会显得相当冗杂，所以，我们可以进行多环境的配置和激活，将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。只需要在application.yaml文件里指定激活的配置文件即可。</p><p>激活方式见下application.yaml文件。</p><p>要求，其他配置文件的命名规范为application-xxx.yaml。</p><p><img src="/../images/image-20241123154442847.png" alt="image-20241123154442847"></p><p>1.application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ggbone</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">11</span></span><br><span class="line">    <span class="attr">hbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eat</span></span><br><span class="line"><span class="comment">#激活方式：</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">druid</span></span><br></pre></td></tr></table></figure><p>2.application-druid.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">druid:</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">ldy:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">bk201</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>当激活的配置文件的key和application的key有重复时，以激活的配置文件的value值为主。如下图所示。</p><p><img src="/../images/image-20241123154934271.png" alt="image-20241123154934271"></p><h2 id="四、SpringMvc整合"><a href="#四、SpringMvc整合" class="headerlink" title="四、SpringMvc整合"></a>四、SpringMvc整合</h2><p>前面的已经介绍过，springboot整合了springmvc大部分的注解和配置。下面是某些其他springmvc功能的设置。</p><h3 id="4-1-静态资源访问"><a href="#4-1-静态资源访问" class="headerlink" title="4.1 静态资源访问"></a>4.1 静态资源访问</h3><p>使用Spring Boot做开发时 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？springboot给我们配置好了默认的静态资源访问路径。只需要把静态资源创建在相应的路径下即可访问。在maven工程中，classpath指的是main&#x2F;java&#x2F;resources。创建文件如下所示</p><p><img src="/../images/image-20241125133910828.png" alt="image-20241125133910828"></p><p>1.默认路径</p><p><strong>默认的静态资源路径为：</strong></p><p><strong>· classpath:&#x2F;META-INF&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;static&#x2F;</strong></p><p><strong>· classpath:&#x2F;public&#x2F;</strong></p><p>2.自定义路径</p><p>指定路径的语法格式为 classpath:&#x2F;xxx。指定多个时，仅需加逗号写同样的格式。不能是classpath:&#x2F;webapps, web。无法访问web下面的静态资源，因为我试过。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/webapps,</span> <span class="string">classpath:/web</span> <span class="comment">#自定义静态资源访问路径</span></span><br><span class="line">      <span class="comment">#注意，配置静态资源地址后,会覆盖默认值</span></span><br></pre></td></tr></table></figure><h3 id="4-2-拦截器设置"><a href="#4-2-拦截器设置" class="headerlink" title="4.2 拦截器设置"></a>4.2 拦截器设置</h3><p>拦截器的设置没什么变化，都是要创建一个实现HandlerInterceptor接口的类</p><p><img src="/../images/image-20241125134408792.png" alt="image-20241125134408792"></p><p>然后，在Main类所在的包下创建一个配置类</p><p>1.添加@Configuration注解，springboot会自动进行配置类扫描</p><p>2.实现WebMvcConfigurer接口</p><p>3.重写addInterceptor方法，添加自定义的拦截器类对象即可</p><p><img src="/../images/image-20241125134624664.png" alt="image-20241125134624664"></p><h2 id="五、Druid连接池配置"><a href="#五、Druid连接池配置" class="headerlink" title="五、Druid连接池配置"></a>五、Druid连接池配置</h2><h3 id="5-1-添加相应的依赖"><a href="#5-1-添加相应的依赖" class="headerlink" title="5.1 添加相应的依赖"></a>5.1 添加相应的依赖</h3><p>druid-spring-boot-3-starter目前1.2.20即以上版本已经兼容springboot3了。1.2.20以下版本需要额外配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-配置application-yaml"><a href="#5-2-配置application-yaml" class="headerlink" title="5.2 配置application.yaml"></a>5.2 配置application.yaml</h3><p>druid连接池配置相应信息的固定格式如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># druid连接池配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="comment"># 使用druid连接池</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h3><p>1.实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> completed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Controller类</p><p>因为添加了jdbcTemplate的相应依赖，springboot会自动把JdbcTemplate对象添加到ioc容器里，所以直接用@Autowired获取即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sche&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate template;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Schedule&gt; <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from schedule&quot;</span>;</span><br><span class="line">        List&lt;Schedule&gt; query = template.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Schedule.class));</span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.启动类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.启动并访问</p><p><img src="/../images/image-20241125141114710.png" alt="image-20241125141114710"></p><h2 id="六、Mybatis整合"><a href="#六、Mybatis整合" class="headerlink" title="六、Mybatis整合"></a>六、Mybatis整合</h2><h3 id="6-1Mybatis整合步骤"><a href="#6-1Mybatis整合步骤" class="headerlink" title="6.1Mybatis整合步骤"></a>6.1Mybatis整合步骤</h3><ol><li>导入依赖：在您的Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。</li><li>配置数据源：在<code>application.properties</code>或<code>application.yml</code>中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。</li><li>创建实体类：创建与数据库表对应的实体类。</li><li>创建Mapper接口：创建与数据库表交互的Mapper接口。</li><li>创建Mapper接口的SQL实现： 可以使用mapperxml文件或者注解方式</li><li>创建程序启动类</li><li>注解扫描：在Spring Boot的主应用类上添加<code>@MapperScan</code>注解，用于扫描和注册Mapper接口的动态代理对象到ioc容器。</li><li>使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。</li></ol><p>以下是快速案例</p><h3 id="6-2依赖导入"><a href="#6-2依赖导入" class="headerlink" title="6.2依赖导入"></a>6.2依赖导入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-配置application-yaml文件"><a href="#6-3-配置application-yaml文件" class="headerlink" title="6.3 配置application.yaml文件"></a>6.3 配置application.yaml文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># druid连接池配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mybatis配置， 彻底抛弃mybatis-config.xml文件</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span>  <span class="comment">#指定mapper的xml文件的位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.ldy.bean</span>  <span class="comment">#设置实体类别名</span></span><br><span class="line">  <span class="attr">configuration:</span> <span class="comment"># setting设置</span></span><br><span class="line">    <span class="attr">auto-mapping-behavior:</span> <span class="string">full</span> <span class="comment">#自动映射，full表示可以嵌套映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#开启驼峰式命名法</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span> <span class="comment">#开启日志输出</span></span><br></pre></td></tr></table></figure><h3 id="6-4-类和接口"><a href="#6-4-类和接口" class="headerlink" title="6.4 类和接口"></a>6.4 类和接口</h3><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> completed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduleMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Schedule&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sche&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ScheduleMapper mapper;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Schedule&gt; <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Schedule&gt; schedules = mapper.selectAll();</span><br><span class="line">        <span class="keyword">return</span> schedules;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在Main中开启<strong>mapper包扫描</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ldy.mapper&quot;)</span> <span class="comment">//mapper包扫描,会把接口的代理对象放到ioc容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、其他SSM功能实现"><a href="#七、其他SSM功能实现" class="headerlink" title="七、其他SSM功能实现"></a>七、其他SSM功能实现</h2><h3 id="1-aop切面管理"><a href="#1-aop切面管理" class="headerlink" title="1.aop切面管理"></a>1.aop切面管理</h3><p>知识点：切点表达式，在之前文章里有总结。</p><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对比</p><p>ssm要在配置类中开启Aspcetj注解支持:</p><p><img src="/../images/image-20241126005435013.png" alt="image-20241126005435013"></p><p>而springboot不需要。直接创建advice类添加@Aspect注解即可使用。</p><p>创建一个advice包用于存储各种Advice类。别忘了在类上添加@Aspect和@Component注解</p><p><img src="/../images/image-20241126003945240.png" alt="image-20241126003945240"></p><p>也可以单独创建一个切点表达式的包用于存放切点信息。</p><p><img src="/../images/image-20241126004131771.png" alt="image-20241126004131771"></p><h3 id="2-tx事务管理"><a href="#2-tx事务管理" class="headerlink" title="2.tx事务管理"></a>2.tx事务管理</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了。</p><p>具体使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sche&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ScheduleMapper mapper;</span><br><span class="line">    <span class="comment">//自定义异常</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> mapper.delete(id);</span><br><span class="line">        <span class="comment">//id大于20时制造异常，进行事务回滚</span></span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@Transactional的属性propagation的各种参数具体功能可以参考如下博客</p><p><a href="https://blog.csdn.net/happydecai/article/details/80338053">Spring事务的传播：PROPAGATION_REQUIRED_propagation.required-CSDN博客</a></p><h2 id="八、springboot项目打包运行"><a href="#八、springboot项目打包运行" class="headerlink" title="八、springboot项目打包运行"></a>八、springboot项目打包运行</h2><blockquote><p>在Spring Boot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加<code>spring-boot-maven-plugin</code>插件配置，使用常规的<code>java -jar</code>命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-执行打包"><a href="#6-2-执行打包" class="headerlink" title="6.2 执行打包"></a>6.2 执行打包</h3><p>在idea点击package进行打包</p><p>可以在编译的target文件中查看jar包</p><p><img src="/../images/image_xY_DhdZdAA.png"></p><h3 id="6-3-命令启动和参数说明"><a href="#6-3-命令启动和参数说明" class="headerlink" title="6.3 命令启动和参数说明"></a>6.3 命令启动和参数说明</h3><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。下面是关于<code>java -jar</code>命令的说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令格式：java -jar  [选项] [参数] <span class="tag">&lt;<span class="name">jar文件名</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code>。</li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：<ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如 <code>-Xmx512m</code> 表示设置最大堆内存为512MB。</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如 <code>-Xms256m</code> 表示设置初始堆内存为256MB。</li></ul></li><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定Spring Boot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code>。</li></ol><p>启动和测试：</p><p><img src="/../images/image_sH3S3fZ9Cy.png"></p><p>注意： -D 参数必须要在jar之前！否者不生效！</p><p>以上，即为springboot的快速入门学习，总的来说确实比ssm省事多了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springmvc总结</title>
      <link href="/2024/11/22/Springmvc%E6%80%BB%E7%BB%93/"/>
      <url>/2024/11/22/Springmvc%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringMVC内容较多，且要结合Spring的内容，所以知识点比较散，总结起来太晕了，所以我复制了尚硅谷的springmvc教案，该教案可以说是相当详细了，我对教案内容的某些晦涩难懂地方进行可理解的表达修改。</p><h2 id="一、SpringMVC简介和体验"><a href="#一、SpringMVC简介和体验" class="headerlink" title="一、SpringMVC简介和体验"></a>一、SpringMVC简介和体验</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>SpringMVC官网<a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">https://docs.spring.io/spring-framework/reference/web/webmvc.html</a></p><p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ <code>spring-webmvc</code> ），但它通常被称为“Spring MVC”。</p><p>在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的<strong>首选方案</strong>。之所以能做到这一点，是因为SpringMVC具备如下显著优势：</p><ul><li><strong>Spring 家族原生产品</strong>，与IOC容器等基础设施无缝对接</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><p>原生Servlet API开发代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">                                                        <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于SpringMVC开发代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(&quot;userName&quot;)</span> String userName,Sting password)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">    <span class="comment">//调用业务即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-主要作用"><a href="#1-2-主要作用" class="headerlink" title="1.2 主要作用"></a>1.2 主要作用</h3><p><img src="/../images/image_ubxbkc-DZ5-17322800921573.png"></p><p>SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！</p><p>SpringMVC的作用主要覆盖的是表述层，例如：</p><ul><li>请求映射</li><li>数据输入</li><li>视图界面</li><li>请求分发</li><li>表单回显</li><li>会话控制</li><li>过滤拦截</li><li>异步交互</li><li>文件上传</li><li>文件下载</li><li>数据校验</li><li>类型转换(如JSON)</li><li>等等等</li></ul><p><strong>最终总结：</strong></p><ol><li>简化前端参数接收( 形参列表 )</li><li>简化后端数据响应(返回值)</li><li>以及其他……</li></ol><h3 id="1-3-核心组件和调用流程理解"><a href="#1-3-核心组件和调用流程理解" class="headerlink" title="1.3 核心组件和调用流程理解"></a>1.3 核心组件和调用流程理解</h3><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><strong>SpringMVC处理请求流程：</strong></p><p><img src="/../images/image_tmdw8dA_0q.png"></p><p><strong>SpringMVC涉及组件理解：</strong></p><ol><li>DispatcherServlet :  SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ]</li><li>HandlerMapping :  SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]</li><li>HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]</li><li>Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]</li><li>ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]</li></ol><h3 id="1-4-快速体验"><a href="#1-4-快速体验" class="headerlink" title="1.4 快速体验"></a>1.4 快速体验</h3><ol><li><p>体验场景需求</p><p><img src="/../images/image_JrHCHOxu_n.png"></p></li><li><p>配置分析</p><ol><li>DispatcherServlet，设置处理所有请求！</li><li>HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！</li><li>Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！</li></ol></li><li><p>准备项目</p><ol><li><p>创建项目</p><p>springmvc-base-quick</p><p>注意：需要转成maven&#x2F;web程序！！</p></li><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.api</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">servlet.api</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springioc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- web相关依赖  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用</span></span><br><span class="line"><span class="comment">         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’</span></span><br><span class="line"><span class="comment">         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的</span></span><br><span class="line"><span class="comment">         Servlet API，没有更新到 Jakarta EE 规范。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.api&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- springwebmvc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Controller声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler就是controller内部的具体方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestMapping</span>(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ResponseBody</span> 代表向浏览器直接返回数据!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/springmvc/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloController.hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello springmvc!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Spring MVC核心组件配置类</p><blockquote><p>声明springmvc涉及组件信息的配置类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>     </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerMapping <span class="title function_">handlerMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SpringMVC环境搭建</p><blockquote><p>对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> getServletMappings 返回的地址 设置DispatherServlet对应处理的地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定service / mapper层的配置类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定springmvc的配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置dispatcherServlet的处理路径!</span></span><br><span class="line"><span class="comment">   * 一般情况下为 / 代表处理所有请求!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动测试</p><p>注意： tomcat应该是10+版本！方可支持 Jakarta EE API!</p><p><img src="/../images/image_196iViHp_T.png"></p></li></ol><h2 id="二、SpringMVC接收数据"><a href="#二、SpringMVC接收数据" class="headerlink" title="二、SpringMVC接收数据"></a>二、SpringMVC接收数据</h2><h3 id="2-1-访问路径设置"><a href="#2-1-访问路径设置" class="headerlink" title="2.1 访问路径设置"></a>2.1 访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><ol><li><p><strong>精准路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>模糊路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/*  </span></span><br><span class="line"><span class="comment">     *    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *    /product/a/a 不可以</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/** </span></span><br><span class="line"><span class="comment">     *   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *   /product/a/a 也可以访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/product/*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductController.show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;product show!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单层匹配和多层匹配：</span><br><span class="line">  /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。</span><br><span class="line">  /**：可以匹配URL地址中的多层。</span><br><span class="line">其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次</span><br><span class="line">这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</span><br></pre></td></tr></table></figure></li><li><p><strong>类和方法级别区别</strong></p><p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p><ol><li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li><li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.标记到handler方法</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/logout&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.优化标记类+handler方法</span></span><br><span class="line"><span class="comment">//类上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//handler方法上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>附带请求方式限制</strong></p><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！</p><p>如果需要特定指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     * method = RequestMethod.POST 可以指定单个或者多个请求方式!</span></span><br><span class="line"><span class="comment">     * 注意:违背请求方式会出现405异常!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：违背请求方式，会出现405异常！！！</p></li><li><p><strong>进阶注解</strong></p><p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)</span></span><br><span class="line">||</span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/login&quot;)</span></span><br></pre></td></tr></table></figure><p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p></li><li><p><strong>常见配置问题</strong></p><p>出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。</p><blockquote><p>There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() <strong>mapped</strong>.</p></blockquote></li></ol><h3 id="2-2-接收参数（重点）"><a href="#2-2-接收参数（重点）" class="headerlink" title="2.2 接收参数（重点）"></a>2.2 接收参数（重点）</h3><h4 id="2-2-1-param-和-json参数比较"><a href="#2-2-1-param-和-json参数比较" class="headerlink" title="2.2.1 param 和 json参数比较"></a>2.2.1 param 和 json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li><p>参数编码： &#x20;</p><p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。</p></li><li><p>参数顺序： &#x20;</p><p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p></li><li><p>数据类型： &#x20;</p><p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p></li><li><p>嵌套性： &#x20;</p><p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p></li><li><p>可读性： &#x20;</p><p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p></li></ol><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><h4 id="2-2-2-param参数接收"><a href="#2-2-2-param参数接收" class="headerlink" title="2.2.2 param参数接收"></a>2.2.2 param参数接收</h4><ol><li><p><strong>直接接值</strong></p><p>客户端请求</p><p><img src="/../images/image_3SOeT8tvvW.png"></p><p>handler接收参数</p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">     *    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">     *          类型相同</span></span><br><span class="line"><span class="comment">     * 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@RequestParam注解</strong></p><p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p><code>@RequestParam</code>使用场景：</p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值<br>基本用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment"> *  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;stuAge&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p><p>如果没有没有设置非必须，也没有传递参数会出现：</p><p><img src="/../images/image_vIkYCRMSZL.png"></p><p>将参数设置非必须，并且设置默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>特殊场景接值</strong></p><ol><li><p>一名多值</p><p>多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment"> *  前提就是参数名一致，如上述网址的两个hbs</span></span><br><span class="line"><span class="comment"> *  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line">    <span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体接收</p><p>Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例：</p><p>定义一个用于接收参数的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中，使用实体对象接收，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p><p>使用postman传递参数测试：</p><p><img src="/../images/image_5BkbhZjtyX.png"></p></li></ol></li></ol><h4 id="2-2-3-路径-参数接收"><a href="#2-2-3-路径-参数接收" class="headerlink" title="2.2.3 路径 参数接收"></a>2.2.3 路径 参数接收</h4><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <code>@PathVariable</code> 注解来处理路径传递参数。</p><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment"> * 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment"> *              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-json参数接收"><a href="#2-2-4-json参数接收" class="headerlink" title="2.2.4 json参数接收"></a>2.2.4 json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p><ol><li><p>前端发送 JSON 数据的示例：（使用postman测试）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个用于接收 JSON 数据的 Java 类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String gender;</span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。</p></li><li><p>完善配置</p><p>测试：</p><p><img src="/../images/image_-vKMBKKMSZ.png"></p><p>问题：</p><p>org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported]</p><p><img src="/../images/image_Kb8Lv29M2o.png"></p><p>原因：</p><ul><li>不支持json数据类型处理</li><li>没有json类型处理的工具（jackson）<br>解决：<br>springmvc handlerAdpater配置json转化器,配置类需要明确：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br></pre></td></tr></table></figure><p> }<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pom.xml 加入jackson依赖</span><br><span class="line">```xml</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.15.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p></li><li><p>@EnableWebMvc注解说明</p><p>@EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素！我们来解析<code>&lt;mvc:annotation-driven&gt;</code>对应的解析工作！</p><p>让我们来查看下<code>&lt;mvc:annotation-driven&gt;</code>具体的动作！</p><ul><li><p>先查看<code>&lt;mvc:annotation-driven&gt;</code>标签最终对应解析的Java类</p><p><img src="/../images/image_WJXPabVDSl.png"></p></li><li><p>查看解析类中具体的动作即可</p><p>打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler</p><p><img src="/../images/image_37KWhccu6c.png"></p><p>打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_MAPPING_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerMapping.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_ADAPTER_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> AnnotationDrivenBeanDefinitionParser.class.getClassLoader();</span><br><span class="line">    javaxValidationPresent = ClassUtils.isPresent(<span class="string">&quot;jakarta.validation.Validator&quot;</span>, classLoader);</span><br><span class="line">    romePresent = ClassUtils.isPresent(<span class="string">&quot;com.rometools.rome.feed.WireFeed&quot;</span>, classLoader);</span><br><span class="line">    jaxb2Present = ClassUtils.isPresent(<span class="string">&quot;jakarta.xml.bind.Binder&quot;</span>, classLoader);</span><br><span class="line">    jackson2Present = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>, classLoader) &amp;&amp;</span><br><span class="line">            ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.core.JsonGenerator&quot;</span>, classLoader);</span><br><span class="line">    jackson2XmlPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;</span>, classLoader);</span><br><span class="line">    jackson2SmilePresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;</span>, classLoader);</span><br><span class="line">    jackson2CborPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;</span>, classLoader);</span><br><span class="line">    gsonPresent = ClassUtils.isPresent(<span class="string">&quot;com.google.gson.Gson&quot;</span>, classLoader);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><pre><code> @Override @Nullable public BeanDefinition parse(Element element, ParserContext context) &#123;   //handlerMapping加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);   //添加jackson转化器   addRequestBodyAdvice(handlerAdapterDef);   addResponseBodyAdvice(handlerAdapterDef);   //handlerAdapter加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);   return null; &#125; //具体添加jackson转化对象方法 protected void addRequestBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;requestBodyAdvice&quot;,         new RootBeanDefinition(JsonViewRequestBodyAdvice.class));   &#125; &#125; protected void addResponseBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;responseBodyAdvice&quot;,         new RootBeanDefinition(JsonViewResponseBodyAdvice.class));   &#125; &#125;</code></pre>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.3 接收Cookie数据</span><br><span class="line"></span><br><span class="line">可以使用 `@CookieValue` 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</span><br><span class="line"></span><br><span class="line">考虑使用以下 cookie 的请求：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>下面的示例演示如何获取 cookie 值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-接收请求头数据"><a href="#2-4-接收请求头数据" class="headerlink" title="2.4 接收请求头数据"></a>2.4 接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-原生Api对象操作"><a href="#2-5-原生Api对象操作" class="headerlink" title="2.5 原生Api对象操作"></a>2.5 原生Api对象操作</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p><p>下表描述了支持的控制器方法参数</p><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment"> * 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">                  HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-共享域对象操作"><a href="#2-6-共享域对象操作" class="headerlink" title="2.6 共享域对象操作"></a>2.6 共享域对象操作</h3><h4 id="2-6-1-属性（共享）域作用回顾"><a href="#2-6-1-属性（共享）域作用回顾" class="headerlink" title="2.6.1 属性（共享）域作用回顾"></a>2.6.1 属性（共享）域作用回顾</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f97dcee32b6069830a598d4c04428f21.png" alt="四大域"></p><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。总结，<strong>直至服务器关闭前都有效</strong>。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。总结，<strong>当前浏览器，直至服务器会话过期</strong>。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。总结，<strong>一次请求，转发</strong>。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><p><img src="/../images/img010_VQ5ta0PT96.png"></p><h4 id="2-6-2-Request级别属性（共享）域"><a href="#2-6-2-Request级别属性（共享）域" class="headerlink" title="2.6.2 Request级别属性（共享）域"></a>2.6.2 Request级别属性（共享）域</h4><p>在springmvc中使用共享域时，只需要在方法参数上声明共享域对象，方法体上就可以直接使用该共享域对象的方法了。</p><ol><li><p>使用 Model 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Model model)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ModelMap 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        ModelMap modelMap)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Map 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用原生 request 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">        HttpServletRequest request)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ModelAndView 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">// 2.存入模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-6-3-Session级别属性（共享）域"><a href="#2-6-3-Session级别属性（共享）域" class="headerlink" title="2.6.3 Session级别属性（共享）域"></a>2.6.3 Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-4-Application级别属性（共享）域"><a href="#2-6-4-Application级别属性（共享）域" class="headerlink" title="2.6.4 Application级别属性（共享）域"></a>2.6.4 Application级别属性（共享）域</h4><p>解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、SpringMVC响应数据"><a href="#三、SpringMVC响应数据" class="headerlink" title="三、SpringMVC响应数据"></a>三、SpringMVC响应数据</h2><h3 id="3-1-handler方法分析"><a href="#3-1-handler方法分析" class="headerlink" title="3.1 handler方法分析"></a>3.1 handler方法分析</h3><p>理解handler方法的作用和组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中注册,供DS查找!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment"> *       1.接收请求参数(param,json,pathVariable,共享域等) </span></span><br><span class="line"><span class="comment"> *       2.调用业务逻辑 </span></span><br><span class="line"><span class="comment"> *       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment"> *       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment"> *       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment"> *       3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">    调用业务方法</span><br><span class="line">    返回的结果 （页面跳转，返回数据（json））</span><br><span class="line">    <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 请求数据接收，我们都是通过handler的形参列表</p><p>&#x20;            前端数据响应，我们都是通过handler的return关键字快速处理！</p><p>&#x20;       springmvc简化了参数接收和响应！</p><h3 id="3-2-页面跳转控制"><a href="#3-2-页面跳转控制" class="headerlink" title="3.2 页面跳转控制"></a>3.2 页面跳转控制</h3><h4 id="3-2-1-快速返回模板视图"><a href="#3-2-1-快速返回模板视图" class="headerlink" title="3.2.1 快速返回模板视图"></a>3.2.1 快速返回模板视图</h4><ol><li><p>开发模式回顾</p><p>在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。</p><p>前后端分离模式：[重点]</p><p>指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。</p><p>混合开发模式：</p><p>指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。</p><p>对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！</p></li><li><p>jsp技术了解</p><p>JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。</p><p>JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。</p><p>JSP 的主要特点包括：</p><ol><li>简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。</li><li>高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。</li><li>多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。<br>总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。</li></ol></li><li><p>准备jsp页面和依赖</p><p>pom.xml依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp需要依赖! jstl--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsp页面创建</p><p>建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！</p><p>位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;</span><br><span class="line">        $&#123;msg&#125;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>快速响应模版页面</p><ol><li><p>配置jsp视图解析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handler返回视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  跳转到提交文件页面  /save/jump</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  如果要返回jsp页面!</span></span><br><span class="line"><span class="comment"> *     1.方法返回值改成字符串类型</span></span><br><span class="line"><span class="comment"> *     2.返回逻辑视图名即可    </span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;</span></span><br><span class="line"><span class="comment"> *            + 逻辑视图名 +</span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;jump&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jumpJsp</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;FileController.jumpJsp&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;request data!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="3-2-2-转发和重定向"><a href="#3-2-2-转发和重定向" class="headerlink" title="3.2.2 转发和重定向"></a>3.2.2 转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 转发到 /demo 路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h3 id="3-3-返回JSON数据（重点）"><a href="#3-3-返回JSON数据（重点）" class="headerlink" title="3.3 返回JSON数据（重点）"></a>3.3 返回JSON数据（重点）</h3><h4 id="3-3-1-前置准备"><a href="#3-3-1-前置准备" class="headerlink" title="3.3.1 前置准备"></a>3.3.1 前置准备</h4><p>导入jackson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加json数据转化器</p><p>@EnableWebMvc&#x20;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-ResponseBody"><a href="#3-3-2-ResponseBody" class="headerlink" title="3.3.2 @ResponseBody"></a>3.3.2 @ResponseBody</h4><ol><li><p>方法上使用@ResponseBody</p><p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="/../images/image_GfNTc3Ei41.png"></p></li><li><p>类上使用@ResponseBody</p><p>如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//responseBody可以添加到类上,代表默认类中的所有方法都生效!</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-3-RestController"><a href="#3-3-3-RestController" class="headerlink" title="3.3.3 @RestController"></a>3.3.3 @RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。</p><p>RestController源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-返回静态资源处理"><a href="#3-4-返回静态资源处理" class="headerlink" title="3.4 返回静态资源处理"></a>3.4 返回静态资源处理</h3><ol><li><p><strong>静态资源概念</strong></p><p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括：</p><ul><li>纯HTML文件</li><li>图片</li><li>CSS文件</li><li>JavaScript文件</li><li>……</li></ul></li><li><p><strong>静态资源访问和问题解决</strong></p><ul><li><p>web应用加入静态资源</p><p><img src="/../images/image_4ZDfBKo7ze.png"></p></li><li><p>手动构建确保编译</p><p><img src="/../images/image_WNWOVOea6e.png"></p><p><img src="/../images/image_jkHB39M3Xa.png"></p><p><img src="/../images/image_iUBYDKRqy5.png"></p></li><li><p>访问静态资源</p><p><img src="/../images/image_k7bhHrwvx1.png"></p></li><li><p>问题分析</p><ul><li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li><li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul></li><li><p>问题解决</p><p>在 SpringMVC 配置配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试访问图片：</p><p><img src="/../images/image_mrBsYbjiMM.png"></p></li><li><p>新的问题：其他原本正常的handler请求访问不了了</p><p>handler无法访问</p><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="四、RESTFul风格设计和实战"><a href="#四、RESTFul风格设计和实战" class="headerlink" title="四、RESTFul风格设计和实战"></a>四、RESTFul风格设计和实战</h2><h3 id="4-1-RESTFul风格概述"><a href="#4-1-RESTFul风格概述" class="headerlink" title="4.1 RESTFul风格概述"></a>4.1 RESTFul风格概述</h3><h4 id="4-1-1-RESTFul风格简介"><a href="#4-1-1-RESTFul风格简介" class="headerlink" title="4.1.1 RESTFul风格简介"></a>4.1.1 RESTFul风格简介</h4><p><img src="/../images/image_wEi6we5MJQ.png"></p><p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。</p><p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。</p><p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p><p><img src="/../images/image_X8M-XfzI_A.png"></p><p>学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！</p><h4 id="4-1-2-RESTFul风格特点"><a href="#4-1-2-RESTFul风格特点" class="headerlink" title="4.1.2 RESTFul风格特点"></a>4.1.2 RESTFul风格特点</h4><ol><li>每一个URI代表1种资源（URI 是名词）；</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是XML或者<strong>JSON</strong>；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li></ol><h4 id="4-1-3-RESTFul风格设计规范"><a href="#4-1-3-RESTFul风格设计规范" class="headerlink" title="4.1.3 RESTFul风格设计规范"></a>4.1.3 <strong>RESTFul风格设计规范</strong></h4><ol><li><p><strong>HTTP协议请求方式要求</strong></p><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table></li><li><p><strong>URL路径风格要求</strong></p><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li></ol><ul><li><p>总结</p><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！</p></li></ul><h4 id="4-1-4-RESTFul风格好处"><a href="#4-1-4-RESTFul风格好处" class="headerlink" title="4.1.4 RESTFul风格好处"></a>4.1.4 RESTFul风格好处</h4><ol><li><p>含蓄，安全</p><p>使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。</p></li><li><p>风格统一</p><p>URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。</p></li><li><p>无状态</p><p>在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。</p></li><li><p>严谨，规范</p><p>严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。</p></li><li><p>简洁，优雅</p><p>过去做增删改查操作需要设计4个不同的URL，现在一个就够了。</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li><li><p>丰富的语义</p><p>通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。</p><blockquote><p><a href="http://localhost:8080/shop" title="http://localhost:8080/shop">http://localhost:8080/shop</a> <a href="http://localhost:8080/shop/product" title="http://localhost:8080/shop/product">http://localhost:8080/shop/product</a> <a href="http://localhost:8080/shop/product/cellPhone" title="http://localhost:8080/shop/product/cellPhone">http://localhost:8080/shop/product/cellPhone</a> <a href="http://localhost:8080/shop/product/cellPhone/iPhone" title="http://localhost:8080/shop/product/cellPhone/iPhone">http://localhost:8080/shop/product/cellPhone/iPhone</a></p></blockquote></li></ol><h3 id="4-2-RESTFul风格实战"><a href="#4-2-RESTFul风格实战" class="headerlink" title="4.2 RESTFul风格实战"></a>4.2 RESTFul风格实战</h3><h4 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1 需求分析"></a>4.2.1 需求分析</h4><ul><li>数据结构： User {id 唯一标识,name 用户名，age 用户年龄}</li><li>功能分析<ul><li>用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10）</li><li>保存用户功能</li><li>根据用户id查询用户详情功能</li><li>根据用户id更新用户数据功能</li><li>根据用户id删除用户数据功能</li><li>多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10）</li></ul></li></ul><h4 id="4-2-2-RESTFul风格接口设计"><a href="#4-2-2-RESTFul风格接口设计" class="headerlink" title="4.2.2 RESTFul风格接口设计"></a>4.2.2 RESTFul风格接口设计</h4><ol><li><p><strong>接口设计</strong></p><table><thead><tr><th>功能</th><th>接口和请求方式</th><th>请求参数</th><th>返回值</th></tr></thead><tbody><tr><td>分页查询</td><td>GET  &#x2F;user</td><td>page&#x3D;1&amp;size&#x3D;10</td><td>{ 响应数据 }</td></tr><tr><td>用户添加</td><td>POST &#x2F;user</td><td>{ user 数据 }</td><td>{响应数据}</td></tr><tr><td>用户详情</td><td>GET &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>用户更新</td><td>PUT &#x2F;user</td><td>{ user 更新数据}</td><td>{响应数据}</td></tr><tr><td>用户删除</td><td>DELETE &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>条件模糊</td><td>GET &#x2F;user&#x2F;search</td><td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td><td>{响应数据}</td></tr></tbody></table></li><li><p><strong>问题讨论</strong></p><p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p><p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p><p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p><ul><li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li><li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。<br>此外，还有一些通用的原则可以遵循：</li><li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li><li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li><li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li></ul></li></ol><h4 id="4-2-3-后台接口实现"><a href="#4-2-3-后台接口实现" class="headerlink" title="4.2.3 后台接口实现"></a>4.2.3 后台接口实现</h4><p>准备用户实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>准备用户Controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 用户模块的控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户保存业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户保存业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户详情业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">detailUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户详情业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户更新业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户更新业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟条件分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;search&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;keyword&quot;,required= false)</span>String keyword)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size + <span class="string">&quot;, keyword = &quot;</span> + keyword);</span><br><span class="line">        System.out.println(<span class="string">&quot;条件分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、SpringMVC其他扩展"><a href="#五、SpringMVC其他扩展" class="headerlink" title="五、SpringMVC其他扩展"></a>五、SpringMVC其他扩展</h2><h3 id="5-1-全局异常处理机制"><a href="#5-1-全局异常处理机制" class="headerlink" title="5.1 全局异常处理机制"></a>5.1 全局异常处理机制</h3><h4 id="5-1-1-异常处理两种方式"><a href="#5-1-1-异常处理两种方式" class="headerlink" title="5.1.1 异常处理两种方式"></a>5.1.1 异常处理两种方式</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p><p>对于异常的处理，一般分为两种方式：</p><ul><li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p>站在宏观角度来看待声明式事务处理：</p><p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p><p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p><h4 id="5-1-2-基于注解异常声明异常处理"><a href="#5-1-2-基于注解异常声明异常处理" class="headerlink" title="5.1.2 基于注解异常声明异常处理"></a>5.1.2 基于注解异常声明异常处理</h4><ol><li><p>声明异常处理控制器类</p><p>异常处理控制类，统一定义异常处理handler方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.execptionhandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * description: 全局异常处理器,内部可以定义异常处理Handler!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明异常处理hander方法</p><p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理handler </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment"> * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment"> * 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment"> * 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment"> *       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件扫描控制器类配置</p><p>确保异常处理控制类被扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,</span></span><br><span class="line"><span class="meta">&quot;com.atguigu.exceptionhandler&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-拦截器使用"><a href="#5-2-拦截器使用" class="headerlink" title="5.2 拦截器使用"></a>5.2 拦截器使用</h3><h4 id="5-2-1-拦截器概念"><a href="#5-2-1-拦截器概念" class="headerlink" title="5.2.1 拦截器概念"></a>5.2.1 拦截器概念</h4><p>拦截器和过滤器解决问题</p><ul><li><p>生活中</p><p>为了提高乘车效率，在乘客进入站台前统一检票</p><p><img src="/../images/img008_uQA2iP6_5n.png"></p></li><li><p>程序中</p><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p><p><img src="/../images/img009_aXz6GsRSMQ.png"></p></li></ul><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li>相似点<ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li>不同点<ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul></li></ul><p>选择：</p><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。</p><p><img src="/../images/image_7rIm3LKXgr.png"></p><h4 id="5-2-2-拦截器使用"><a href="#5-2-2-拦截器使用" class="headerlink" title="5.2.2 拦截器使用"></a>5.2.2 拦截器使用</h4><ol><li><p>创建拦截器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if( ! preHandler())&#123;return;&#125;</span></span><br><span class="line">    <span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 返回true：放行</span></span><br><span class="line">        <span class="comment">// 返回false：不放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器方法拦截位置：</p><p><img src="/../images/image_FwhiGWjP_t.png"></p></li><li><p>修改配置类添加拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line">        <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 配置详解</span><br><span class="line"></span><br><span class="line">   1. 默认拦截全部</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      @Override</span><br><span class="line">      public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">          //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br><span class="line">          registry.addInterceptor(new Process01Interceptor());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><ol start="2"><li><p>精准配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>排除配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排除匹配,排除应该在匹配的范围内排除</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>())</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>多个拦截器执行顺序</p><ol><li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li><li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li><li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li></ol></li></ol><h3 id="5-3-参数校验"><a href="#5-3-参数校验" class="headerlink" title="5.3 参数校验"></a>5.3 参数校验</h3><blockquote><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p></blockquote><ol><li><p><strong>校验概述</strong></p><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr><tr><td>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</td><td></td></tr><tr><td>注解</td><td>规则</td></tr><tr><td>————————————————————————————————————————————————————————————————————————————————————————————————————————————————-</td><td>——————–</td></tr><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr><tr><td>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</td><td></td></tr><tr><td>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</td><td></td></tr></tbody></table></li><li><p><strong>操作演示</strong></p><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>应用校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line">    <span class="meta">@Min(10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line">    <span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//email 邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>handler标记和绑定错误收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">                       BindingResult result)</span>&#123;</span><br><span class="line">       <span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试效果</p><p><img src="/../images/image_BKORDdDEb9.png"></p></li></ul></li><li><p><strong>易混总结</strong></p><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ol><li><p>@NotNull  (用于检测<strong>包装类型</strong>不为null，如Integer, Float, Double…)</p><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p></li><li><p>@NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 <strong>CharSequence、Collection、Map 或者数组对象类型</strong>的属性进行校验，校验时会检查该属性是否<strong>为 Null 或者 size()&#x3D;&#x3D;0</strong>，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p></li><li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于<strong>字符串类型</strong>的属性进行校验，校验时会检查该属性是否<strong>为 Null 或 “” 或者只包含空格</strong>，如果是的话就会校验失败。需要注意的是，**@NotBlank 注解只能用于字符串类型的校验**。<br>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p></li></ol></li></ol><h2 id="六、SpringMVC总结"><a href="#六、SpringMVC总结" class="headerlink" title="六、SpringMVC总结"></a>六、SpringMVC总结</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>springmvc框架</td><td>主要作用、核心组件、调用流程</td></tr><tr><td>简化参数接收</td><td>路径设计、参数接收、请求头接收、cookie接收</td></tr><tr><td>简化数据响应</td><td>模板页面、转发和重定向、JSON数据、静态资源</td></tr><tr><td>restful风格设计</td><td>主要作用、具体规范、请求方式和请求参数选择</td></tr><tr><td>功能扩展</td><td>全局异常处理、拦截器、参数校验注解</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题易错点整理</title>
      <link href="/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2024/11/09/%E7%AE%97%E6%B3%95%E9%A2%98%E6%98%93%E9%94%99%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这篇博客用于提醒自己在写算法题时，很容易忽视的易错点，有时明明是很小的问题，却花了好长时间才发现。</p><p>2024&#x2F;12&#x2F;10 要考试了，此博客除了易错点整理外，还整理了各种算法思想来应对考试！例题是选取pta上面我提交了好几次才ac的题目。┭┮﹏┭┮</p><h1 id="一、易错点"><a href="#一、易错点" class="headerlink" title="一、易错点"></a>一、易错点</h1><h2 id="1-qsort的cmp函数"><a href="#1-qsort的cmp函数" class="headerlink" title="1.qsort的cmp函数"></a>1.qsort的cmp函数</h2><p>如下图代码，a.d 和b.d都是double类型,如果return语句是a.d-b.d，那么当a.d和b.d的整数位的值相同时，它们并不会排序，导致排序有问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * x, <span class="type">const</span> <span class="type">void</span> * y)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">a</span> =</span> *(<span class="keyword">struct</span> <span class="built_in">map</span>*)x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">b</span> =</span> *(<span class="keyword">struct</span> <span class="built_in">map</span>*)y;</span><br><span class="line">    <span class="keyword">if</span>(a.d &gt; b.d)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-memset函数"><a href="#2-memset函数" class="headerlink" title="2.memset函数"></a>2.memset函数</h2><p>void *memset(void *str, int c, size_t n)</p><p>str是数组名，c是数值，n是sizeof(数组名)</p><p>例如：memset(arr, 0, sizeof(arr));</p><p>memset对于char数组，可以任意c赋值，而int数组只能用于赋值0。因为它是按字节赋值的。</p><p>参考链接<a href="https://blog.csdn.net/Supreme7/article/details/115431235">memset()函数的用法详解-CSDN博客</a></p><h2 id="3-strcmp函数"><a href="#3-strcmp函数" class="headerlink" title="3.strcmp函数"></a>3.strcmp函数</h2><h2 id="4-c-的队列对象"><a href="#4-c-的队列对象" class="headerlink" title="4.c++的队列对象"></a>4.c++的队列对象</h2><h2 id="5-qsort函数"><a href="#5-qsort函数" class="headerlink" title="5.qsort函数"></a>5.qsort函数</h2><p>qsort函数包含四个参数，分别是：</p><p>1.数组名</p><p>2.元素个数（从前往后计算）</p><p>3.数组元素所占字节（int，double，char等所占字节）</p><p>4.排序原则（递增，递减，奇偶交叉等）</p><p>使用例子：</p><p>int arr[100];</p><p>qsort(arr, n, sizeof(int), cmp);</p><p>参考链接<a href="https://blog.csdn.net/Cooler_z/article/details/122384559">C语言排序神器——qsort函数（看这一篇，足矣）-CSDN博客</a></p><h1 id="二、算法整理"><a href="#二、算法整理" class="headerlink" title="二、算法整理"></a>二、算法整理</h1><h2 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h2><h3 id="1）普通的0-1背包问题"><a href="#1）普通的0-1背包问题" class="headerlink" title="1）普通的0-1背包问题"></a>1）普通的0-1背包问题</h3><p>直接根据动态规划来做</p><p>但是，注意，有时会有坑，比如如下代码，问题出在第18行，j应该是&gt;&#x3D;0,而不是&gt;0,原因是vol[i]可能为0.</p><p>因为题目的输入要求为</p><p>第一行包含整数 T ，即个案数。后面是 T 个案例，每个案例有三行，第一行包含两个整数 N ， V ， （N &lt;&#x3D; 1000 ， V &lt;&#x3D; 1000 ） 代表骨头的数量和他的袋子的体积。第二行包含 N 个整数，表示每个骨骼的值。第三行包含 N 个整数，表示每个骨骼的体积。</p><p>这里V没有说大于0，所以0也是可能的。真的吐了，检查了半天，也太恶心了，正常来说肯定大于0啊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int t, n, v;</span><br><span class="line">    int val[1111] = &#123;0&#125;, vol[1111] = &#123;0&#125;;</span><br><span class="line">    int dp[1111] = &#123;0&#125;;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t-- &gt; 0)&#123;</span><br><span class="line">        memset(val, 0, sizeof(val));</span><br><span class="line">        memset(vol, 0, sizeof(vol));</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;n, &amp;v);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;vol[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = v; j &gt; 0; j--)&#123;</span><br><span class="line">                if(j &gt;= vol[i])</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-vol[i]] + val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）普通的完全背包问题"><a href="#2）普通的完全背包问题" class="headerlink" title="2）普通的完全背包问题"></a>2）普通的完全背包问题</h3><p>即可以取任意个相同的物品，应该对于每一个物品，都把它遍历至容量结束为止，可以参考如下代码。</p><p>题目链接<a href="https://blog.csdn.net/weixin_45808737/article/details/115147213">湫湫系列故事——减肥记I(HDU-4808)-CSDN博客</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">111</span>], b[<span class="number">111</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">111111</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = b[i]; j &lt;= m; j ++)&#123;</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-b[i]] + a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）对于判断是否装满背包的完全背包情况下"><a href="#3）对于判断是否装满背包的完全背包情况下" class="headerlink" title="3）对于判断是否装满背包的完全背包情况下"></a>3）对于判断是否装满背包的完全背包情况下</h3><p>得最大&#x2F;最小的价值情况，要额外进行判段，给每一个物品从头遍历至容量最大值时，先判断该容量是否可以装满，可以则进行赋值，不行则不管它。</p><p>题目链接<a href="https://blog.csdn.net/Alanrookie/article/details/107468511">Piggy-Bank HDU - 1114 （完全背包模板题）_在acm能够做任何事情之前,必须编制预算并获得必要的财政支持。这一行动的主要收入-CSDN博客</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">600</span>], w[<span class="number">600</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">11000</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t -- &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;e, &amp;f);</span><br><span class="line">        f = f - e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= f; i++)&#123;</span><br><span class="line">            dp[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p[i], &amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = w[i]; j &lt;= f; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - w[i]] != INF)&#123;</span><br><span class="line">                    dp[j] = min(dp[j], dp[j-w[i]] + p[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[f] != INF)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;</span>, dp[f]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;This is impossible.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）对于普通背包问题，不要进行额外判断了，会出错"><a href="#4）对于普通背包问题，不要进行额外判断了，会出错" class="headerlink" title="4）对于普通背包问题，不要进行额外判断了，会出错"></a>4）对于普通背包问题，不要进行额外判断了，会出错</h3><p>和第二点的题目一样，但使用了额外判断时不能通过。</p><p>未通过代码如下，原因是，从后找能完全符合容量的幸福度不一定是最大的，这是因为占满容量的限制。导致越大的容量价值不一定最高。</p><p>例如 价值    容量</p><p>​ 111      100</p><p>​   1         123</p><p>这个情况下，123容量装满只有1元，而100容量装满有111元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int max(int x, int y)&#123;</span><br><span class="line">    if(x &gt; y)</span><br><span class="line">        return x;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    int a[111], b[111];</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) != EOF)&#123;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;a[i], &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int dp[111111];</span><br><span class="line">        for(int i = 0; i &lt; 111111; i++)&#123;</span><br><span class="line">            dp[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = b[i]; j &lt;= m; j ++)&#123;</span><br><span class="line">                if(dp[j - b[i]] != -1)</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-b[i]] + a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[m] != -1)</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[m]);</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int i = m - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">                if(dp[i] != -1)&#123;</span><br><span class="line">                    printf(&quot;%d&quot;, dp[i]);</span><br><span class="line">                    break;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-放挡板法"><a href="#2-放挡板法" class="headerlink" title="2.放挡板法"></a>2.放挡板法</h2><p>核心思想，<strong>数量最多的种类的数量值 - 1&lt;&#x3D;总数-数量最多的种类的数量值</strong>时，才可以将同种类的物品都隔开。</p><h3 id="例题，吃糖果"><a href="#例题，吃糖果" class="headerlink" title="例题，吃糖果"></a>例题，吃糖果</h3><p>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样； 可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？ 请你写个程序帮忙计算一下。</p><p>输入格式:</p><p>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;&#x3D;1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;&#x3D;1000000)。 </p><p>输出格式:</p><p>对于每组数据，输出一行，包含一个”Yes”或者”No”。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4 1 1</span><br><span class="line">5</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--)</span><br><span class="line">&#123;</span><br><span class="line">int n, num;</span><br><span class="line">//long long保险，毕竟有可能要加很多数，有很大几率超出int</span><br><span class="line">long long sum = 0;</span><br><span class="line">//最大值假定-1完美没问题，因为题目输入都是自然数</span><br><span class="line">int max = -1;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">while (n--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">if (max &lt; num)</span><br><span class="line">max = num;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">//个人感觉这个写法容易理解</span><br><span class="line">if (sum - max &lt;= max - 2)</span><br><span class="line">//sum - max &lt; max - 1</span><br><span class="line">//sum - max + 1 &lt; max</span><br><span class="line">//都是等价的</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-贪心"><a href="#3-贪心" class="headerlink" title="3.贪心"></a>3.贪心</h2><p><strong>核心思想：每次都先取最优解</strong></p><h3 id="例题，田忌赛马"><a href="#例题，田忌赛马" class="headerlink" title="例题，田忌赛马"></a>例题，田忌赛马</h3><p><strong>输入格式:</strong></p><p>输入最多包含 50 个测试用例。每个情况都以第一行的正整数 n （n &lt;&#x3D; 1000） 开始，这是每边的马匹数量。第二行接下来的 n 个整数是 Tian 的马的速度。然后第三行的下一个 n 个整数是国王的马的速度。input 以一行结尾，该行在最后一个测试用例后有一个 0。</p><p><strong>输出格式:</strong></p><p>对于每个 Importing case，输出一行包含单个数字的行，这是 Tian Ji 将获得的最大金额，以银元为单位。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">92 83 71</span><br><span class="line">95 87 74</span><br><span class="line">2</span><br><span class="line">20 20</span><br><span class="line">20 20</span><br><span class="line">2</span><br><span class="line">20 19</span><br><span class="line">22 18</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用田忌最快的马与王最快的马相比较</p><p>如果田忌的快马比王的快马要快</p><p>果断把先用田忌的快马先赢一把(这样赢是代价最小的)</p><p>如果田忌的快马比王的快马要慢</p><p>果断把最慢的马与王最快的马比赛(因为反正都要输，这样我输的价值更大，因为我把最快的马比下去了，可以增加后面其他马赢的机会)</p><p>如果田忌的快马与王的快马<strong>速度一样</strong>——重点！！！</p><p>拿田忌最慢的马和王最慢的马比较</p><p>慢马能赢就让慢马赢，直到慢马比王的慢马速度一样或者更慢时，让慢马和王的快马比，</p><p>之所以慢马速度相同时依旧要让慢马输给快马的原因是如下情况</p><p>王     90 80 70</p><p>田忌 90 80 70</p><p>这时候，如果慢马比掉快马，田忌后面两只都能赢，最后得分200，但如果慢马依旧和慢马比，得分最后是0。</p><p>此外，还需要判断，是否慢吗和快马的速度一样，因为有可能是如下形式</p><p>王     90 90 90</p><p>田忌 90 90 90</p><p>这种情况，不需要减得分。</p><p>答案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = *(<span class="type">int</span>*)a;</span><br><span class="line">    <span class="type">int</span> n2 = *(<span class="type">int</span>*)b;</span><br><span class="line">    <span class="keyword">return</span> n2 - n1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> tianji[num];</span><br><span class="line">        <span class="type">int</span> king[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; num; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tianji[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;king[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        qsort(tianji, num, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">        qsort(king, num, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">        <span class="type">int</span> end = num - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(king[i] &gt; tianji[top])&#123;</span><br><span class="line">                score -= <span class="number">200</span>;</span><br><span class="line">                end -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(king[i] &lt; tianji[top])&#123;</span><br><span class="line">                score += <span class="number">200</span>;</span><br><span class="line">                top += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//慢马能赢就让它赢</span></span><br><span class="line">                <span class="keyword">if</span>(tianji[end] &gt; king[num<span class="number">-1</span>])&#123;</span><br><span class="line">                    score+= <span class="number">200</span>;</span><br><span class="line">                    end -= <span class="number">1</span>;</span><br><span class="line">                    num-= <span class="number">1</span>;</span><br><span class="line">                    i -= <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tianji[end] == king[i])&#123;</span><br><span class="line">                    end -= <span class="number">1</span>; <span class="comment">//慢吗和王的快马的速度一样时不需要减得分</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    score -= <span class="number">200</span>; <span class="comment">//慢马和王的慢马速度一样或者更慢，且慢马比对面快马慢时，需要减得分</span></span><br><span class="line">                    end -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h2><p><strong>核心思想：确立后续</strong></p><h3 id="例题一、母牛的故事"><a href="#例题一、母牛的故事" class="headerlink" title="例题一、母牛的故事"></a>例题一、母牛的故事</h3><p>有一头母牛，它每年年初生一头小母牛。 每头小母牛从第四个年头开始，每年年初也生一头小母牛。 请编程实现在第n年的时候，共有多少头母牛？</p><p>输入格式:</p><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n&#x3D;0表示输入数据的结束，不做处理。</p><p>输出格式:</p><p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：n年母牛的数量等于n-1年母牛的数量加上n-3年母牛的数量，因为n-3年的所有母牛到n年都已经成年了，所以第n年出生的母牛等于n-3年的母牛数量。而第n年的母牛数量等于去年母牛数量加新生母牛数量。故可得递推式m[n] &#x3D; m[n-1] + m[n-3]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long m[55];</span><br><span class="line">    m[1] = 1;</span><br><span class="line">    m[2] = 2;</span><br><span class="line">    m[3] = 3;</span><br><span class="line">    m[4] = 4;</span><br><span class="line">    for(int i = 5; i &lt; 55; i++)&#123;</span><br><span class="line">        m[i] = m[i - 1] + m[i - 3];</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, m[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、儿童队列"><a href="#例题二、儿童队列" class="headerlink" title="例题二、儿童队列"></a>例题二、儿童队列</h3><p>PHT School 有很多学生。有一天，名叫 PigHeader 的校长希望所有学生站成一排。他规定女孩不能单身。换句话说，要么队列中没有女孩，要么不止一个女孩并排站着。情况 n&#x3D;4（n 是孩子的数量）类似于<br>FFFF、FFFM、MFFF、FFMM、MFFM、MMFF、MMMM<br>这里 F 代表女孩，M 代表男孩。满足校长需求的队列总数为 7。你能做一个程序来找到有 n 个孩子的队列总数吗？</p><p>输入格式:</p><p>此问题有多种情况，并由 EOF 结束。在每种情况下，只有一个整数 n 表示子项的数量 （1&lt;&#x3D;n&lt;&#x3D;1000）</p><p>输出格式:</p><p>对于每个测试用例，只有一个整数表示满足 Headmaster 需求的队列数量。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：</p><p>设f[n]合法</p><p>前提，队尾是M,那么前面一定要合法，因为非法无法变成合法。若队伍最后两位是MF,那么只有去掉最后两位后是合法，且该队伍继续进入的下一位是F的情况非法才能变为合法。</p><p>当f[n]的队尾是M时，前n-1个数肯定合法，所以f[n] 的数量等于 f[n-1] 的数量</p><p>当f[n]的队尾是F时，要求f[n]合法，所以f[n-1]的队尾是F.</p><p>此时，f[n-2]既可以合法又可以非法</p><p>f[n-2]合法时，f[n]的数量等于f[n-2].</p><p>而f[n-2]非法时，f[n-2]的队尾两个元素为MF。所以f[n-4]是合法的，f[n]数量等于f[n-4]</p><p>综上三种情况整合起来，得递推式f[n] &#x3D; f[n-1] + f[n-2] + f[n-4]。</p><p>此外，本题还要求高精度，超过了long long，所以用了二维数组来存值每个十进制位的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long f[1001][101] =&#123;0&#125;;</span><br><span class="line">    f[0][1] = 1;</span><br><span class="line">    f[1][1] = 1;</span><br><span class="line">    f[2][1] = 2;</span><br><span class="line">    f[3][1] = 4;</span><br><span class="line">    f[4][1] = 7;</span><br><span class="line">    for(int i = 5; i &lt; 1001; i++)&#123;</span><br><span class="line">        int add =0;</span><br><span class="line">        for(int j = 1; j &lt;= 100; j++)&#123;</span><br><span class="line">            f[i][j] = add + f[i - 1][j] + f[i - 2][j] + f[i - 4][j];</span><br><span class="line">            add = f[i][j] / 10000;</span><br><span class="line">            f[i][j] = f[i][j] % 10000;</span><br><span class="line">            if(add == 0 &amp;&amp; f[i][j] == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;k) != EOF)&#123;</span><br><span class="line">        int end = 0;</span><br><span class="line">        for(int i = 100; i  &gt; 0; i--)&#123;</span><br><span class="line">            if(f[k][i] != 0)&#123;</span><br><span class="line">                end = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d&quot;, f[k][end--]);</span><br><span class="line">        for(int j = end; j &gt; 0; j--)&#123;</span><br><span class="line">            printf(&quot;%04d&quot;, f[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h2><h3 id="例题一、免费馅饼"><a href="#例题一、免费馅饼" class="headerlink" title="例题一、免费馅饼"></a>例题一、免费馅饼</h3><p>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：<br><img src="http://acm.hdu.edu.cn/data/images/1176_1.jpg" alt="img"><br>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</p><p>输入格式:</p><p>输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n&#x3D;0时输入结束。</p><p>输出格式:</p><p>每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。<br>提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5 1</span><br><span class="line">4 1</span><br><span class="line">6 1</span><br><span class="line">7 2</span><br><span class="line">7 2</span><br><span class="line">8 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="例题二、搬寝室"><a href="#例题二、搬寝室" class="headerlink" title="例题二、搬寝室"></a>例题二、搬寝室</h3><p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 &#x3D; 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</p><p>输入格式:</p><p>每组输入数据有两行,第一行有两个数n,k(2&lt;&#x3D;2*k&lt;&#x3D;n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p><p>输出格式:</p><p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="例题三、最大总和"><a href="#例题三、最大总和" class="headerlink" title="例题三、最大总和"></a>例题三、最大总和</h3><p>给定序列 a[1]，a[2]，a[3]……a[n]，你的工作是计算子序列的最大和。例如，给定 （6，-1,5,4，-7），此序列中的最大总和为 6 + （-1） + 5 + 4 &#x3D; 14。</p><p>输入格式:</p><p>输入的第一行包含一个整数 T（1&lt;&#x3D;T&lt;&#x3D;20），表示测试用例的数量。然后是 T 行，每行以一个数字 N（1&lt;&#x3D;N&lt;&#x3D;100000） 开头，然后是 N 个整数（所有整数都在 -1000 到 1000 之间）。</p><p>输出格式:</p><p>对于每个测试用例，您应该输出两行。第一行是 “Case #：”，# 表示测试用例的编号。第二行包含三个整数，序列中的 Max Sum、子序列的开始位置、子序列的结束位置。如果有多个结果，则输出第一个结果。在两个 case 之间输出一个空行。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 6 -1 5 4 -7</span><br><span class="line">7 0 6 -1 1 -6 7 -5</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">14 1 4</span><br><span class="line"></span><br><span class="line">Case 2:</span><br><span class="line">7 1 6</span><br></pre></td></tr></table></figure><p>答案</p><p>解法: </p><p>前提，若第n个元素前面的最大序列值小于0，果断舍弃前面的值，单独列出做为起始值。</p><p>从头开始，用temp不断累加遍历到的元素，不断与max进行比较。若temp&lt;0,则说明后面的值没必要留着前面累赘了，放弃前面，temp&#x3D;0重新开始记录。</p><p>设dp[n]是当前最大序列值数组</p><p>则可得动态规划式：dp[n] &#x3D; dp[n-1] &gt; 0 ? m[n] + dp[n-1] : m[n]。</p><p>下面没有用这个式子，但实际想法差不多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">        int len;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;len);</span><br><span class="line">        int m[100001] = &#123;0&#125;;</span><br><span class="line">        for(int i = 1; i &lt;= len; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        int start = 1; </span><br><span class="line">        int up = 1;</span><br><span class="line">        int end = 1;</span><br><span class="line">        int max = -10000;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">​    for(int i = 1; i &lt;= len; i++)&#123;</span><br><span class="line">​        temp += m[i];</span><br><span class="line">​        if(temp &gt; max)&#123;</span><br><span class="line">​            up = start;</span><br><span class="line">​            max = temp;</span><br><span class="line">​            end = i;</span><br><span class="line">​        &#125;if(temp &lt; 0)&#123;</span><br><span class="line">​            start = i + 1;</span><br><span class="line">​            temp = 0;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    printf(&quot;Case %d:\n%d %d %d\n&quot;, j, max, up, end);</span><br><span class="line">​    if(j!=n)&#123;</span><br><span class="line">​        printf(&quot;\n&quot;);</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-宽度优先搜索BFS"><a href="#6-宽度优先搜索BFS" class="headerlink" title="6.宽度优先搜索BFS"></a>6.宽度优先搜索BFS</h2><p><strong>核心思想：队列</strong></p><p>参考链接<a href="https://blog.csdn.net/aliyonghang/article/details/128724989">宽度优先搜索算法（BFS）详解（超级详细讲解，附有大图）-CSDN博客</a></p><p>bfs函数设计</p><p>可以参考下面两个例题的bfs函数，函数可以不需要参数值，因为不需要递归，在函数里面主要就是在while循环进行入队出队操作，直至遍历到满足的元素后输出结果+return结束，或者队列为空后再输出结果。</p><p>模板一：使用c++的queue对象</p><p>queue&lt;结构体对象名&gt; q</p><p>q.push(元素对象) 放入对象</p><p>q.empty()检测队列是否为空</p><p>q.front() 获取队首元素</p><p>q.pop() 队首元素出队</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//以下两个是必要的头文件！！！！</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct qu&#123;</span><br><span class="line">    int item;</span><br><span class="line">    int step;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">        qu cur = &#123;0, 0&#125;;</span><br><span class="line">        queue&lt;qu&gt; q;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        qu nex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板二、使用c++的priority_queue对象</p><p>priority_queue对象会自动排序，但要求我们自定义的结构体里面有声明相应的排序规则</p><p>注意，priority_queue获取队首用的是top(),不是front()</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int x,y;</span><br><span class="line">bool operator &lt; (const node &amp; a) const</span><br><span class="line">&#123;</span><br><span class="line">return x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个node结构体有两个成员，x和y，它的小于规则是x小者小。</p><p>就是说若当前x比新来的x要小的话，就return true，进行交换，把大的放在靠近队首的地方。</p><p>所以把元素(10,100),(12,60),(14,40),(6,20),(8,20)这五个node加入到队列后，一个个pop()的输出结果是(14,40) (12,60) (10,100) (8,20) (6,80)</p><p>参考链接<a href="https://blog.csdn.net/c20182030/article/details/70757660">【原创】优先队列 priority_queue 详解-CSDN博客</a></p><h3 id="例题一、胜利大逃亡"><a href="#例题一、胜利大逃亡" class="headerlink" title="例题一、胜利大逃亡"></a>例题一、胜利大逃亡</h3><p><strong>7-5 胜利大逃亡</strong></p><p>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会. </p><p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个. 现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.</p><p><img src="https://images.ptausercontent.com/d20c18e1-1c3c-4097-8056-7bb2ad155250.png" alt="image.png"></p><p>输入格式:</p><p>输入数据的第一行是一个正整数K,表明测试数据的数量. 每组测试数据的第一行是四个正整数A,B,C和T(1&lt;&#x3D;A,B,C&lt;&#x3D;50,1&lt;&#x3D;T&lt;&#x3D;1000),它们分别代表城堡的大小和魔王回来的时间. 然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙. (如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)</p><p>输出格式:</p><p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 3 4 20</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 0 0 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 1 1 0</span><br><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><p>答案</p><p>注意点：该题是一个三维数组，需要建立三维坐标，以及六个方向数组。</p><p>2.bfs函数里，该函数没有传入值，在函数开头需要先把队列里元素全都pop掉，再把初始的node cur &#x3D; {0, 0, 0, 0}传入到queue&lt;node&gt; q中。</p><p>3.函数的结束判定。因为只要能遍历到终点或者当前时间已经超时了，那么一定有输出，所以再输出完之后直接return掉结束函数就可以了。</p><p>4.若函数的while循环里，没有最终遍历到终点，那么要记得在while循环外面放一个printf(“-1\n”)语句。</p><p>或者在while循环里最后放上这么一段</p><pre><code>if(q.empty())&#123;    printf(&quot;-1\n&quot;);    return;&#125;</code></pre><p>总之，核心关键点就是记得拿到结果时，<strong>使用return直接结束函数</strong>。因为这个老是会忘记┭┮﹏┭┮。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map[51][51][51];</span><br><span class="line">int vis[51][51][51];</span><br><span class="line">int k, a, b, c, t;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x, y, z;</span><br><span class="line">    int time;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">int dir[6][3] = &#123;&#123;-1, 0, 0&#125;, &#123;1, 0, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, 0, -1&#125;, &#123;0, 0, 1&#125;&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    node n = &#123;0, 0, 0, 0&#125;;</span><br><span class="line">    q.push(n);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        node cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(cur.time &gt; t)&#123;</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur.x == a - 1 &amp;&amp; cur.y == b - 1 &amp;&amp; cur.z == c -1)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, cur.time);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        node nex;</span><br><span class="line">        for(int i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">            int x = cur.x + dir[i][0];</span><br><span class="line">            int y = cur.y + dir[i][1];</span><br><span class="line">            int z = cur.z + dir[i][2];</span><br><span class="line">            if(!vis[x][y][z] &amp;&amp; !map[x][y][z] &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; a &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; b &amp;&amp; z &gt;= 0 &amp;&amp; z &lt; c)&#123;</span><br><span class="line">                nex = &#123;x, y, z, cur.time+1&#125;;</span><br><span class="line">                q.push(nex);</span><br><span class="line">                vis[x][y][z] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">    while(k -- &gt;0)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;t);</span><br><span class="line">        for(int i = 0; i &lt; a; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; b; j++)&#123;</span><br><span class="line">                for(int p = 0; p &lt; c; p++)&#123;</span><br><span class="line">                    scanf(&quot;%d&quot;, &amp;map[i][j][p]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(vis, 0, sizeof(vis));</span><br><span class="line">        vis[0][0][0] = 1;</span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、营救"><a href="#例题二、营救" class="headerlink" title="例题二、营救"></a>例题二、营救</h3><p><strong>7-4 营救</strong></p><p>Angel 被 MOLIGPY 抓住了！他被 Moligpy 关进了监狱。监狱被描述为 N * M （N， M &lt;&#x3D; 200） 矩阵。监狱里有 WALLs、ROAD 和 GUARDs。Angel 的朋友想救 Angel。他们的任务是：接近 Angel。我们假设 “接近 Angel” 是为了到达 Angel 停留的位置。当网格中有守卫时，我们必须杀死他（或她）才能进入网格。我们假设我们向上、向下、向右、向左移动需要 1 个单位的时间，杀死一个守卫也需要 1 个单位的时间。而且我们足够强大，可以杀死所有的守卫。您必须计算接近 Angel 的最短时间。（当然，我们只能将 UP、DOWN、LEFT 和 RIGHT 移动到边界内的相邻网格。</p><p>输入格式:</p><p>第一行包含两个整数，分别代表 N 和 M。然后是 N 行，每行有 M 个字符。“.” 代表道路，“a” 代表 Angel，“r” 代表 Angel 的每个朋友。进程到文件末尾。</p><p>输出格式:</p><p>对于每个测试用例，您的程序应输出一个整数，代表所需的最短时间。如果不存在这样的数字，您应该输出一行，其中包含“可怜的天使必须终生留在监狱中”。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">#.#####.</span><br><span class="line">#.a#..r.</span><br><span class="line">#..#x...</span><br><span class="line">..#..#.#</span><br><span class="line">#...##..</span><br><span class="line">.#......</span><br><span class="line">........</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：</p><p>因为这道题里，time的值不是一直+1，还有可能+2,所以，所以用普通的队列不能ac，因为我们要保证队列前面的元素一定要是time最小的，从前到后遍历时，元素的time是非递减的，这样子才能保证遍历到结束点的时候用时最短。故需要在原普通队列的基础上做一点改动就能够ac了。</p><p>1.queue&lt;node&gt; q 改为 priority_queue&lt;node&gt; q</p><p>2.取队首元素从q.front()改为q.top()。 </p><p>3.结构体里要内嵌比较函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x, y, time;</span><br><span class="line">    <span class="comment">//固定写法，试过了，不能不写const</span></span><br><span class="line">    <span class="type">bool</span> operator &lt;(<span class="type">const</span> node&amp;other)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="comment">//当前元素的值和其他元素的time比较，若返回true,则交换，即当前元素放到后面，所以就是从小到大排</span></span><br><span class="line">        <span class="keyword">return</span> time &gt; other.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易错点：这道题重新写，让我崩溃的是我x和y的范围没有写全，漏了x &gt;&#x3D; 0 和 y &gt;&#x3D; 0，导致一直报段错误，害我找半天错误。</p><p>队列会写的话，优先队列只需要改动一点就行了O(∩_∩)O。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, sx, sy;</span><br><span class="line">char map[201][201];</span><br><span class="line">int vis[201][201];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x, y, time;</span><br><span class="line">    </span><br><span class="line">    bool operator&lt;(const node&amp; other) const &#123;</span><br><span class="line">        return time &gt; other.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">    node st = &#123;sx, sy, 0&#125;;</span><br><span class="line">    q.push(st);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node cur = q.top();</span><br><span class="line">        if(map[cur.x][cur.y] == &#x27;r&#x27;)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, cur.time);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        node nex;</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int x = cur.x + dir[i][0];</span><br><span class="line">            int y = cur.y + dir[i][1];</span><br><span class="line">            if(vis[x][y] == 0 &amp;&amp; map[x][y] != &#x27;#&#x27; &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)&#123;</span><br><span class="line">                if(map[x][y] == &#x27;x&#x27;)&#123;</span><br><span class="line">                    nex = &#123;x, y, cur.time + 2&#125;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    nex = &#123;x, y, cur.time+1&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[x][y] = 1;</span><br><span class="line">                q.push(nex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Poor ANGEL has to stay in the prison all his life.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        q = &#123;&#125;;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            // getchar();</span><br><span class="line">            scanf(&quot;%s&quot;, &amp;map[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                if(map[i][j] == &#x27;a&#x27;)&#123;</span><br><span class="line">                    sx = i; </span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(vis, 0, sizeof(vis));</span><br><span class="line">        vis[sx][sy] = 1;</span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-深度优先搜索DFS"><a href="#7-深度优先搜索DFS" class="headerlink" title="7.深度优先搜索DFS"></a>7.深度优先搜索DFS</h2><p><strong>核心思想：回溯、递归</strong></p><ol><li>为了求得问题的解，先选择某一种可能情况向前探索；</li><li>在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索；</li><li>如此反复进行，直至得到解或证明无解。</li></ol><p>模板</p><p>主要就是设置一个vis数组标记是否访问过。</p><p>难点在如何剪枝</p><p>参考链接<a href="https://blog.csdn.net/qq_47733361/article/details/123858318">DFS (深度优先搜索) 算法详解 + 模板 + 例题，这一篇就够了_dfs算法-CSDN博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int a[510];   //存储每次选出来的数据</span><br><span class="line">int book[510];   //标记是否被访问</span><br><span class="line">int ans = 0; //记录符合条件的次数</span><br><span class="line"></span><br><span class="line">void DFS(int cur)&#123;</span><br><span class="line">if(cur == k)&#123; //k个数已经选完，可以进行输出等相关操作 </span><br><span class="line">for(int i = 0; i &lt; cur; i++)&#123;</span><br><span class="line">printf(&quot;%d &quot;, a[i]);</span><br><span class="line">&#125; </span><br><span class="line">ans++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123; //遍历 n个数，并从中选择k个数 </span><br><span class="line">if(!book[i])&#123; //若没有被访问 </span><br><span class="line">book[i] = 1; //标记已被访问 </span><br><span class="line">a[cur] = i;  //选定本数，并加入数组 </span><br><span class="line">DFS(cur + 1);  //递归，cur+1 </span><br><span class="line">book[i] = 0;  //释放，标记为没被访问，方便下次引用 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题一、骨头者的诱惑"><a href="#例题一、骨头者的诱惑" class="headerlink" title="例题一、骨头者的诱惑"></a>例题一、骨头者的诱惑</h3><p><strong>7-1 骨头的诱惑者</strong></p><p>这只小狗在一个古老的迷宫里发现了一根骨头，这让他非常着迷。然而，当他捡起它时，迷宫开始晃动，小狗能感觉到地面在下沉。他意识到那块骨头是一个陷阱，他拼命想走出这个迷宫。迷宫是一个尺寸为 N x M 的矩形。迷宫里有一扇门。一开始，门是关着的，它会在第 T 秒打开一小段时间（不到 1 秒）。因此，这只小狗必须在第 T 秒到达门口。在每一秒内，他可以将一个块移动到上、下、左、右相邻块中的一个。一旦他进入一个方块，这个方块的地面就会开始下沉，并在下一秒消失。他不能在一个区块上停留超过一秒钟，也不能进入一个被访问过的区块。可怜的小狗能活下来吗？请帮助他。</p><p>输入格式:</p><p>输入由多个测试用例组成。每个测试用例的第一行包含三个整数 N、M 和 T （1 &lt; N， M &lt; 7;0 &lt; T &lt; 50），分别表示迷宫的大小和门打开的时间。接下来的 N 行给出了迷宫布局，每行包含 M 个字符。字符是以下之一： ‘X’：一块墙，小狗不能进入;’S’：小狗的起点;’D’：门;或 ‘.’：一个空块。input 以三个 0 终止。此测试用例不予处理。</p><p>输出格式:</p><p>对于每个测试用例，如果 doggie 可以存活，则在一行中打印 “YES”，否则打印 “NO”。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">..XD</span><br><span class="line">....</span><br><span class="line">3 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">...D</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p>答案</p><p>解法：</p><p>dfs和剪枝</p><p>1.dfs()，以当前元素的位置和时间作为参数</p><p>2.剪枝。当目前时间减去最短距离所需时间时的剩余时间小于0，或者等于奇数时，那么该点一定走不到终点，直接return。</p><p>问题：该代码读取map各个位置的元素时不能使用getchar()加scanf(),cin或者直接scanf(“%s”)就可以，也不知道为什么。我自己重新写时出一堆问题，明明和原代码差不多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, t, nt;</span><br><span class="line">int ex, ey;</span><br><span class="line">char map[10][10];</span><br><span class="line">int flag = 0;</span><br><span class="line">int dir[4][2] = &#123;&#123;0,1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">void dfs(int x, int y, int cnt)&#123;</span><br><span class="line">    if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x == ex &amp;&amp; y == ey &amp;&amp; cnt == t)&#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = t - cnt - fabs(x - ex) - fabs(y - ey);</span><br><span class="line">    if(temp &lt; 0 || temp % 2 == 1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        if(map[x + dir[i][0]][y + dir[i][1]] != &#x27;X&#x27;)&#123;</span><br><span class="line">            map[x + dir[i][0]][y + dir[i][1]] = &#x27;X&#x27;;</span><br><span class="line">            dfs(x + dir[i][0], y + dir[i][1], cnt+1);</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            map[x + dir[i][0]][y + dir[i][1]] = &#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int sx, sy;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t)&amp;&amp;(m+n+t))&#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        //scanf(&quot;%s&quot;, &amp;map[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                cin&gt;&gt;map[i][j];</span><br><span class="line">                if(map[i][j] == &#x27;S&#x27;)&#123;</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(map[i][j] == &#x27;D&#x27;)&#123;</span><br><span class="line">                    ex = i; </span><br><span class="line">                    ey = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map[sx][sy] = &#x27;X&#x27;;</span><br><span class="line">        dfs(sx, sy, 0);</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、FatMouse-和奶酪"><a href="#例题二、FatMouse-和奶酪" class="headerlink" title="例题二、FatMouse 和奶酪"></a>例题二、FatMouse 和奶酪</h3><p><strong>7-7 FatMouse 和奶酪</strong></p><p>FatMouse 在一个城市储存了一些奶酪。城市可以看作是维度 n 的方形网格：每个网格位置都标记为 （p，q），其中 0 &lt;&#x3D; p &lt; n 和 0 &lt;&#x3D; q &lt; n。在每个网格位置，Fatmouse 都在一个洞中隐藏了 0 到 100 块奶酪。现在他要享受他最喜欢的食物了。FatMouse 首先站在位置 （0,0）。他吃掉了自己站着的奶酪，然后水平或垂直地跑到另一个地方。问题是有一只名叫 Top Killer 的超级猫坐在他的洞附近，所以每次他最多可以跑 k 个位置进入洞中，然后被 Top Killer 抓住。更糟糕的是 – 在一个地方吃完奶酪后，FatMouse 变得更胖了。因此，为了获得足够的能量进行下一次跑步，他必须跑到一个比当前洞的奶酪块更多的地方。给定 n、k 和每个网格位置的奶酪块数，计算 FatMouse 在无法移动之前可以吃的最大奶酪量。</p><p>输入格式:</p><p>有几个测试用例。每个测试用例由一行组成，其中包含两个介于 1 和 100 之间的整数：n 行和 k n 行，每行有 n 个数字：第一行包含位置 （0,0） （0,1） 的奶酪块数……（0，n-1）;下一行包含位置 （1,0）、（1,1）、…（1，n-1） 等。input 以一对 -1 结尾。</p><p>输出格式:</p><p>对于每个测试用例，在一行中输出单个整数，给出收集的奶酪块数。</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 2 5</span><br><span class="line">10 11 6</span><br><span class="line">12 12 7</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure><p>答案:</p><p>解法：dfs+dp</p><p>这道题需要注意的是，由于要计算收集的奶酪的最大值，所以我们不能只单纯进行dfs，而应该在dfs过程中运用dp思想，把当前位置可以拿到的最大奶酪数记录到dp数组里。而且由于只能走比自己当前位置大的数的方向，所以没有必要再用vis数组记录当前位置是否被遍历过。</p><p>剪枝:</p><p>若dp数组一开始就赋予了和map数组一样的值，那么进行dfs时，遍历到的位置最大值可能要求好多次。</p><p>从结果推到起点来看，如果我们在dfs中开始先判断dp是否有值，若有，若没有，那么再把同样位置的map值赋给dp当初始值进行最大值搜索，因为这样做，如果从别的位置又遍历到当前位置时，不需要再进行dfs下去，直接return该值即可，因为之前已经dfs过，把当前位置的最大值给记录到了。总之就是当前dp进行dfs后就已经获取最大值了，只是借用dp不为0来进行直接返回。换用其他标记数组也可以达到同样效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[x][y] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x][y] = <span class="built_in">map</span>[x][y];</span><br><span class="line">    <span class="type">int</span> tx, ty, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            tx = dir[i][<span class="number">0</span>] * j + x;</span><br><span class="line">            ty = dir[i][<span class="number">1</span>] * j + y;</span><br><span class="line">            <span class="keyword">if</span>(tx &gt;= <span class="number">0</span> &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; tx &lt; n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[tx][ty] &gt; <span class="built_in">map</span>[x][y])&#123;</span><br><span class="line">                    dp[x][y] = max(<span class="built_in">map</span>[x][y] + dfs(tx, ty), dp[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memset(map, 0, sizeof(map));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;  n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        res = dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-并查集"><a href="#8-并查集" class="headerlink" title="8.并查集"></a>8.并查集</h2><p><strong>核心思想：找父亲findp(), 合并merge()</strong></p><p>1.给每个元素都先把它们自己定义为父亲。</p><p>2.查找目标元素父亲时，使用while循环，直至遍历的当前元素的父亲等于当前元素，此时当前元素即为目标元素的父类。</p><p>3.合并时要注意，合并的是<strong>当前两个元素的父亲</strong>，即先findp(x)和findp(y)，把x和y的父亲先找到，再给y的父亲的父亲设置为x的父亲。而不是直接f[x] &#x3D; y!!!!。</p><p>优化：</p><p>查找目标元素父亲时，顺便把找父亲时遍历的其他元素的f[n]也都直接设置为父亲，这样子可以有效减少之后找父亲的循环次数。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int findp(int x)&#123;</span><br><span class="line">    int r = x;</span><br><span class="line">    //找到最终的父亲</span><br><span class="line">    while(f[r] != r)&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    //给当前元素的f直接设置为父亲的值</span><br><span class="line">    //i存储当前元素，j存储当前元素的f</span><br><span class="line">    int i=x,j;</span><br><span class="line">    while(f[i]!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        j=f[i];</span><br><span class="line">        f[i]=r;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板</p><p>1.findp函数如上面的优化写即可</p><p>2.merge函数</p><p>注意：merge函数有两种写法，一个是在merge里找父亲元素，一个是在调用merge函数之前把父亲找好了再传值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> xp = findp(x);</span><br><span class="line">    <span class="type">int</span> yp = findp(y);</span><br><span class="line">    f[yp] = xp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">f[y] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题一、畅通工程再续"><a href="#例题一、畅通工程再续" class="headerlink" title="例题一、畅通工程再续"></a>例题一、畅通工程再续</h3><p><strong>7-3 畅通工程再续</strong></p><p>全屏浏览切换布局</p><p>作者 刘春英</p><p>单位 杭州电子科技大学</p><p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元&#x2F;米。</p><p>输入格式:</p><p>输入包括多组数据。输入首先包括一个整数T(T &lt;&#x3D; 200)，代表有T组数据。<br>每组数据首先是一个整数C(C &lt;&#x3D; 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;&#x3D; x, y &lt;&#x3D; 1000的整数。</p><p>输出格式:</p><p>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">20 20</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1000 1000</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1414.2</span><br><span class="line">oh!</span><br></pre></td></tr></table></figure><p>答案</p><p>解法</p><p>贪心+并查集</p><p>1.该题使用并查集之前，需要自己在读完所有岛屿信息后，根据条件筛选出两两对应的不同岛屿，把他们的编号和距离存放到结构体数组node中。由于两个for循环遍历完，所以结构体node数组开辟的大小应该是c*(c-1)&#x2F;2。之后使用qsort函数排序后进行并查集操作。</p><p>易错点</p><p>node数组的大小不等于岛的个数c，而是等于<em><em>c</em>(c-1)&#x2F;2</em>*，这点很重要，否则一直报段错误。还有，qsort函数里面排序数量也是c*(c-1),这些都是极易忽视的易错点啊(╯°□°）╯︵ ┻━┻。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int t, c;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    double dis;</span><br><span class="line">&#125;node[10000];</span><br><span class="line">int land[111][2], f[111], vis[101];</span><br><span class="line">int cmp(const void * a, const void * b)&#123;</span><br><span class="line">    struct node x = *(struct node*)a;</span><br><span class="line">    struct node y = *(struct node*)b;</span><br><span class="line">    if(x.dis - y.dis &gt; 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int findp(int x)&#123;</span><br><span class="line">    int r = x;</span><br><span class="line">    while(f[r] != r)&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    int a = x, b;</span><br><span class="line">    while(f[a] != r)&#123;</span><br><span class="line">        b = f[a];</span><br><span class="line">        f[a] = r;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">void merge(int a, int b)&#123;</span><br><span class="line">    f[b] = a;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;c);</span><br><span class="line">        for(int i = 0; i &lt; c; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;land[i][0], &amp;land[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        double dis = 0;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for(int i = 0; i &lt; c-1; i ++)&#123;</span><br><span class="line">            for(int j = i + 1; j &lt; c; j++)&#123;</span><br><span class="line">                dis = sqrt(pow(land[j][0] - land[i][0], 2)+pow(land[j][1]-land[i][1], 2));</span><br><span class="line">                if(dis &gt;= 10 &amp;&amp; dis &lt;= 1000)&#123;</span><br><span class="line">                    node[index].a = i;</span><br><span class="line">                    node[index].b = j;</span><br><span class="line">                    node[index].dis = dis;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; c; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        double sum = 0;</span><br><span class="line">        int num = 0;</span><br><span class="line">        qsort(node, c*(c-1)/2, sizeof(struct node), cmp);</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;</span><br><span class="line">            int fx = findp(node[i].a);</span><br><span class="line">            int fy = findp(node[i].b);</span><br><span class="line">            if(fx != fy)&#123;</span><br><span class="line">                merge(fx, fy);</span><br><span class="line">                sum += node[i].dis;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num == c - 1)</span><br><span class="line">            printf(&quot;%.1lf\n&quot;, sum*100);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;oh!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、Is-It-A-Tree"><a href="#例题二、Is-It-A-Tree" class="headerlink" title="例题二、Is It A Tree"></a>例题二、Is It A Tree</h3><p><strong>7-6 Is It A Tree?</strong></p><p>全屏浏览切换布局</p><p>作者 刘春英</p><p>单位 杭州电子科技大学</p><p>A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties.<br>There is exactly one node, called the root, to which no directed edges point.</p><p>Every node except the root has exactly one edge pointing to it.</p><p>There is a unique sequence of directed edges from the root to each node.</p><p>For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not.<br><img src="https://images.ptausercontent.com/68a90dcf-b7f1-47ae-b69f-e27d254896b6.png" alt="image.png"><img src="https://images.ptausercontent.com/3a21ddd6-66ae-4c58-a4d8-68df04c524bb.png" alt="image.png"><img src="https://images.ptausercontent.com/b85985db-76f8-4b76-9f1a-3fe18f5d5faa.png" alt="image.png"></p><p>In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not.</p><p>输入格式:</p><p>The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero.</p><p>输出格式:</p><p>For each test case display the line <code>Case k is a tree.&quot; or the line </code>Case k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1).</p><p>输入样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8 5 3 5 2 6 4</span><br><span class="line">5 6 0 0</span><br><span class="line">8 1 7 3 6 2 8 9 7 5</span><br><span class="line">7 4 7 8 7 6 0 0</span><br><span class="line">3 8 6 8 6 4</span><br><span class="line">5 3 5 6 5 2 0 0</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1 is a tree.</span><br><span class="line">Case 2 is a tree.</span><br><span class="line">Case 3 is not a tree.</span><br></pre></td></tr></table></figure><p>答案</p><p>解法</p><p>1.一个节点有两个父节点时，这就不是一个树了。所以在合并前，应先判断b是否已经有父节点了。</p><p>2.用一个vis数组来记录节点是否存在，若存在，再根据其是否等于父节点（即该节点是否是根），给sum+1, 若最后sum&#x3D;&#x3D;1,则是树，否则不是树。</p><p>3.空集合是树，即输入为 0 0 的情况。因此需要额外判断。</p><p>易错点</p><p>气死我了，输出样例最后句子有个小数点，但我没注意，结果一直反复查看代码哪里出错了，(╯▔皿▔)╯。另外，该题<strong>不能用两个while循环来读取数据，会一直超时</strong>。也不知道啥原因。所以只能用一个while循环来写，若遍历到了0 0，则调用isAtree()函数判断是否是树，再用initial()函数重置数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10005</span>], vis[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>,index = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findp</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> r = a;</span><br><span class="line">    <span class="keyword">while</span>(r != f[r])&#123;</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x =a, y;</span><br><span class="line">    <span class="keyword">while</span>(f[x] != r)&#123;</span><br><span class="line">        y = f[x];</span><br><span class="line">        f[x] = r;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    f[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initial</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10005</span>; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isAtree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>, index++);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10005</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[i] == i)&#123;</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">1</span> || !ok)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is a tree.\n&quot;</span>, index++);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>, index++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    initial();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">-1</span> &amp;&amp; b == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)&#123;</span><br><span class="line">            isAtree();</span><br><span class="line">            initial();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vis[a] = <span class="number">1</span>;</span><br><span class="line">            vis[b] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[b] != b || a == b)&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> fa = findp(a);</span><br><span class="line">            <span class="type">int</span> fb = findp(b);</span><br><span class="line">            <span class="keyword">if</span>(fa != fb)&#123;</span><br><span class="line">                merge(fa, fb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术总结03-Aop</title>
      <link href="/2024/11/08/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9303-Aop/"/>
      <url>/2024/11/08/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9303-Aop/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring技术总结03-Aop"><a href="#Spring技术总结03-Aop" class="headerlink" title="Spring技术总结03-Aop"></a>Spring技术总结03-Aop</h1><h2 id="一、什么是Aop"><a href="#一、什么是Aop" class="headerlink" title="一、什么是Aop"></a>一、什么是Aop</h2><p>AOP：Aspect Oriented Programming面向切面编程。</p><p>AOP利用的是一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>AOP技术包含了切点表达式和增强方法的知识点。</p><h2 id="二、切点表达式和增强方法"><a href="#二、切点表达式和增强方法" class="headerlink" title="二、切点表达式和增强方法"></a>二、切点表达式和增强方法</h2><p>增强方法用于获取调用切面类的类信息，可以根据其信息进行添加独特的功能。</p><h3 id="1-增强方法"><a href="#1-增强方法" class="headerlink" title="1.增强方法"></a>1.增强方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.定义增强方法</span></span><br><span class="line"><span class="comment"> * 2.使用注解指定对应的方法      @After等</span></span><br><span class="line"><span class="comment"> * 3.配置切点表达式中的方法     在增强方法的注解上配置</span></span><br><span class="line"><span class="comment"> * 4.切面和ioc配置        在类前面添加相应的注解@Component @Aspect</span></span><br><span class="line"><span class="comment"> * 5.开启aspectj注解的支持    在配置类或者配置文件中开启</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span>实践获取目标类的信息</span></span><br><span class="line"><span class="comment"> *      1.全部增强方法中，获取目标方法的信息(方法名，参数，访问修饰符，所属类的信息)</span></span><br><span class="line"><span class="comment"> *          在增强方法的参数中添加JoinPoint形参，该参数包含了目标类的信息</span></span><br><span class="line"><span class="comment"> *      2.返回的结果</span></span><br><span class="line"><span class="comment"> *          增强方法的参数列表中添加(Object result)</span></span><br><span class="line"><span class="comment"> *          在@AfterReturning(value = &quot;execution()&quot;, returning = &quot;result&quot;)中添加returing=&quot;形参名&quot;接收返回结果</span></span><br><span class="line"><span class="comment"> *      3.异常的信息</span></span><br><span class="line"><span class="comment"> *          增强方法的参数列表中添加(Throwable throwable)</span></span><br><span class="line"><span class="comment"> *          在@AfterThrowing(value = &quot;execution()&quot;, throwing = &quot;throwable&quot;)中添加throwing=&quot;形参名&quot;接收返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(15)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdivce</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="comment">//获取方法参数列表</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法参数列表：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//获取方法的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法名称：&quot;</span>+ name);</span><br><span class="line">        <span class="comment">//获取方法的访问修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> joinPoint.getSignature().getModifiers();</span><br><span class="line">        <span class="type">String</span> <span class="variable">modifer</span> <span class="operator">=</span> Modifier.toString(modifiers);</span><br><span class="line">        System.out.println(<span class="string">&quot;访问修饰符：&quot;</span>+ modifer);</span><br><span class="line">        <span class="comment">//获取方法所属类的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法所属类：&quot;</span>+className);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.ldy.service.impl.*.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object result)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法返回值：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.ldy.service.impl.*.*(..))&quot;,throwing = &quot;throwable&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable throwable)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法异常对象：&quot;</span>+ throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Around(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="comment">//    public void around()&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用注解来创建ioc容器对象</span></span><br><span class="line"><span class="comment">//      要求依赖： spring-text</span></span><br><span class="line"><span class="comment">//@SpringJUnitConfig(value= , location= )</span></span><br><span class="line"><span class="comment">//      value: 指定配置类</span></span><br><span class="line"><span class="comment">//      location: 指定配置文件</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = Config.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用注解自动获取ioc容器中的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//若多个类实现某个接口，代理时可以加@Qualifier指定代理的对象</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;demo2&quot;)</span></span><br><span class="line">    <span class="comment">//若不指定，则根据变量名来选对应的代理对象，即demo选Demo,demo2选Demo2</span></span><br><span class="line">    <span class="keyword">public</span> DemoService demo;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> Calculate calculate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        方法参数列表：[1, 2]</span></span><br><span class="line"><span class="comment">        方法名称：div</span></span><br><span class="line"><span class="comment">        访问修饰符：public abstract</span></span><br><span class="line"><span class="comment">        方法所属类：com.ldy.service.impl.Demo</span></span><br><span class="line"><span class="comment">        方法返回值：-1</span></span><br><span class="line"><span class="comment">        div=-1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> demo.div(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;div=&quot;</span> + div);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        方法参数列表：[1, 0]</span></span><br><span class="line"><span class="comment">        方法名称：chu</span></span><br><span class="line"><span class="comment">        访问修饰符：public abstract</span></span><br><span class="line"><span class="comment">        方法所属类：com.ldy.service.impl.Demo</span></span><br><span class="line"><span class="comment">        方法异常对象：java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//        int chu = demo.chu(1, 0);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;chu=&quot; + chu);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> calculate.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;add=&quot;</span>+add);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-切点表达式"><a href="#2-切点表达式" class="headerlink" title="2.切点表达式"></a>2.切点表达式</h3><p> 切点表达式语法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span>切点表达式</span></span><br><span class="line"><span class="comment">*       固定语法： execution(&quot;1 2 3 4 5 6&quot;)</span></span><br><span class="line"><span class="comment">*           1: 访问修饰符</span></span><br><span class="line"><span class="comment">*               public/private</span></span><br><span class="line"><span class="comment">*           2: 返回参数类型</span></span><br><span class="line"><span class="comment">*               int/void/...</span></span><br><span class="line"><span class="comment">*           细节: * 代表任意修饰符和返回参数类型，但不能独立表示其中一个，即不能 * int</span></span><br><span class="line"><span class="comment">*           3: 包名</span></span><br><span class="line"><span class="comment">*               具体: com.ldy.service.impl</span></span><br><span class="line"><span class="comment">*               单层模糊: com.ldy.service.*  *单层模糊</span></span><br><span class="line"><span class="comment">*               多层模糊: com..impl   ..多层模糊</span></span><br><span class="line"><span class="comment">*               细节: 不能..开头</span></span><br><span class="line"><span class="comment">*               查询所有包下的impl包  *..impl</span></span><br><span class="line"><span class="comment">*               全部包: *..</span></span><br><span class="line"><span class="comment">*           4: 类名</span></span><br><span class="line"><span class="comment">*               具体: DemoService</span></span><br><span class="line"><span class="comment">*               部分模糊: Demo*   表示以Demo开头的所有类</span></span><br><span class="line"><span class="comment">*               模糊: *</span></span><br><span class="line"><span class="comment">*           5: 方法名  与类名一致</span></span><br><span class="line"><span class="comment">*           6: 方法参数</span></span><br><span class="line"><span class="comment">*               具体: (String, int)</span></span><br><span class="line"><span class="comment">*               部分模糊: (String..)  String后面有没有都无所谓</span></span><br><span class="line"><span class="comment">*               模糊: (..)</span></span><br><span class="line"><span class="comment">*       实战:</span></span><br><span class="line"><span class="comment">*           1.全部包下的impl包的所有参数为int的方法</span></span><br><span class="line"><span class="comment">*               * *..impl.*.*(int)</span></span><br><span class="line"><span class="comment">*           2.某包某类下，访问修饰符公有的，返回值类型是int的全部方法，</span></span><br><span class="line"><span class="comment">*               public int xx.xx.jj.*(..)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">*       切点表达式的提取和复用</span></span><br><span class="line"><span class="comment">*           法1.当前类中定义空方法</span></span><br><span class="line"><span class="comment">*               添加注解@Pointcut()里面传要复用的切点表达式 @Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line"><span class="comment">*           法2.创建一个存储切点的类</span></span><br><span class="line"><span class="comment">*               增强方法的注解里写存储切点类的 全类名.方法名()</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h2 id="三、依赖和注解介绍"><a href="#三、依赖和注解介绍" class="headerlink" title="三、依赖和注解介绍"></a>三、依赖和注解介绍</h2><h3 id="aspectj依赖"><a href="#aspectj依赖" class="headerlink" title="aspectj依赖"></a><strong>aspectj依赖</strong></h3><p>在新的子类工程的pom文件里添加aspectj依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a><strong>注解介绍</strong></h3><h4 id="1-Aspect"><a href="#1-Aspect" class="headerlink" title="1.@Aspect"></a>1.<strong>@Aspect</strong></h4><p>作用于类上，声明该类为切面类</p><h4 id="2-Component"><a href="#2-Component" class="headerlink" title="2.@Component"></a>2.<strong>@Component</strong></h4><p>作用于类上，使得该切面类能放到ioc容器</p><h4 id="3-Order"><a href="#3-Order" class="headerlink" title="3.@Order"></a>3.<strong>@Order</strong></h4><p>作用于类上，用于声明切面类的优先级，数字越小级别越优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(10)</span></span><br></pre></td></tr></table></figure><h4 id="4-Pointcut"><a href="#4-Pointcut" class="headerlink" title="4.@Pointcut"></a>4.@Pointcut</h4><p>@Pointcut作用于空方法上，为其他方法提供切点表达式。</p><h4 id="4-切面类的方法上的注解"><a href="#4-切面类的方法上的注解" class="headerlink" title="4.切面类的方法上的注解"></a>4.切面类的方法上的注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*       使用注解配置</span><br><span class="line">*           前置  <span class="meta">@Before</span></span><br><span class="line">*           后置  <span class="meta">@AfterReturning</span></span><br><span class="line">*           最后  <span class="meta">@After</span></span><br><span class="line">*           异常  <span class="meta">@AfterThrowing</span></span><br><span class="line">*           环绕  <span class="meta">@Around</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这些注解可以指定切点表达式，也可以引用本类或其他类的切点表达式。</p><p>直接指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure><p>引用本类的切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">//该类中的表达式提取</span></span><br><span class="line"><span class="meta">@Before(&quot;pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;事务开启&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用其他类中的切点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类中切点表达式提取</span></span><br><span class="line"><span class="meta">@After(&quot;com.ldy.pointcut.MyPointcut.all())</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void after()&#123;</span></span><br><span class="line"><span class="string">    System.out.println(&quot;</span>事务结束<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>被引用的切点类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPointcut</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* *..impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">impl</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.ldy..*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-EnableAspectJAutoProxy"><a href="#5-EnableAspectJAutoProxy" class="headerlink" title="5.@EnableAspectJAutoProxy"></a>5.@EnableAspectJAutoProxy</h4><p>作用于配置类上面，用于开启Aspectj注解支持</p><h2 id="四、实操"><a href="#四、实操" class="headerlink" title="四、实操"></a>四、实操</h2><p>简单实操如下</p><h3 id="1-配置类"><a href="#1-配置类" class="headerlink" title="1.配置类"></a>1.配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&#123;&quot;com.ldy.service&quot;, &quot;com.ldy.advice&quot;,&quot;com.ldy.pointcut&quot;&#125;)</span></span><br><span class="line"><span class="comment">//开启支持Aspectj的注解配置</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAspectAutoProxy用于开启Aspectj的注解支持</p><h3 id="2-切面类"><a href="#2-切面类" class="headerlink" title="2.切面类"></a>2.切面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   增强类的内部存储增强代码</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*      1.定义方法存储增强代理</span></span><br><span class="line"><span class="comment">*           具体定义几个根据实际需要</span></span><br><span class="line"><span class="comment">*       2.使用注解配置</span></span><br><span class="line"><span class="comment">*           前置  @Before</span></span><br><span class="line"><span class="comment">*           后置  @AfterReturning</span></span><br><span class="line"><span class="comment">*           最后  @After</span></span><br><span class="line"><span class="comment">*           异常  @AfterThrowing</span></span><br><span class="line"><span class="comment">*           环绕  @Around</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="comment">//@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myaop</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法报错了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.ldy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Service类"><a href="#3-Service类" class="headerlink" title="3.Service类"></a>3.Service类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ldy.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ldy.service.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试类"><a href="#4-测试类" class="headerlink" title="4.测试类"></a>4.测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">        <span class="type">DemoService</span> <span class="variable">demo</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;demo&quot;</span>, DemoService.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> demo.div(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;div=&quot;</span> + div);</span><br><span class="line"><span class="comment">//        int chu = demo.chu(2, 0);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;chu=&quot; + chu);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo02</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Aop的实现原理"><a href="#五、Aop的实现原理" class="headerlink" title="五、Aop的实现原理"></a>五、Aop的实现原理</h2><p>2024&#x2F;12&#x2F;6 突然想起aop的实现原理</p><p>静态代理和动态代理可参考以下文章，有空再用自己的语言整理整理</p><p><a href="https://blog.csdn.net/xiaojin21cen/article/details/79487769">AOP的实现原理 —— 静态代理 和 动态代理（ Spring AOP）_aspectj 静态代理-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring java ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术总结02-IoC</title>
      <link href="/2024/10/31/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9302-IoC/"/>
      <url>/2024/10/31/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9302-IoC/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring技术总结02-IoC"><a href="#Spring技术总结02-IoC" class="headerlink" title="Spring技术总结02-IoC"></a>Spring技术总结02-IoC</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p> Ioc：Inverse of Control的简写，为 控制反转，指把创建对象交给Spring进行管理。即不通过new 对象的方式在dao、service等Impl类中获取对象，而是通过读取<strong>xml文件</strong>或者<strong>配置类</strong>的方式创建一个统一管理所有对象的<strong>ApplicationContext类</strong>，通过**getBean()**的方法获取所需对象。</p><p>Spring中的IoC容器就是IoC思想的一个落地产品实现。IoC容器中管理的组件也叫做bean。</p><h2 id="二、基于xml方式管理bean"><a href="#二、基于xml方式管理bean" class="headerlink" title="二、基于xml方式管理bean"></a>二、基于xml方式管理bean</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h3><p>1.根据上一篇文章，已经按要求重新创建了一个项目。</p><p><img src="/../images/image-20241031163048915.png" alt="image-20241031163048915"></p><p>2.创建实体类和xml配置文件</p><p>配置文件创建方式如下图</p><p><img src="/../images/image-20241031164148051.png" alt="image-20241031164148051"></p><p>实体类创建</p><p><img src="/../images/image-20241031165746906.png" alt="image-20241031165746906"></p><p><img src="/../images/image-20241031165803766.png" alt="image-20241031165803766"></p><p><img src="/../images/image-20241031165824485.png" alt="image-20241031165824485"></p><h3 id="2-管理bean对象——基本操作"><a href="#2-管理bean对象——基本操作" class="headerlink" title="2.管理bean对象——基本操作"></a>2.管理bean对象——基本操作</h3><p>在spring01.xml上编写语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.通过无参构造函数创建实例化的组件，配置方法</span></span><br><span class="line"><span class="comment">    &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span></span><br><span class="line"><span class="comment">        id: 组件的标识，自定义名字，方便读取对象</span></span><br><span class="line"><span class="comment">        class: 组件的全限定符，即全类名</span></span><br><span class="line"><span class="comment">`   默认是单例模式，声明两个相同的组件信息，会实例化两个组件对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.bean.User&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.基本属性注入</span></span><br><span class="line"><span class="comment">    在bean标签中添加&lt;property name=&quot;&quot; value/ref=&quot;&quot; &gt;标签</span></span><br><span class="line"><span class="comment">            name:组件set方法去掉set后面一个字母小写的规则命名，例如setName -&gt; name</span></span><br><span class="line"><span class="comment">            value: 直接赋值即可，注意传值类型</span></span><br><span class="line"><span class="comment">            ref: 其他组件的id</span></span><br><span class="line"><span class="comment">    注意：若set方法中的参数是基本类型，用value直接赋值，若是其他类，要用ref取相应的id。</span></span><br><span class="line"><span class="comment">         在组件中一定要给属性注入的属性添加set方法！！！</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.bean.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;白小纯&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--3.对象类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;user2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--4.构造器属性注入 </span></span><br><span class="line"><span class="comment">      &lt;constructor-arg 进行DI配置</span></span><br><span class="line"><span class="comment">          value : 直接赋值</span></span><br><span class="line"><span class="comment">          ref : 所要引用对象的bean的id</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--多参数构造器的情况</span></span><br><span class="line"><span class="comment">            三种方式</span></span><br><span class="line"><span class="comment">                1.按构造器的参数默认顺序配置</span></span><br><span class="line"><span class="comment">                2.按构造器的参数的参数名定位赋值</span></span><br><span class="line"><span class="comment">                3. 按构造器的参数的索引值定位赋值，从0开始</span></span><br><span class="line"><span class="comment">以下的实现在上述实体类中并没有设置，从之前的文件复制修改的，了解即可</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.按构造器的参数默认顺序配置   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ggbone&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.按构造器的参数的参数名定位赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ggbone&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3. 按构造器的参数的索引值定位赋值，从0开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ggbone&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们写一个测试类进行测试，看看是否能成功获取对象并执行方法。</p><p>测试时的ioc容器对象创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    创建ioc容器</span></span><br><span class="line"><span class="comment">//    有四个实现类，最常用的是ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">推荐创建方式， new 实现类(String...),传入一个或多个ioc配置文件名称</span></span><br><span class="line"><span class="comment">配置文件的名称是根据编译后的target文件中的的classes进行查找的，由于resources下面直接创建了xml文件</span></span><br><span class="line"><span class="comment">，所以相对应的classes下直接有相应的xml文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-03.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取Bean对象</span></span><br><span class="line"><span class="comment">//方法1,只传入bean的id名，需要强转，不推荐</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)applicationContext.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"><span class="comment">//方法2，传入bean的id和相应的Class类</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line"><span class="comment">//方法3， 只传入要获取的类的Class</span></span><br><span class="line"><span class="comment">//要求：</span></span><br><span class="line"><span class="comment">//   使用该方法必须在配置文件里，有且只能有该类的一个Bean，不能有多个</span></span><br><span class="line"><span class="comment">//   若多个，则报异常 NoUniqueBeanDefinitionException</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line"><span class="comment">//此外，可以通过该类的父类的Class获取对象</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> applicationContext.getBean(Animal.class);</span><br></pre></td></tr></table></figure><p>推荐在test文件夹下面创建测试类，如下图所示。</p><p><img src="/../images/image-20241031184949948.png" alt="image-20241031184949948"></p><p>这里我们可以看到成功的获取了对象和实现了相应的方法</p><p><img src="/../images/image-20241031185027013.png" alt="image-20241031185027013"></p><h3 id="3-其他细节内容"><a href="#3-其他细节内容" class="headerlink" title="3.其他细节内容"></a>3.其他细节内容</h3><p>以下代码均是之前学习时的产物，没必要重新写了，就复制过来了</p><p>1.bean标签的属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    类似tomcat的servlet的生命周期</span></span><br><span class="line"><span class="comment">            init-method: 在该对象创建后就调用指定的对象的一个函数，必须是无参、public且返回值为void</span></span><br><span class="line"><span class="comment">            destory-mothod: 该对象销毁时调用的方法，要求同上</span></span><br><span class="line"><span class="comment">            注意：简而言之就是一旦管理这个bean的类被创建后就会调用init-method,类close()后就会调用destory-method。与通过getBean()获取对象无关，因为bean对象早就创建了，这只是引用创建的对象而已。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    scope属性指定该Bean每次被Ioc容器对象使用getBean()方法获取后是否是单例的</span></span><br><span class="line"><span class="comment">            prototype: 多例</span></span><br><span class="line"><span class="comment">            singleton: 单例， 默认值</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            容器管理范围:</span></span><br><span class="line"><span class="comment">                单例模式下的 Bean 由 Spring 容器管理其整个生命周期，包括创建和销毁。</span></span><br><span class="line"><span class="comment">                多例模式下的 Bean 由客户端代码管理其生命周期，Spring 容器仅负责创建。</span></span><br><span class="line"><span class="comment">            所以多例模式下的Bean在Ioc容器close()后不会被调用destroy-method</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;javaBean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ldy.ioc04.JavaBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2.获取原始类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--.直接通过原始类赋值获取DataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.配置文件赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过配置文件赋值给原始类获取DataSource</span></span><br><span class="line"><span class="comment">      &lt;context:property-placeholder 引用配置文件 location=&quot;classpath:druid.properties&quot;指明配置文件在类路径下</span></span><br><span class="line"><span class="comment">      使用$&#123;变量名&#125;来获取配置文件中的属性值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:druid.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;xxx.url&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.配合注解进行包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--指定包下面进行注解扫描</span><br><span class="line">        base-package： 包名，该包以下的所有类和子包中的所有类都会被扫描</span><br><span class="line">--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.ldy&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="三、基于配置类的方式管理bean"><a href="#三、基于配置类的方式管理bean" class="headerlink" title="三、基于配置类的方式管理bean"></a>三、基于配置类的方式管理bean</h2><p>Spring从2.5版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化Spring的xml配置。</p><p>Spring通过注解实现自动装配：</p><ol><li>引入依赖</li><li>开启组件扫描</li><li>使用注解定义Bean</li><li>依赖注入</li></ol><h3 id="1-注解介绍"><a href="#1-注解介绍" class="headerlink" title="1.注解介绍"></a>1.注解介绍</h3><p>基本的类上注解</p><p><img src="/../images/image-20241031192752509.png" alt="image-20241031192752509"></p><p><strong>@ComponentScan用于批量注册bean。</strong></p><p>这个注解会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器容器中。</p><p><strong>@Autowired注入</strong><br>        单独使用@Autowired注解，默认根据类型装配（byType）</p><p>@Autowired注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须存在，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在就注入，不存在也不报错。</p><p><strong>@Qualifier搭配@Autowired使用</strong></p><p>若@Autowired注入的类有多个实现类，需要指定某个实体类时，在@Autowired注解下面添加@Qualifier(“指定实现类的id”)来指定注入的实现类。</p><p><strong>@Resource整合了@Autowired和@Qualifier一起的功能</strong></p><ol><li>指定@Resource中的name，则根据名称装配</li><li>未指定name时，则根据属性名装配</li><li>未指定name，属性名也不一致，则根据类型装配</li></ol><p>使用该注解需要导入如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@PropertySource配置文件引用</strong></p><p>示例:@PropertySource(value&#x3D;”classpath:jdbc.properties”),与xml的配置文件路径写法一致。</p><h3 id="2-实际操作"><a href="#2-实际操作" class="headerlink" title="2.实际操作"></a>2.实际操作</h3><p><strong>1.简单操作</strong></p><p>创建配置类</p><p><img src="/../images/image-20241031195230545.png" alt="image-20241031195230545"></p><p>给各个组件添加注解，以下是其中一个类</p><p><img src="/../images/image-20241031195322823.png" alt="image-20241031195322823"></p><p>给之前写的类添加上上述注解之后，用AnnotationConfigApplicationContext获取ApplicationContext类进行测试。</p><p><img src="/../images/image-20241031194955240.png" alt="image-20241031194955240"></p><p><strong>2.详细内容</strong></p><p>之前所学习时的配置类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用配置类而不使用xml进行ioc容器的配置</span></span><br><span class="line"><span class="comment">   @Configuration   ioc配置类</span></span><br><span class="line"><span class="comment">   @@ComponentScan   包扫描</span></span><br><span class="line"><span class="comment">   @PropertySource    配置文件引用</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.ldy&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value=&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfigure</span> &#123;</span><br><span class="line">    <span class="comment">//  bean由@Bean注解标注，并且对象类型为方法返回的类型，id默认为方法名</span></span><br><span class="line">    <span class="comment">//  配置文件的Di配置由参数（注解+参数声明）来获取配置参数，以便进行依赖注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;xxx.url&#125;&quot;)</span> String url, <span class="meta">@Value(&quot;$&#123;xxx.driverClassName&#125;&quot;)</span> String driverClassName,<span class="meta">@Value(&quot;$&#123;xxx.username&#125;&quot;)</span> String username, <span class="meta">@Value(&quot;$&#123;xxx.password&#125;&quot;)</span> String password)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//    配置类的Di中，参数作为方法参数被传入</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。用注解配置还是很方便的。</p>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring java ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术总结01-环境搭建</title>
      <link href="/2024/10/29/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9301-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/10/29/Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%9301-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring技术总结01-环境搭建"><a href="#Spring技术总结01-环境搭建" class="headerlink" title="Spring技术总结01-环境搭建"></a>Spring技术总结01-环境搭建</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Spring指的是Spring Framework，通常我们称之为Spring框架。Spring框架是一个分层的面向切面的Java应用程序的一站式解决框架，它是Spring技术栈的核心和基础，是为了解决企业级引用开发的复杂性而创建的。</p><p> Spring有两个核心模块：IoC和AOP。</p><p> Ioc：Inverse of Control的简写，为 控制反转，指把创建对象交给Spring进行管理。即不通过new 对象的方式在dao、service等Impl类中获取对象，而是通过xml文件或者配置类的方式统一管理所有对象，将所需对象注入到其他对象。其他</p><p> AOP：Aspect Oriented Programming 的简写，为 面向对象编程。AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP还解决一些系统层面上的问题，比如日志、事务、权限等。</p><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a><strong>1.创建项目</strong></h3><p>首先，使用Idea中maven这个中间件来创建一个项目。</p><p><img src="/../images/image-20241030183104957-17302943901662.png" alt="image-20241030183104957"></p><h3 id="2-检查Maven设置"><a href="#2-检查Maven设置" class="headerlink" title="2.检查Maven设置"></a><strong>2.检查Maven设置</strong></h3><p>创建完成之后，记得要查看Idea的settings中的Build,Execution,Deployment-&gt;Build Tools-&gt;Maven中的Maven home path,把其改为自己配置的maven文件夹路径，而不是idea默认自带的，然后检查User settings file 和local repository的路径是否正确，不正确要勾选Override进行修改。</p><p><img src="/../images/image-20241030183334305.png" alt="image-20241030183334305"></p><h3 id="3-导入基本依赖以及相关实用插件推荐"><a href="#3-导入基本依赖以及相关实用插件推荐" class="headerlink" title="3.导入基本依赖以及相关实用插件推荐"></a><strong>3.导入基本依赖以及相关实用插件推荐</strong></h3><p><strong>基本依赖项</strong></p><p>1.spring-context依赖。当spring-context依赖引入后，spring的基础依赖已经引入了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.junit5测试依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.11.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>插件推荐</strong></p><p>1.JBLJavaToWeb插件。方便创建web项目。</p><p><img src="/../images/image-20241030193153121.png" alt="image-20241030193153121"></p><p>在项目根文件夹上右键会出现JBLJavaToWeb选项，点击之后，会自动将项目改为web工程项目。</p><p><img src="/../images/image-20241030193425685.png" alt="image-20241030193425685"></p><p>即在src文件下添加webapps文件夹</p><p><img src="/../images/image-20241030194249420.png" alt="image-20241030194249420"></p><p>并在项目的pom.xml文件里设置packing标签内容为war</p><p><img src="/../images/image-20241030194424280.png" alt="image-20241030194424280"></p><p>2.maven-search插件。该插件可以搜索依赖，选择所需依赖的版本，复制依赖的导入语句，省去了去官网查询依赖的麻烦。</p><p><img src="/../images/image-20241030200033114.png" alt="image-20241030200033114"></p><p>使用方法，在Idea上方导航栏的Tools中的Maven Serach选项。</p>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring java ioc aop tx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线音乐播放器项目03</title>
      <link href="/2024/10/11/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE03/"/>
      <url>/2024/10/11/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE03/</url>
      
        <content type="html"><![CDATA[<h1 id="在线音乐播放器项目03"><a href="#在线音乐播放器项目03" class="headerlink" title="在线音乐播放器项目03"></a>在线音乐播放器项目03</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于网页移植，原本是想把学的音乐播放器移植到原来写的代码中，但经过该音乐播放器的html、css代码学习后，发现自己原来的页面代码写的依托，结构比较混乱，故我决定抛弃原来的页面，转而针对当前音乐播放器的页面进行更改和重新设计。</p><h3 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h3><h4 id="一-页面设计"><a href="#一-页面设计" class="headerlink" title="一.页面设计"></a>一.页面设计</h4><p>1.将原有的界面进行了扩展，增加了播放设置和音量调节功能，并且将其移动至页面下方。</p><p><img src="/../images/image-20241011205539766.png" alt="image-20241011205539766"></p><p>2.增加了侧边导航栏进行功能扩展。</p><p><img src="/../images/image-20241011205618172.png" alt="image-20241011205618172"></p><p>3.搜索功能的展现与音乐列表展开的实现原理一致，将其放在页面左边。同时实现了交互，异步通过后端爬虫获取歌曲数据。</p><p><img src="/../images/image-20241011205741029.png" alt="image-20241011205741029"></p><p><img src="/../images/image-20241011211226658.png" alt="image-20241011211226658"></p><h4 id="二、音乐信息爬取"><a href="#二、音乐信息爬取" class="headerlink" title="二、音乐信息爬取"></a>二、音乐信息爬取</h4><p>原本我想爬取音乐搜索器来进行音乐数据的爬取，以为它已经实现了网易云音乐数据的爬取，但它的内容是动态加载的，需要使用动态爬取的方式，效率低，而且我只能爬到搜索到的第一首歌曲的具体信息，其他的歌曲我看了源码没有找到可以获取的数据，此外，我的爬虫只能爬取英文歌曲和部分中文歌曲，查了很多信息，不知道为什么，一些中文歌曲在爬取时不能成功爬取，明明网址是对的，自己输入可以正常访问，考虑到了编码问题，但还是没发现问题出在哪里。</p><p>所以我打算重新设计爬虫，直接爬取网易云的，但目前爬虫教程都是python爬取网易云，所以我准备学习python的爬取方式再将思想移植到java爬虫里。</p><p>原来的想法代码展示。</p><p><img src="/../images/image-20241011210651630.png" alt="image-20241011210651630"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在实现音乐信息爬取以及相关交互bug的修复后，对于后面页面的功能扩展和页面新增的进度会变得缓慢，我想还是先学习更多的前后端·知识之后再来进行实现。哎，实现这个项目还是要挺多知识，感觉自己学了挺多，但做起来还是好多东西要学。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> 音乐播放器 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线音乐播放器项目02</title>
      <link href="/2024/10/01/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE02/"/>
      <url>/2024/10/01/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE02/</url>
      
        <content type="html"><![CDATA[<h1 id="在线音乐播放器项目02"><a href="#在线音乐播放器项目02" class="headerlink" title="在线音乐播放器项目02"></a>在线音乐播放器项目02</h1><h3 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h3><h5 id="1-初步构建了上方导航栏，以及实现了搜索联想功能-如下图所示。"><a href="#1-初步构建了上方导航栏，以及实现了搜索联想功能-如下图所示。" class="headerlink" title="1.初步构建了上方导航栏，以及实现了搜索联想功能,如下图所示。"></a>1.初步构建了上方导航栏，以及实现了搜索联想功能,如下图所示。</h5><p><img src="/../images/image-20241001003911303.png" alt="image-20241001003911303"></p><p>通过看之前的javaweb项目重新复习一遍了搜索联想功能的实现。</p><h5 id="2-设置了分页查询功能。"><a href="#2-设置了分页查询功能。" class="headerlink" title="2.设置了分页查询功能。"></a>2.设置了分页查询功能。</h5><p>这次的分页查询并没有像之前的web项目一样，通过每次点击相应的图标而发送请求到servlet中进行交互，而是通过vue的帮助，实现了一次获取数据即可实现分页查询功能，很是方便。</p><h5 id="3-重新设计了音乐播放器的显示"><a href="#3-重新设计了音乐播放器的显示" class="headerlink" title="3.重新设计了音乐播放器的显示"></a>3.重新设计了音乐播放器的显示</h5><p>由于html自带的audio标签的样式不是很好看，所以查找了各种信息，最终在B站找到了一个很不错的视频，通过该视频的学习，在另一个网页初步构建了新的音乐播放器，后续会完成该播放器其余内容后将其移植到当前的音乐播放器项目里。如下图所示。</p><p><img src="/../images/image-20241001004512225.png" alt="image-20241001004512225"></p><p>学习视频链接【HTML+CSS3+JS实现音乐播放器项目】<a href="https://www.bilibili.com/video/BV1tj411N7SH?vd_source=ad14811b0629f215912c584fbe9d9875%E8%BF%99%E4%B8%AA%E8%A7%86%E9%A2%91%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%94%B6%E8%8E%B7%E7%9B%B8%E5%BD%93%E5%A4%9A%EF%BC%8C%E8%AE%A9%E6%88%91%E5%AF%B9%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%9C%89%E4%BA%86%E6%96%B0%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E4%B8%8E%E8%A7%84%E8%8C%83%E3%80%82">https://www.bilibili.com/video/BV1tj411N7SH?vd_source=ad14811b0629f215912c584fbe9d9875这个视频可以说收获相当多，让我对网页布局有了新的认识和更好的写代码逻辑与规范。</a></p><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>我先把分页查询功能完善后，晚点再写吧。</p><p>2024&#x2F;10&#x2F;7</p><h5 id="一、自定义音乐播放器交互功能实现流程："><a href="#一、自定义音乐播放器交互功能实现流程：" class="headerlink" title="一、自定义音乐播放器交互功能实现流程："></a>一、自定义音乐播放器交互功能实现流程：</h5><p>1.先通过ajax将音乐数据从数据库中读取出来存入变量musiclist中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.加载音乐列表信息</span></span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/mvn01/test&quot;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        musiclist = data;</span><br><span class="line">        <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">       <span class="title function_">renderMusicList</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.在点击播放按钮后，除了要播放当前音乐外，还需要将页面背景和音乐信息卡片的内容进行更改，由于该功能具有复用性，所以需要新建加载函数来实现相应的内容更改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据信息，设置页面对应的标签内容</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;.name&quot;</span>).<span class="title function_">text</span>(data.<span class="property">name</span>);</span><br><span class="line">    $(<span class="string">&quot;.singer&quot;</span>).<span class="title function_">text</span>(data.<span class="property">singer</span>);</span><br><span class="line">    $(<span class="string">&quot;.time&quot;</span>).<span class="title function_">text</span>(data.<span class="property">time</span>);</span><br><span class="line">    $(<span class="string">&quot;.cover img&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, data.<span class="property">cover</span>);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, data.<span class="property">audio_url</span>);</span><br><span class="line">    $(<span class="string">&quot;.mask_bg&quot;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">        <span class="attr">background</span>: <span class="string">`url(&quot;<span class="subst">$&#123;data.cover&#125;</span>&quot;) no-repeat center center`</span>,</span><br><span class="line">        <span class="string">&quot;background-size&quot;</span> : <span class="string">&quot;cover&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>给播放按钮添加点击事件时需要考虑当前的播放状态，一开始的想法是判断当前的播放图标来更改音乐的播放与暂停，但在实现音乐的上一首和下一首的功能时，若当前是播放，会出现下一首显示图标暂停，下下一首显示播放，而实际上都是在播放的问题，因为audio在更换音乐源时，图标没有继续更改。所以为了方便，发现了可以用audio的paused属性<code>$(&quot;audio&quot;).get(0).paused</code> 可以告知音乐是否暂停，若暂停，则返回true。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给播放按钮添加点击事件</span></span><br><span class="line">$(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.判断当前播放状态</span></span><br><span class="line">    <span class="keyword">if</span>($(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="property">paused</span>)&#123;</span><br><span class="line">        <span class="comment">//修改播放状态</span></span><br><span class="line">        isplay = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//0.改变播放图标状态</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/暂停.png&quot;</span>);</span><br><span class="line">        <span class="comment">//1.音乐播放</span></span><br><span class="line"></span><br><span class="line">        $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">play</span>();</span><br><span class="line">        <span class="comment">//2.动态显示卡片信息</span></span><br><span class="line">        $(<span class="string">&quot;.player-info&quot;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">            <span class="attr">top</span>: <span class="string">&#x27;-100%&#x27;</span>,</span><br><span class="line">            <span class="attr">opacity</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;slow&quot;</span>);</span><br><span class="line">        <span class="comment">//3.封面旋转起来</span></span><br><span class="line">        $(<span class="string">&quot;.cover&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;animation-play-state&quot;</span>, <span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//修改播放状态</span></span><br><span class="line">        isplay = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//0.改变播放图标状态</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/播放.png&quot;</span>);</span><br><span class="line">        <span class="comment">//1.音乐暂停播放</span></span><br><span class="line">        $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">pause</span>();</span><br><span class="line">        <span class="comment">//2.动态显示卡片信息</span></span><br><span class="line">        $(<span class="string">&quot;.player-info&quot;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">                <span class="attr">top</span>: <span class="string">&#x27;0%&#x27;</span>,</span><br><span class="line">                <span class="attr">opacity</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;slow&quot;</span>);</span><br><span class="line">        <span class="comment">//3.封面旋转暂停</span></span><br><span class="line">        $(<span class="string">&quot;.cover&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;animation-play-state&quot;</span>, <span class="string">&quot;paused&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.播放后重新渲染音乐列表</span></span><br><span class="line">    <span class="title function_">renderMusicList</span>(musiclist);</span><br></pre></td></tr></table></figure><p>4.实现上一首和下一首播放时，要注意变量的范围，不能一直加也不能一直减，所以要对音乐索引的临界点进行判定。此外再调用render函数和触发播放按钮的点击事件来进行音乐的播放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给上一首按钮绑定事件</span></span><br><span class="line">$(<span class="string">&quot;#prevBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.当前播放音乐索引减一</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        currentIndex --;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//若是第一首，则跳转至最后一首</span></span><br><span class="line">        currentIndex = musiclist.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.调用render函数  重新渲染歌曲信息</span></span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//3.让音乐播放  触发播放按钮事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//给下一首按钮绑定事件</span></span><br><span class="line">$(<span class="string">&quot;#nextBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.当前播放音乐索引加一</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex &lt; musiclist.<span class="property">length</span> - <span class="number">1</span>)&#123;</span><br><span class="line">        currentIndex ++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//若是最后一首，则跳转至第一首</span></span><br><span class="line">        currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.调用render函数  重新渲染歌曲信息</span></span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//3.让音乐播放  触发播放按钮事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.实现音乐播放列表的显示时，我们需要动态的实时更新音乐列表，所以要创建一个可复用的函数renderMusicList()以便播放状态信息的实时更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据音乐列表创建li</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderMusicList</span>(<span class="params">list</span>)&#123;</span><br><span class="line">    <span class="comment">//先清空列表</span></span><br><span class="line">    $(<span class="string">&quot;.music-list&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line">    $.<span class="title function_">each</span>(list, <span class="keyword">function</span>(<span class="params">index, item</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> $li = $(<span class="string">`</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;<span class="subst">$&#123;currentIndex == index ? <span class="string">&quot;playing&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;span&gt;<span class="subst">$&#123;index+<span class="number">1</span> &lt; <span class="number">10</span>? <span class="string">&quot;0&quot;</span>+(index +<span class="number">1</span>) : index + <span class="number">1</span>&#125;</span>.<span class="subst">$&#123;item.name&#125;</span>-<span class="subst">$&#123;item.singer&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">                &lt;span data-index=&quot;<span class="subst">$&#123;index&#125;</span>&quot;&gt;&lt;img class=&quot;play-circle&quot; src=&quot;<span class="subst">$&#123;currentIndex == index &amp;&amp; !$(<span class="string">&quot;audio&quot;</span>).get(<span class="number">0</span>).paused ? <span class="string">&#x27;image/icon/暂停.png&#x27;</span>: <span class="string">&#x27;image/icon/播放.png&#x27;</span>&#125;</span>&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">            &lt;/li&gt;</span></span><br><span class="line"><span class="string">        `</span>);</span><br><span class="line">        <span class="comment">//重新加载列表</span></span><br><span class="line">        $(<span class="string">&#x27;.music-list&#x27;</span>).<span class="title function_">append</span>($li);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数所用的地方有 列表图标的点击事件、音乐列表中的播放按钮点击事件、主界面播放按钮的点击事件。主界面播放按钮的点击事件用到的地方多，涵盖了音乐列表信息更新所要关联的地方，方便实现动态更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给音乐列表绑定事件</span></span><br><span class="line">$(<span class="string">&quot;#openModal&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;.modal&quot;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">            <span class="string">&quot;display&quot;</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_">renderMusicList</span>(musiclist);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//给音乐列表按钮添加点击事件</span></span><br><span class="line">$(<span class="string">&quot;.music-list&quot;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;li span&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//修改当前音乐索引</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;data-index&#x27;</span>))&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        currentIndex = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;data-index&quot;</span>);</span><br><span class="line">        <span class="comment">//先设置标签内容</span></span><br><span class="line">        <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再触发播放功能</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>6.顺序播放、随机播放和单曲循环的实现。该功能应该位于音乐播放结束时实现，所以要监听audio的ended状态，由于在添加移除监听事件需要指定移除的函数，否则无效，所以不能用匿名函数来添加点击事件，所以只能创建相应的函数来进行监听事件的更改。每次点击播放设置图标时，会移除监听audio的上一个事件，再添加当前事件。目前还未实现在随机播放状态下点击下一首时实现随机播放的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给音乐播放设置按钮绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#setBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/随机播放.png&quot;</span>);</span><br><span class="line">        <span class="title class_">RadPlay</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/单曲循环.png&quot;</span>);</span><br><span class="line">        <span class="title class_">CirPlay</span>();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;play-model&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;image/icon/顺序播放.png&quot;</span>);</span><br><span class="line">        $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="title class_">SeqPlay</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//顺序播放</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SeqPlay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, cirplay);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;ended&quot;</span>, seqplay)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">seqplay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    currentIndex = currentIndex &gt; musiclist.<span class="property">length</span> - <span class="number">1</span> ? <span class="number">0</span> : currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//顺序播放直接出发下一首事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机播放</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RadPlay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, seqplay);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;ended&quot;</span>, radplay);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">radplay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//随机获取一个音乐索引</span></span><br><span class="line">    <span class="keyword">var</span> origin = currentIndex;</span><br><span class="line">    <span class="keyword">while</span>(origin == currentIndex)</span><br><span class="line">        currentIndex = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">100</span>) % musiclist.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">//重新渲染音乐信息</span></span><br><span class="line">    <span class="title function_">render</span>(musiclist[currentIndex]);</span><br><span class="line">    <span class="comment">//触发点击事件</span></span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CirPlay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;ended&quot;</span>, radplay);</span><br><span class="line">    $(<span class="string">&quot;audio&quot;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;ended&quot;</span>, cirplay);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cirplay</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#playBtn&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>我觉得网页最难懂的就是css了，样式太多了，设计页面好麻烦。我对前端内容不是很熟悉，所以在调整css样式方面可以说是相当难受，就是调整不到自己想要的显示效果，因为很多css属性我都是一点不清楚，问ai也是牛头不对马脚。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> 音乐播放器 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线音乐播放器搭建项目01</title>
      <link href="/2024/09/26/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE01/"/>
      <url>/2024/09/26/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E9%A1%B9%E7%9B%AE01/</url>
      
        <content type="html"><![CDATA[<h1 id="在线音乐播放器搭建项目01"><a href="#在线音乐播放器搭建项目01" class="headerlink" title="在线音乐播放器搭建项目01"></a>在线音乐播放器搭建项目01</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在学了html,  css, javascript, tomcat，jdbc，jsp等内容之后，闲来无事,又学了maven和vue、mybatis的基础内容，想搭建一个在线音乐播放器的网站，希望是类似于qq音乐和网易云音乐之类的网页音乐播放页面，虽然是不可能的，但还是想着试着自己做一下这个项目来巩固自己所学的内容。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>基于maven项目管理工具，同时遵循JavaEE的MVC设计模式搭建该项目。</p><h4 id="项目文件各部分内容说明："><a href="#项目文件各部分内容说明：" class="headerlink" title="项目文件各部分内容说明："></a>项目文件各部分内容说明：</h4><p><strong>数据库</strong>：先把音乐的相关数据存入到数据库maven当中的music表里，目前包含了四种字段，id, name（其实是文件存放位置）, img（图片存放位置） 和 singer。后期肯定是会添加新的列的，但暂时就放这四个字段。</p><p><strong>java</strong>:基于javaEE的三层架构创建相应文件。</p><p><img src="/../images/image-20240926002554656.png" alt="image-20240926002554656"></p><p><strong>resources</strong>:存放所需配置文件。</p><p><img src="/../images/image-20240926002656127.png" alt="image-20240926002656127"></p><p><strong>webapp</strong>: 存放除了java源码外的其他文件。</p><p><img src="/../images/image-20240926002408273.png" alt="image-20240926002408273"></p><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>由于对前端代码的不熟悉，在构建页面，调整css属性，写js相关代码上面花了不少时间（设置布局好头疼）。</p><p>在找合适的标签进行绑定点击事件时，我一共试了三个标签 <code>&lt;input&gt; &lt;a&gt; 和 &lt;button&gt;</code>,由于input的value与显示的内容一致，button的按钮外观不好看。所以选择了a标签，将其name属性来存放歌曲存放位置信息，这与其展示的文本不冲突，所以很nice。</p><p>一开始我并没有通过vue来渲染页面，而是直接以静态的代码形式布局网页，所以一开始的这段添加点击事件的代码就行不通了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给超链接添加点击事件，由于a标签是动态渲染的，所以js里面的这个方法不能添加到新渲染的a标签中</span></span><br><span class="line"><span class="comment">// var as = document.getElementsByClassName(&quot;music_a&quot;);</span></span><br><span class="line"><span class="comment">// for(var i = 0; i &lt; as.length; i++)&#123;</span></span><br><span class="line"><span class="comment">//     as[i].onclick = playMusic.bind(null, as[i]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>而是转变成了更为简便的把onclick事件直接添加到一个v-for标签下的a标签中即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="keyword">class</span>=<span class="string">&quot;music_a&quot;</span> v-<span class="attr">bind</span>:name=<span class="string">&quot;&#x27;/mvn01/&#x27;+music.name&quot;</span> onclick=<span class="string">&quot;playMusic(this)&quot;</span>&gt;&#123;&#123;music.<span class="property">name</span>.<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]&#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>如下图所示，目前仅通过vue和axios把数据库的信息传递到网页上面并渲染。目前数据库里面就两个音乐信息，所以看着还行，后面肯定要做分页或者一个可下拉式的列表来应对多个数据的情况。</p><p><img src="/../images/image-20240926003227508.png" alt="image-20240926003227508"></p><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><h4 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h4><p>美化当前页面，在当前页面上方设计一个横式选择条或者右方设计一个可展开的页面选择条，来选择其他内容的页面。</p><p>给播放器添加字幕功能。</p><p>展示音乐列表的外观实现。</p><p>设置音乐播放界面。类似于<img src="/../images/image-20240926010101221.png" alt="image-20240926010101221"></p><h4 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h4><p>做好各个页面间的数据交互。</p><h4 id="希望做到项目完成的时刻，加油！！！！！"><a href="#希望做到项目完成的时刻，加油！！！！！" class="headerlink" title="希望做到项目完成的时刻，加油！！！！！"></a>希望做到项目完成的时刻，加油！！！！！</h4>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> 音乐播放器 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵模式</title>
      <link href="/2024/07/30/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/07/30/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="哨兵模式概念"><a href="#哨兵模式概念" class="headerlink" title="哨兵模式概念"></a>哨兵模式概念</h1><p>Redis的哨兵模式（Sentinel）是一种高可用的部署方式，由一个或多个Sentinel实例组成的Sentinel系统可以监控和管理多个Redis实例。在哨兵模式下，有一个或多个哨兵进程监控Redis主服务器和备份服务器的状态，并在主服务器下线时自动切换到备份服务器，继续处理命令请求。<br>详解见链接<a href="http://t.csdnimg.cn/FY1Pq">http://t.csdnimg.cn/FY1Pq</a></p><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>首先在主机上配置个一主两从的redis服务器，这里我配置了3个redis配置文件，其中redis-6381.conf是主节点</p><p><img src="/../images/image-20240730085620963.png" alt="image-20240730085620963"></p><p>再配置至少一个sentinel.conf配置文件，里面只需要加入如下语句（可在命令行用 <code>vi &lt;文件地址&gt;</code> 进行直接编写）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;主节点名称，任意即可&gt;  &lt;主节点ip地址，例127.0.0.1&gt;  &lt;主节点端口号&gt;</span><br></pre></td></tr></table></figure><p>如下所示，conf文件第一行即为加入的语句，语句下面是使用过程中产生的日志</p><p><img src="/../images/image-20240730090039350.png" alt="image-20240730090039350"></p><p>然后在命令行分别启动这三个节点的服务器(例: <code>redis-server myredis/redis-6380.conf</code>) 以及启动哨兵模式 (例: <code>redis-sentinel redis_sentinel/sentinel2.conf</code>)</p><p>最后就可以成功看到命令行中sentinel已经成功监控主节点了</p><p><img src="/../images/image-20240730091105753.png" alt="image-20240730091105753"></p><p>再把端口号为6381的这个主节点服务器关闭(在客户端使用shutdown命令)，可以看到</p><p><img src="/../images/image-20240730091438684.png" alt="image-20240730091438684"></p><p>由最后一句知道，新的主节点转换为了6382，查看6381和6382的从属关系可知已经改变了。</p><p><img src="/../images/image-20240730091615627.png" alt="image-20240730091615627"></p><p>这时，再把原来的主节点6381重新启动，哨兵检测到6381的恢复并主动将其设置为6382的从节点，如下图所示:</p><p><img src="/../images/image-20240730091904396.png" alt="image-20240730091904396"></p><p>至此，哨兵模式的简单实现流程就完成了，更加具体的内容还是查看其他博主的帖子吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="/2024/07/09/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2024/07/09/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="主从复制概念"><a href="#主从复制概念" class="headerlink" title="主从复制概念"></a>主从复制概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower) ; 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p><p>默认情况下，每台Redis服务器都是主节点 ;且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><h2 id="Redis服务启动方式"><a href="#Redis服务启动方式" class="headerlink" title="Redis服务启动方式"></a>Redis服务启动方式</h2><h4 id="1-默认启动方式"><a href="#1-默认启动方式" class="headerlink" title="1.默认启动方式"></a>1.默认启动方式</h4><blockquote><p> 服务端：.&#x2F;redis-server </p><p>client端：.&#x2F;redis-cli </p><p>退出： .&#x2F;redis-cli shutdown</p></blockquote><h4 id="2-指定端口启动"><a href="#2-指定端口启动" class="headerlink" title="2.指定端口启动"></a>2.指定端口启动</h4><blockquote><p> 服务端：.&#x2F;redis-server –port 端口号 </p><p>client端：.&#x2F;redis-cli -p 端口号 </p><p>退出： .&#x2F;redis-cli -p 端口号 shutdown</p></blockquote><h4 id="3-指定端口ip连接"><a href="#3-指定端口ip连接" class="headerlink" title="3.指定端口ip连接"></a>3.指定端口ip连接</h4><blockquote><p>服务端：.&#x2F;redis-server –port 端口号</p><p>client端：.&#x2F;redis-cli -p 端口号 -h 127.0.0.1</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="1-获取当前redis的信息"><a href="#1-获取当前redis的信息" class="headerlink" title="1.获取当前redis的信息"></a>1.获取当前redis的信息</h4><p>注意默认端口为6379，且该端口默认为主节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server  //开启redis服务端, 默认port 6380 ip 127.0.0.1</span><br><span class="line"></span><br><span class="line">redis-cli  //连接到该redis服务端，默认port 6380 ip 127.0.0.1</span><br><span class="line"></span><br><span class="line">info replication  //查看当前redis的信息，含主从节点信息</span><br></pre></td></tr></table></figure><h4 id="2-获取子节点6380的信息"><a href="#2-获取子节点6380的信息" class="headerlink" title="2.获取子节点6380的信息"></a>2.获取子节点6380的信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server --port 6380  //开启端口为6380的服务端</span><br><span class="line"></span><br><span class="line">redis-cli -p 6380 (-h 127.0.0.1 若ip未改，默认可不写)  //redis的cli(客户端)指定端口与ip连接到指定的服务端</span><br><span class="line"></span><br><span class="line">info replication  //查看当前redis的信息，含主从节点信息</span><br></pre></td></tr></table></figure><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h4 id="1-复制端口号6379的redis配置文件到redis的执行目录"><a href="#1-复制端口号6379的redis配置文件到redis的执行目录" class="headerlink" title="1.复制端口号6379的redis配置文件到redis的执行目录"></a>1.复制端口号6379的redis配置文件到redis的执行目录</h4><p>查询redis的配置文件方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config get dir</span><br></pre></td></tr></table></figure><p>这个命令返回的是redis的安装目录，配置文件应位于该目录下，注意etc这个位置是其他文件存放位置</p><h4 id="2-复制配置文件到要启动的redis其他端口的目录下-然后执行以下命令"><a href="#2-复制配置文件到要启动的redis其他端口的目录下-然后执行以下命令" class="headerlink" title="2.复制配置文件到要启动的redis其他端口的目录下,然后执行以下命令"></a>2.复制配置文件到要启动的redis其他端口的目录下,然后执行以下命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.config redis-6380.config</span><br></pre></td></tr></table></figure><p>拷贝的配置文件名自己定，如redis-6380.config</p><h4 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h4><p>下载一个可以打开配置文件的编辑器，推荐subllime</p><p>然后打开配置文件，用ctrl+f查询下面的语句然后进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1. 修改端口号，一主多从模式，此教程中我默认是以6379为主，6380、6381为从</span><br><span class="line"></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 2.开启守护进程模式运行，默认是no，这个要搜</span><br><span class="line"></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 3. 修改pid文件名，我是以端口来区分的</span><br><span class="line"></span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line"></span><br><span class="line"># 4.拷贝多个 redis.conf 配置文件，并按照以上步骤修改配置文件</span><br></pre></td></tr></table></figure><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>因为不了解ubuntu系统，导致我实现主从复制花了2个小时才成功。</p><p>首先一定要先知道redis的服务启动方法，因为这个网上找的有些命令是错误的，导致我开启自定义端口的服务端一直有问题，本文所给命令是我经实践后成功的。</p><p>其次，redis.config这个配置文件我找了半天，才发现在其他文件位置里。同时，要打开配置文件推荐使用sublime。</p><p>最后，不一定要改在配置文件中配置主节点，可以在子节点使用 <code>slaveof 主节点id 主节点端口号</code> 命令来建立主从关系，但如果在配置文件中配置了，那么重启也就不会失效了。</p><h2 id="重大发现"><a href="#重大发现" class="headerlink" title="重大发现"></a>重大发现</h2><p>原来我的操作还是有很大问题，初步了解了linux的命令行操作过后，发现了一个重点，这是针对我电脑的ubuntu系统实现redis主从复制的关键。</p><p>依赖配置文件在服务器端启动redis的方式应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 配置文件地址(例如：myredis/redis-6380.conf)</span><br></pre></td></tr></table></figure><p>然后，重点来了，执行后，命令行提示我Permission Denied而无法启动redis,然后，我用root权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><p>之后再次输入同样的启动语句，虽然没显示redis启动界面，而且看似好像没有发生任何事一样，你依旧可以输入其他语句。</p><p>结果，当我再次打开终端输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380</span><br></pre></td></tr></table></figure><p>发现成功在客户端启动这个redis服务器，随后输入的info replication显示的正是我所配置的redis-6380.conf文件.</p><p>这个成功实现的方法网上找遍了解决方案都没有找到，居然被我误打误撞找到了原因所在。估计是我的这个root权限有点问题，没设置好的缘故。</p><p>然后，就是<strong>服务端：.&#x2F;redis-server –port 端口号</strong> 这个启动redis服务器的方式估计是操作在默认文件夹下的配置文件，那个配置文件并没有被我修改过，所以查看主从关系时发现没有主从节点。</p><p>所以还是要用<code>redis-server 配置文件地址(例如：myredis/redis-6380.conf)</code>这个方式来启动相应文件的redis服务器。</p><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h4 id="9-21日"><a href="#9-21日" class="headerlink" title="9.21日"></a>9.21日</h4><p>之前配置实现主从节点后我发现主从的配置文件都变成了所属者为root，估计是以为配置文件里面的某些设置导致了主从设置后将配置文件的所有者改为了root，此外文件的读写权限也变成了只读。而且使用从节点进行写操作时会失败。</p><p>修改文件所属者和读写权限只要依照下面两条命令执行即可，之后进行操作时，其所属者和读写权限并不会改变，所以还是不知道是什么原因导致我一开始实现主从复制后。权限改变的原因是什么。</p><p>更改文件所属者的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown username 配置文件的路径</span><br></pre></td></tr></table></figure><p>更改文件读写权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+rw 配置文件的路径</span><br></pre></td></tr></table></figure><p>经过发现，redis配置文件里面有个<code>replica-read-only yes</code>的语句，这个语句表明了当前节点若是从节点的话，只能读取数据，不能修改数据，所以要把yes改为no。</p><p>此外，在以普通用户执行<code>redis-server myredis/redis-6380.conf</code>这句命令启动我指定的redis配置文件的服务时，会提示我权限不够，这是因为在配置文件里的语句<code>dir 存放路径</code>没有配置好，导致访问了root权限才能访问的文件夹，这个语句是指定存放rdb文件的位置。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习01</title>
      <link href="/2024/07/07/redis01/"/>
      <url>/2024/07/07/redis01/</url>
      
        <content type="html"><![CDATA[<p><strong>我是通过vm虚拟机安装ubuntu系统来学习redis的。</strong></p><h3 id="一-redis的基本数据结构"><a href="#一-redis的基本数据结构" class="headerlink" title="一.redis的基本数据结构"></a>一.redis的基本数据结构</h3><p>redis有5种基础数据结构，分别是String、Hash、List、Set、SortedSet。除此之外还有HyperLogLog、Geo、Pub&#x2F;Sub, 算是高级的数据结构。</p><h4 id="01-String"><a href="#01-String" class="headerlink" title="01.String"></a>01.String</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name cmower</span><br><span class="line">OK</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;cmower&quot;</span><br><span class="line">&gt; exists name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>1）set 命令用来存储一个键值对，在本例中，name 为 key，cmower 为 值。</p><p>2）get 命令用来获取一个键的值。</p><p>3）exists 命令用来测试一个键值对是否存在，<code>(integer) 1</code> 表示存在，<code>(integer) 0</code> 表示不存在。</p><p>4）del 命令用来删除一个键值对，<code>(integer) 1</code> 表示执行成功，<code>(integer) 0</code> 表示执行失败。</p><p>5）当键值对删除后，再通过 get 命令获取时，结果就为 <code>(nil)</code> 。</p><p>6）keys 命令用来查找键。例：*b表示所有以b结尾的键、 cmower 若存在则返回cmower</p><h4 id="02-List"><a href="#02-List" class="headerlink" title="02.List"></a>02.List</h4><p>Redis 列表由多个节点组成，每个节点包含一个字符串元素。列表可以存储任意数量的元素，而且列表中的元素可以重复。由于列表是双向链表，因此可以从列表的头部或尾部进行操作，这为实现先进先出（FIFO）或后进先出（LIFO）队列提供了基础。</p><p>常用命令<br><code>LPUSH key element [element …]</code></p><ul><li><p>描述：将一个或多个值插入到列表的头部。</p></li><li><p>示例：LPUSH list1 value1 value2</p></li></ul><p><code>RPUSH key element [element …]</code></p><ul><li><p>描述：将一个或多个值插入到列表的尾部。</p></li><li><p>示例：RPUSH list1 value1 value2</p></li></ul><p><code>LPOP key</code></p><ul><li><p>描述：移除并返回列表的第一个元素。</p></li><li><p>示例：LPOP list1</p></li></ul><p><code>RPOP key</code></p><ul><li><p>描述：移除并返回列表的最后一个元素。</p></li><li><p>示例：RPOP list1</p></li></ul><p><code>LRANGE key start stop</code></p><ul><li><p>描述：返回列表中指定范围的元素。</p></li><li><p>示例：LRANGE list1 0 5，返回列表的前六个元素。</p></li></ul><p><code>LLEN key</code></p><ul><li><p>描述：返回列表的长度。</p></li><li><p>示例：LLEN list1</p></li></ul><p><code>LINDEX key index</code></p><ul><li><p>描述：返回列表中指定位置的元素。</p></li><li><p>示例：LINDEX list1 2</p></li></ul><p><code>LREM key count value</code></p><ul><li><p>描述：移除列表中等于 value 的元素。</p></li><li><p>示例：LREM list1 2 value1，从列表头部开始移除前两个等于 value1 的元素。</p></li></ul><p><code>LTRIM key start stop</code></p><ul><li><p>描述：对一个列表进行修剪(trim)，使其只保留指定区间内的元素。</p></li><li><p>示例：LTRIM list1 0 10</p></li></ul><h4 id="03-Set"><a href="#03-Set" class="headerlink" title="03.Set"></a>03.Set</h4><p>Redis 的 Set 集合数据 , 与 List 列表功能相似 , 唯一的区别是 Set 集合中的元素 是 <strong>不允许重复</strong>的 ;</p><p>该 Set 集合 是一个 无序集合 , 存储 String 类型数据 ;</p><p>Set 集合底层是由 Hash 表实现 的 , 本质是 字典结构 , 其 添加 , 删除 , 查找 元素的 时间复杂度 是 O(1) ;</p><p>Java 的 HashSet 集合 内部由 HashMap 实现 , 所有的 值 Value 都指向同一个实例对象 ;</p><p>Redis 的 Set 集合 内部也是由 Hash 实现 , 所有的 值 Value 都指向同一个值 ;</p><p>常用命令</p><p>添加和删除与list差不多一致 SADD, SREM</p><p><code>SMEMBERS key</code></p><ul><li>描述：获取key集合的所有元素</li><li>示例：SMEMBERS name</li></ul><p><code>SISMEMBER key value</code></p><ul><li>描述：判断key键中是否存在value值</li><li>示例：SISMEMBER name Alice. 存在返回1，不存在返回0</li></ul><p><code>SCARD key</code></p><ul><li><p>描述：获取集合元素的个数</p></li><li><p>示例：SCARD name. 返回name中元素的个数</p></li></ul><p><code>SINTER key1 key2</code></p><ul><li><p>描述：获取两个集合的交集</p></li><li><p>示例：SINTER course1 course2</p></li></ul><p><code>SUNION key1 key2</code></p><ul><li><p>描述：获取两个集合的并集</p></li><li><p>示例：SUNION course1 course2</p></li></ul><p><code>SDIFF key1 key2</code></p><ul><li><p>描述：获取两个结合的差集</p></li><li><p>示例：SDIFF course1 course2</p></li></ul><p><code>SMOVE key1 key2 value</code></p><ul><li><p>描述：将key集合中的value值移动到key2集合中，key1中的value消失，key2中出现key1中消失的value</p></li><li><p>示例：SMOVE course1 course2 math. 若course1中不含math，则返回0；若含，则返回1</p></li></ul><h4 id="04-Hash"><a href="#04-Hash" class="headerlink" title="04.Hash"></a>04.Hash</h4><p>哈希类型是指Redis键值对中的<strong>值本身又是一个键值对结构</strong>，形如value&#x3D;[{field1，value1}，…{fieldN，valueN}]，</p><p>Hash主要就是对一个对象的多重属性(如人的姓名，性别，年龄)的存储</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/d17466ab22014931a1565c8046259903.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>同样是存储字符串，Hash 与String 的主要区别？</p><ol><li>把所有相关的值聚集到一个key 中，节省内存空间</li><li>只使用一个key，减少key 冲突</li><li>当需要批量获取值的时候，只需要使用一个命令，减少内存&#x2F;IO&#x2F;CPU 的消耗</li></ol><p><strong>常用命令</strong></p><p><code>HSET key field value</code></p><ul><li>描述：将哈希表key中的域field的值设置为value</li><li>示例：HSET person name ldy</li></ul><p><code>HGET key field</code></p><ul><li>描述：获取哈希表key中的域field的值</li><li>示例：HGET person name</li></ul><p><code>MHSET key field1 value1 field2 value2 ......</code></p><ul><li>描述：同时将多个field-value(字段-值)对设置到哈希表key中</li><li>示例：MHSET person name ldy age 15 sex male</li></ul><p><code>MHGET key field1 field2 ......</code></p><ul><li>描述：同时获取多个哈希表key中字段的值</li><li>示例：MHGET person name age sex</li></ul><p><code>HGETALL key</code></p><ul><li>描述：获取哈希表key中所有字段和值</li><li>示例：HGETALL person</li></ul><p><code>HDEL key field1 [field2、field3、... ]</code></p><ul><li>描述：删除哈希表key中的一个或多个指定字段，不存在的字段将被忽略,返回值为删除的字段个数</li><li>示例：HDEL person name age</li></ul><p><code>HLEN key</code></p><ul><li>描述：获取哈希表中字段的数量，当key不存在时返回0</li><li>示例：HLEN person</li></ul><p><code>HEXISTS key field</code></p><ul><li>描述：查看哈希表是否含有指定字段，有返回1，无返回或者key不存在返回0</li><li>示例：HEXISTS person age</li></ul><p><code>HKEYS key</code></p><ul><li>描述：获取哈希表中所有的字段</li><li>示例：HKEYS person</li></ul><p><code>HVALUES key</code></p><ul><li>描述：获取哈希表中所有字段的属性</li><li>示例：HVALUES person</li></ul><p><code>HINCRBY key field 数值</code></p><ul><li>描述：为哈希表中的字段值加上指定的增量</li><li>示例：HINCRBY person age 10</li><li>注意：增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。对一个储存字符串值的字段执行 HINCRBY 命令将造成一个错误。</li></ul><p><code>HSETNX key field1 value1</code></p><ul><li>描述：为哈希表中不存在的字段赋值</li><li>示例： HSETNX person name ldh age 33</li><li>注意：如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0</li></ul><h4 id="05-SortedSet"><a href="#05-SortedSet" class="headerlink" title="05.SortedSet"></a>05.SortedSet</h4><p>Sorted Sets 与 Sets 类似，是一种集合类型，集合中<strong>不会出现重复的数据（member）</strong>。区别在于 Sorted Sets 元素由两部分组成，分别是 member 和 score。</p><p>member 会关联一个 double 类型的分数（score），sorted sets 默认会根据这个 score 对 member 进行从小到大的排序，如果 member 关联的分数 score 相同，则按照字符串的字典顺序排序。</p><p><img src="D:\MyBlog\img\redis\60daf3de60c4d07fa4eaecac6002acb7.png" alt="60daf3de60c4d07fa4eaecac6002acb7"></p><p>常用命令</p><p><code>ZADD key score1 member1 [socre2 member2、... ...]</code></p><p><code>ZCARD key</code></p><p><code>ZRANGE key start stop [WITHSCORES]</code></p><p><code>ZREVRANGE key start stop [WITHSCORES]</code></p><p><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p><p><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></p><p><code>ZCOUNT key min max</code></p><p><code>ZINCRBY key increment member</code></p><p><code>ZRANK key member</code></p><p><code>ZREVRANK key member</code></p><p><code>ZREM key member [member ...]</code></p><p><code>ZREMRANGEBYRANK key start stop</code></p><p><code>ZREMRANGEBYSCORE key min max</code></p><p><code>ZSCORE key member</code></p><p>详见网址<a href="https://blog.csdn.net/aitangyong/article/details/51967362">redis数据类型SortedSet的常用命令-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EL表达式</title>
      <link href="/2024/05/24/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/05/24/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="  EL表达式"></a><center>  <strong>EL表达式</strong><center></h1><blockquote><h3 id="1-EL表达式概述"><a href="#1-EL表达式概述" class="headerlink" title="1. EL表达式概述"></a><strong>1. EL表达式概述</strong></h3></blockquote><ul><li>EL（Express Language）表达式可以嵌入在JSP页面内部，减少JSP脚本的编写，EL出现的目的是要替代JSP页面中脚本的编写。通俗讲就是通过使用EL表达式来减少java代码的编写。</li></ul><blockquote><h3 id="2-EL从域中取出数据"><a href="#2-EL从域中取出数据" class="headerlink" title="2. EL从域中取出数据"></a><strong>2. EL从域中取出数据</strong></h3></blockquote><ul><li><p>JSP脚本：&lt;%&#x3D;request.getAttribute(name)%&gt;</p></li><li><p>EL表达式替代上面的脚本：${requestScope.name}</p></li><li><p>EL最主要的作用是获得四大域中的数据，格式为<u>${EL表达式}</u></p></li><li><p>EL获得pageContext域中的值：$(pageScope.key);</p></li><li><p>EL获得request域中的值：$(requestScope.key);</p></li><li><p>EL获得session域中的值：$(sessionScope.key);</p></li><li><p>EL获得application域中的值：$(applicationScope.key);</p></li><li><p>EL从四个域中获得某个值:  <u><strong>$(key</strong>)</u></p></li></ul><p> <u><strong>$(key</strong>)</u>该方法和pageContext.findAttribute()一样,同样是依次从pageContext域，request域，session域，application域中 获取属性，在某个域中获取后将不再向后寻找。</p><p><strong>示例：</strong></p><ul><li><p>EL获得普通字符串</p><p><code>$&#123;str&#125;</code></p></li><li><p>EL获得User对象的值</p></li><li><p>EL获得List<String>的值</p></li><li><p>EL获得List<User>的值</p></li><li><p>EL获得Map&lt;String,String&gt;的值</p></li><li><p>EL获得Map&lt;String,User&gt;的值</p></li><li><p>EL获得Map&lt;String, List<User>&gt;的值</p></li></ul><p>​</p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EL </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇博客</title>
      <link href="/2024/05/23/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/23/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是我的第一篇博客，什么也没有诶w(ﾟДﾟ)w！！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/22/hello-world/"/>
      <url>/2024/05/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
